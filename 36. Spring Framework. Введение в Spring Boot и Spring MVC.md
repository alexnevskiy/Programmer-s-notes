Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 7.
# Что такое веб-приложение
## Основные сведения о веб-приложениях
Рассмотрим в общих чертах, что такое веб-приложение с технической точки зрения. Любое веб-приложение состоит из двух частей, таких как.
- **клиентская часть** — то, с чем непосредственно взаимодействует пользователь. Представлена веб-браузером. Браузер отправляет запросы на веб-сервер, получает от него ответы и предоставляет пользователю способ взаимодействия с приложением. Клиентскую часть приложения ещё называют **фронтендом**;
- **серверная часть** — получает запросы от клиента и отправляет ему в ответ данные. Серверная часть содержит логику, которая обрабатывает и иногда сохраняет запрашиваемые клиентом данные перед тем, как отправить ему ответ. Серверную часть также называют **бэкендом**.

Общая схема веб-приложения представлена ниже.
![spring_7.1](/pictures/spring_7.1.png)

Говоря о веб-приложениях, мы обычно имеем в виду клиентскую и серверную части. Но важно учитывать, что бэкенд обслуживает сразу нескольких клиентов на конкурентной основе. Множество людей могут использовать одно и то же веб-приложение в одно и то же время на разных платформах. Пользователи могут открывать приложение в браузере на компьютере, в телефоне, на планшете и т. п.
![spring_7.2](/pictures/spring_7.2.png)
## Способы реализации веб-приложений на основе Spring
Веб-приложения по способу функционирования бывают разные.
1. **Приложения, в которых бэкенд в ответ на запрос клиента даёт полностью готовое представление.** В таких продуктах браузер получает данные от бэкенда и сразу выводит их на экран пользователя.
2. **Приложения с разделением обязанностей между фронтендом и бэкендом.** В таких продуктах бэкенд предоставляет только первичные данные. Получив ответ от бэкенда, браузер не выводит эти данные сразу на экран, а запускает некое особое клиентское приложение, которое получает ответы от сервера, обрабатывает данные и сообщает браузеру, что именно нужно вывести.

Первый вариант, где в приложении нет четкого разделения на клиентскую и серверную части, показан ниже. В таких приложениях практически всё происходит на стороне бэкенда. Бэкенд получает запросы, отражающие действия пользователя, и выполняет некую логику. После этого сервер возвращает браузеру нужную информацию для вывода на экран. Бэкенд передаёт данные в тех форматах, которые браузер может интерпретировать и вывести, — HTML, CSS, изображения и т. п. Сервер также может предоставить сценарии, написанные на языках программирования, которые браузер способен интерпретировать и выполнить (таких как JavaScript).
![spring_7.3](/pictures/spring_7.3.png)

Ниже показано приложение, в котором используется разделение на клиентскую и серверную части. Теперь бэкенд вместо того, что нужно в точности вывести на экран, передает браузеру только первичные данные. Браузер запускает независимое клиентское приложение, которое загружается с сервера в ответ на первый запрос. Приложение получает первичные данные от бэкенда, интерпретирует их и принимает решение о том, как именно следует вывести информацию.
![spring_7.4](/pictures/spring_7.4.png)

На практике встречаются оба варианта. Иногда разработчики называют подход с делением приложений на клиентскую и серверную части современным. Такой вариант упрощает разработку крупных приложений, поскольку реализацией разных частей занимаются разные команды. Это позволяет задействовать больше специалистов. Кроме того, клиентская и серверная части также могут развертываться независимо друг от друга, что для крупных приложений является значительным преимуществом.

Другой подход, при котором деления на клиентскую и серверную части нет, применяется в основном для небольших приложений.
## Использование контейнера сервлетов в веб-разработке
Один из важнейших моментов, который следует учитывать, — это коммуникация между клиентом и сервером. Веб-браузер обменивается данными с сервером по сети через протокол передачи гипертекста — Hypertext Transfer Protocol (HTTP), — который аккуратно регламентирует данный процесс. Но вам, если только вы не увлекаетесь информационными сетями, для создания веб-приложений не нужно знать все нюансы HTTP. Как разработчику программного обеспечения, вам достаточно факта, что этот протокол используется компонентами веб-приложения для обмена данными по принципу «запрос — ответ», когда клиент ожидает ответа на каждый отправленный запрос.

Но значит ли это, что приложение должно уметь обрабатывать HTTP-сообщения? В принципе, при желании можно реализовать такую функцию. Но лучше воспользоваться уже существующим компонентом для поддержки HTTP (если, конечно, вы не хотите немного развлечься написанием низкоуровневого функционала).

В сущности, вам нужно не только что-то понимающее HTTP-запросы, но и что-то способное передать HTTP-запрос и получить ответ для Java-приложения. Это «что-то» называется **контейнером сервлетов** (для которого ещё иногда употребляют термин «веб-сервер»). **Контейнер сервлетов служит для Java-приложения переводчиком с HTTP.** Таким образом, нет необходимости реализовывать коммуникационный уровень в продукте. Одним из самых популярных контейнеров сервлетов считается Tomcat.

Ниже показано, какое место занимает контейнер сервлетов (Tomcat) в архитектуре приложения.
![spring_7.5](/pictures/spring_7.5.png)

Но если функции контейнера сервлетов этим и ограничиваются, почему он называется контейнером сервлетов? Что такое сервлеты?

**Сервлет** — это просто объект Java, который напрямую взаимодействует с контейнером сервлетов. Когда контейнер получает HTTP-запрос, он вызывает метод объекта сервлета, которому передаёт этот запрос в виде параметра. Сервлет отправляет ответ клиенту, сделавшему запрос, а метод получает параметр, представляющий собой HTTP-ответ.

Было время, когда, с точки зрения разработчика, сервлеты являлись главными компонентами бэкенда веб-приложений. Допустим, специалисту требовалось написать для веб-приложения новую страницу, расположение которой указывалось определённым URL (например, */home/profile/edit*). Для этого ему приходилось создавать новый экземпляр сервлета, описывать его конфигурацию в контейнере и назначать заданный путь. В сервлете содержалась логика, позволяющая принимать пользовательский запрос и готовить ответ, включая информацию для браузера о том, как выводить данный ответ на экран. Для любого пути, по которому мог обратиться клиент, разработчик должен был создать в контейнере сервлетов отдельный экземпляр со своей конфигурацией. Этот компонент управляет экземплярами сервлетов, добавленными в контекст, поэтому мы и назвали его контейнером сервлетов. В сущности, у него есть контекст экземпляров, которые он контролирует, подобно тому как Spring управляет бинами в своём контексте. Поэтому компоненты наподобие Tomcat мы называем контейнерами сервлетов.
![spring_7.6](/pictures/spring_7.6.png)

Экземпляры сервлетов обычно не приходится разрабатывать. Мы будем использовать сервлеты в приложениях, создаваемых на основе Spring, но писать сами сервлеты нам не придется, поэтому нет смысла тратить внимание на изучение этого момента. Главное — запомнить, что **сервлет — это точка входа в логику приложения, компонент, с которым напрямую взаимодействует контейнер сервлетов** (в данном случае Tomcat). С его помощью данные из клиентского запроса попадают в приложение, а ответ возвращается клиенту.
![spring_7.7](/pictures/spring_7.7.png)
# Магия Spring Boot
Ниже мы рассмотрим Spring Boot — инструмент для создания современных Spring-приложений. В настоящее время Spring Boot является одним из самых важных проектов экосистемы Spring. Он ускоряет создание Spring-приложений, позволяя сконцентрироваться на бизнес-логике и избавляя от написания огромных кусков кода, ответственного за конфигурацию. Эта возможность особенно полезна для сервисно-ориентированных архитектур (СОА) и микросервисов, для которых создаётся большинство приложений.

Список самых важных опций Spring Boot и тех возможностей, которые они открывают.
- **Упрощенное создание проектов.** Сервис инициализации проекта создаёт пустую, но полностью сконфигурированную заготовку приложения.
- **Диспетчеры зависимостей.** Spring Boot группирует зависимости, используемые для тех или иных целей, и объединяет их с помощью диспетчеров. Больше не нужно выяснять ни полный список зависимостей, которые необходимо добавить в проект с определённой целью, ни то, какие их версии нужны для обеспечения совместимости.
- **Автоконфигурация на основе зависимостей.** На основе зависимостей, добавленных в проект, Spring Boot создаёт несколько конфигураций по умолчанию. Вместо того чтобы задавать все эти конфигурации самому, теперь достаточно изменить отдельные из них, которые не соответствуют вашим потребностям, причём для этого приходится писать меньше кода (или не приходится его писать вообще).
## Упрощённое управление зависимостями с помощью диспетчеров зависимостей
**Диспетчер зависимостей** — это группа зависимостей, добавленная в конфигурацию приложения с определённой целью. В следующем фрагменте кода вы увидите, что в *pom.xml* диспетчер выглядит как обычная зависимость: его имя, как правило, начинается со `spring-boot-starter-`, после чего стоит оборот, описывающий возможности, которые добавляются в приложение:
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

Предположим, мы хотим добавить в приложение веб-функции. Прежде для описания конфигурации веб-приложения на основе Spring приходилось самостоятельно добавлять в *pom.xml* все необходимые зависимости и следить, чтобы их версии были совместимы между собой. Настраивать их было непросто, а следить за их совместимостью — ещё сложнее.

Благодаря диспетчерам больше не приходится обращаться к зависимостям напрямую. Теперь мы запрашиваем функционал. Достаточно просто добавить диспетчер зависимости для определённых свойств приложения — например, подключить веб-функции, базу данных, настройки безопасности. Spring Boot автоматически добавит в приложение необходимые зависимости с правильными, совместимыми версиями, которые обеспечат реализацию нужного функционала. Можно сказать, что **диспетчеры зависимостей — это группы совместимых зависимостей, ориентированные на предоставление определённого функционала**.
![spring_7.8](/pictures/spring_7.8.png)
## Автоматическая конфигурация по соглашению на основе зависимостей
Spring Boot также выполняет автоматическую конфигурацию приложения. Принято говорить, что в Spring Boot используется принцип «**cоглашения важнее конфигурации**».

Автоматическая конфигурация является, пожалуй, самым ценным и популярным из всех описанных свойств Spring Boot. Причина этого станет ясна, стоит лишь запустить приложение. Мы ещё ничего не написали, а только загрузили проект и открыли его в IDE. Но мы уже можем запустить это приложение и увидеть, что оно загружает экземпляр Tomcat, который по умолчанию доступен через порт 8080. В консоли вы увидите примерно следующее:
```
Tomcat started on port(s): 8080 (http) with context path ''
Started Main in 1.684 seconds (JVM running for 2.306)
```

В соответствии с добавленными зависимостями Spring Boot «догадывается», чего вы ожидаете от приложения, и предоставляет некоторые конфигурации по умолчанию. Это настройки, которые обычно используются для того функционала, для которого вы внедряли зависимости.

Например, когда вы добавили зависимость для веб-функционала, Spring понял, что вам понадобится контейнер сервлетов, и настроил экземпляр Tomcat — как правило, разработчики используют именно его. Tomcat для Spring Boot является контейнером сервлетов по соглашению.

**Соглашение** — это наиболее частый вариант конфигурации приложения для выполнения определённых задач. Благодаря тому, что Spring Boot описывает конфигурацию приложения по соглашению, разработчику остаётся только изменить те места, где нужны нестандартные настройки. Благодаря этому приходится писать меньше кода в файле конфигурации (или вообще не приходится его писать).
# Реализация приложения с помощью Spring MVC
Мы создадим нашу первую страницу веб-приложения на основе Spring. Конечно, у нас уже есть проект Spring Boot с конфигурацией по умолчанию, но приложение пока просто запускает сервер Tomcat. Это ещё не делает наше приложение веб-приложением! Нам все ещё нужны страницы, которые можно будет открыть в веб-браузере.

Чтобы добавить в веб-приложение новую страницу, нужно выполнить следующие операции.
1. Написать HTML-документ, содержимое которого будет отображаться в браузере.
2. Написать для веб-страницы, созданной в пункте 1, контроллер с соответствующим действием.
![spring_7.9](/pictures/spring_7.9.png)

Мы вначале создадим статическую веб-страницу, содержимое которой должно отображаться в браузере. Это обычный HTML-документ, и в нашем примере он состоит только из короткого заголовка. Содержимое файла с HTML-страницей показано ниже. Этот файл нужно поместить в папку *resources/static* проекта Maven. В ней по умолчанию размещаются страницы для визуализации в Spring Boot.
```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Home Page</title>
</head>
<body>
	<h1>Welcome!</h1>
</body>
</html>
```

Затем нужно написать контроллер с методом, который будет связывать HTTP-запрос со страницей, возвращаемой приложением в ответ. **Контроллер** — это компонент веб-приложения, который содержит методы (обычно называемые действиями), выполняемыми для определенных HTTP-запросов. В итоге действие контроллера предоставляет ссылку на веб-страницу, которую приложение даёт в ответ на запрос. Чтобы не усложнять первый пример, наш контроллер пока что не будет выполнять какую-то специальную логику. Мы просто настроим действие, которое будет возвращать содержимое документа *home.html*, который мы заранее создали и поместили в папку *resources/static*.

Чтобы отметить класс как контроллер, достаточно воспользоваться аннотацией `@Controller` — это стереотипная аннотация, подобная `@Component` и `@Service`. Таким образом, Spring создаст бин данного класса и добавит его в контекст, чтобы впоследствии этим бином управлять. В классе контроллера можно определить действия контроллера — методы, связанные с определенными HTTP-запросами.

Предположим, мы хотим, чтобы браузер выводил содержимое страницы, когда пользователь задает путь `/home`. Для этого нужно снабдить метод аннотацией `@RequestMapping` и указать данный путь в значении аннотации: `@RequestMapping("/home")`. Метод должен предоставлять строку с именем документа, который приложение будет возвращать в ответ на запрос.
```java
@Controller
public class MainController { 

	@RequestMapping("/home") 
	public String home() { 
		return "home.html"; 
	}
}
```

Теперь запустим веб-приложение, проанализируем его поведение и изучим (в том числе на рисунках) механизм, благодаря которому приложение может так работать. Сначала вы увидите запись в консоли. Там будет сказано, что запускается Tomcat, и будет указан используемый им порт. Если это порт по умолчанию, то Tomcat будет использовать порт 8080:
```
Tomcat started on port(s): 8080 (http) with context path ''
```

Откройте окно браузера на том же компьютере, где вы запустили приложение, и введите в адресной строке следующий адрес: `http://localhost:8080/home`. Не забудьте написать путь `/home`, который мы связали с действием контроллера, иначе получите ошибку и HTTP-ответ со статусом `404 — Not Found`.
![spring_7.10](/pictures/spring_7.10.png)

Ниже показан результат обращения к веб-странице в браузере.
![spring_7.11](/pictures/spring_7.11.png)

Теперь, когда мы проследили за внешним поведением приложения, рассмотрим, какие механизмы за этим стоят. В Spring есть набор компонентов, которые, взаимодействуя между собой, выдают наблюдаемый нами результат. Данные компоненты и последовательность обработки ими веб-запроса показаны ниже.
1. Клиент делает HTTP-запрос.
2. Tomcat получает HTTP-запрос клиента и вызывает компонент сервлета, ответственный за его обработку. В случае Spring MVC это сервлет, указанный в конфигурации Spring Boot. Его мы называем **сервлетом-диспетчером (dispatcher servlet)**.
3. Сервлет-диспетчер является точкой входа в веб-приложение Spring. Tomcat вызывает сервлет-диспетчер для всех полученных HTTP-запросов. Его обязанность — управлять запросами в Spring-приложении. Диспетчер должен найти действие контроллера, которое вызывается в ответ на данный запрос, и определить, что следует вернуть клиенту. Этот сервлет ещё называют **фронтальным контроллером** или **единой точкой входа (front controller)**.
4. Сервлет-диспетчер ищет действие контроллера для ответа на запрос. Чтобы определить, какой контроллер нужно вызвать, сервлет делегирует управление компоненту, который называется **картой обработчиков (handler mapping)**. Она находит действие контроллера, связанное с запросом через аннотацию `@RequestMapping`.
5. Когда нужное действие контроллера будет найдено, сервлет-диспетчер вызывает его. Если на карте обработчиков не нашлось ни одного действия, связанного с запросом, приложение выдает клиенту HTTP-статус `404 — Not Found`. Если же действие есть, контроллер возвращает сервлету-диспетчеру имя страницы, которую нужно отобразить. Её принято называть **представлением (view)**.
6. В этот момент сервлет-диспетчер должен найти представление, имя которого было предоставлено контроллером, получить содержимое представления и отправить его клиенту. Сервлет-диспетчер делегирует обязанность получить содержимое компоненту, который называется **арбитром представлений (view resolver)**.
7. Сервлет-диспетчер возвращает сгенерированное представление клиенту в виде HTTP-ответа.
![spring_7.12](/pictures/spring_7.12.png)

Благодаря этим настройкам Spring (в сочетании со Spring Boot) сильно упрощает разработку веб-приложений. Вам остаётся только написать действия контроллера и связать их с запросами посредством аннотаций. Значительная часть логики скрыта внутри фреймворка, что ускоряет написание приложений и сокращает их код.
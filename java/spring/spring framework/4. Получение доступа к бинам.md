Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 3.

В реальных приложениях приходится обращаться из одного бина к другому напрямую. Для этого Spring может предоставлять ссылку на экземпляр, размещённый в контексте фреймворка. Таким образом устанавливаются связи между бинами (один бин получает ссылку на другой, и после этого он может делегировать ему вызовы). Как вы, вероятно, уже знаете, в объектно-ориентированном программировании при реализации поведения объектов часто возникает необходимость в делегировании определённых функций другим объектам. Поэтому при использовании фреймворка Spring тоже необходимо уметь устанавливать такие связи между объектами.
# Установка связей между бинами, описанными в файле конфигурации
Представим, что в контексте Spring есть два экземпляра: попугай и человек. Мы создадим эти экземпляры и вставим их в контекст. Мы хотим сделать человека владельцем попугая — для этого данные экземпляры нам нужно связать.

Итак, любая установка взаимосвязей между бинами (и **монтаж (wiring)**, и **автомонтаж (autowiring)**) выполняется в два этапа.
1. Сначала нужно добавить бины человека и попугая в контекст Spring.
2. Затем следует установить взаимосвязь между человеком и попугаем.
![spring_3.1](/pictures/spring_3.1.png)

Ниже более схематично изображена взаимосвязь типа **has-A** между объектами «человек» и «попугай».
![spring_3.2](/pictures/spring_3.2.png)
*Эта упрощенная диаграмма отражает взаимосвязь **has-A (владение)** между объектами «человек» и «попугай».*

В следующем фрагменте кода показано, как добавить в файл *pom.xml* проекта Maven зависимость для контекста Spring:
```xml
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.2.7.RELEASE</version>
</dependency>
```

Затем мы определим класс `Parrot`, описывающий объект «попугай», и класс `Person`, описывающий объект «человек».
```java
public class Parrot {

	private String name;
	
	// геттеры и сеттеры
	
	@Override
	public String toString() {
		return "Parrot : " + name;
	}
}

public class Person {

	private String name;
	private Parrot parrot;
	
	// геттеры и сеттеры
}
```

Определение бинов с помощью аннотации `@Bean`.
```java
@Configuration
public class ProjectConfig {

	@Bean
	public Parrot parrot() {
		Parrot p = new Parrot();
		p.setName("Koko");
		return p;
	}
	
	@Bean
	public Person person() {
		Person p = new Person();
		p.setName("Ella");
		return p;
	}
}
```

Теперь можно определить класс `Main` и убедиться, что экземпляры «человек» и «попугай» всё ещё не связаны между собой.
```java
public class Main { 

	public static void main(String[] args) { 
		var context = new AnnotationConfigApplicationContext(ProjectConfig.class);
		
		Person person = context.getBean(Person.class); 
		
		Parrot parrot = context.getBean(Parrot.class); 
		
		System.out.println( "Person's name: " + person.getName());
		System.out.println( "Parrot's name: " + parrot.getName()); 
		System.out.println( "Person's parrot: " + person.getParrot());
	}
}
```

Запустив приложение, вы увидите в консоли примерно следующее:
```
Person's name: Ella
Parrot's name: Koko
ParrotPerson's parrot: null
```

Главное, что нужно здесь заметить, — несмотря на то что экземпляры `Person` и `Parrot` есть в контексте, при попытке вывести в консоль `Person's parrot` («попугай принадлежит человеку») получаем `null`. Вывод `null` означает, что связь между этими экземплярами ещё не установлена.
![spring_3.3](/pictures/spring_3.3.png)
## Монтаж бинов путём прямого вызова одного метода с аннотацией `@Bean` из другого такого же метода
Установим связь между двумя экземплярами — `Person` и `Parrot`. Первый способ (монтаж) заключается в **вызове одного метода из другого в классе конфигурации**. Он очень простой и поэтому популярный.
```java
@Configuration
public class ProjectConfig {

	@Bean
	public Parrot parrot() {
		Parrot p = new Parrot();
		p.setName("Koko");
		return p;
	}
	
	@Bean
	public Person person() {
		Person p = new Person();
		p.setName("Ella");
		p.setParrot(parrot()); // Создание ссылки из бина person на бин parrot
		return p;
	}
}
```

Теперь, запустив приложение, вы увидите, что текст в консоли изменился. Вы обнаружите, что во второй строке `Ella` (экземпляр «человек» в контексте Spring) является хозяйкой `Koko` (экземпляр «попугай» в контексте Spring):
```
Person's name: Ella
Person's parrot: Parrot : Koko
```

Не создается ли при этом два экземпляра типа `Parrot` — один при добавлении в контекст Spring и ещё один, когда метод `person()` напрямую вызывает метод `parrot()`? Нет. На самом деле в приложении существует только один экземпляр `parrot`.

На первый взгляд это может показаться странным, но Spring достаточно «умён», чтобы понять, что вы, вызывая метод `parrot()`, хотите сослаться на размещённый в контексте бин `parrot`. Если для определения бина в контексте Spring была использована аннотация `@Bean`, то Spring отслеживает вызываемые методы и в конкретной ситуации может применить ту или иную логику.

**Если в контексте уже есть бин `parrot`, то вместо того, чтобы вызвать метод `parrot()`, Spring сразу извлекает этот экземпляр из контекста. Если же бин `parrot` в контексте ещё не создан, то Spring вызывает метод `parrot()` и возвращает созданный бин.**
![spring_3.4](/pictures/spring_3.4.png)

В сущности, мы можем легко проверить, так ли это: достаточно добавить в класс `Parrot` конструктор без аргументов и вывести из данного конструктора сообщение в консоль. Сколько раз сообщение появится в консоли? Если всё верно, то мы увидим сообщение только один раз. Проведём эксперимент.
```java
public class Parrot {

	private String name;
	
	public Parrot() {
		System.out.println("Parrot created");
	}
	
	// геттеры и сеттеры
	
	@Override
	public String toString() {
		return "Parrot : " + name;
	}
}
```

Снова запустив приложение, мы увидим, что его результат изменился — теперь там появляется сообщение `Parrot created` (Попугай создан). Вы заметите, что оно выводится только один раз, а следовательно, Spring управляет созданием бинов и вызывает метод `parrot()` лишь однажды:
```
Parrot created
Person's name: Ella
Person's parrot: Parrot : Koko
```
## Монтаж бинов путём передачи параметра в метод с аннотацией `@Bean`
Существует и другой способ прямого вызова метода с аннотацией `@Bean`. Вместо того чтобы непосредственно вызывать метод, определяющий бин, на который мы хотим сослаться, мы будем **добавлять параметр к методу соответствующего типа объектов, и Spring будет предоставлять нам значение через этот параметр**. Данный способ более гибкий. Теперь не имеет значения, как был определён бин, на который мы ссылаемся: с помощью аннотации `@Bean` или посредством стереотипной аннотации наподобие `@Component`.
![spring_3.5](/pictures/spring_3.5.png)

Ниже содержится определение класса конфигурации. Обратите внимание на метод `person()`. Теперь он принимает параметр типа `Parrot` и присваивает ссылку возвращаемому атрибуту экземпляра `person`. При вызове этого метода Spring найдёт в контексте бин `parrot` и внедрит его значение в параметр в методе `person()`.
```java
@Configuration
public class ProjectConfig { 

	@Bean 
	public Parrot parrot() { 
		Parrot p = new Parrot(); 
		p.setName("Koko"); 
		return p; 
	} 
	
	@Bean 
	public Person person(Parrot parrot) { // Spring внедряет бин parrot в этот параметр
		Person p = new Person(); 
		p.setName("Ella"); 
		p.setParrot(parrot); 
		return p; 
	}
}
```

То, что мы сейчас прописали, отныне будем называть **внедрением зависимостей (dependency injection, DI)**. Как следует из названия, технология DI состоит в том, что **фреймворк присваивает значение определённому полю или параметру**. В данном случае Spring присваивает значение параметру метода `person()` при вызове этого метода и устанавливает для него зависимость. **DI — это применение принципа IoC, а IoC подразумевает, что фреймворк управляет выполнением приложения.**
![spring_3.6](/pictures/spring_3.6.png)
*Без использования принципа IoC приложение само контролирует своё выполнение и использует многочисленные зависимости. Приложение, в котором применяется принцип IoC, позволяет зависимости управлять своим выполнением. DI как раз и является примером такого управления. Фреймворк (зависимость) присваивает значение полю объекта, который принадлежит приложению.*

При выполнении приложения в консоли появятся сообщения, подобные показанным ниже. Вы увидите, что попугай `Koko` действительно принадлежит человеку `Ella`:
```
Parrot created
Person's name: Ella
Person's parrot: Parrot : Koko
```
# Внедрение бинов с помощью аннотации `@Autowired`
Рассмотрим ещё один способ установить связь между бинами, размещёнными в контексте Spring. Данная технология, требующая использования аннотации `@Autowired`, будет часто встречаться вам при изменении класса, для которого был определён бин (если этот класс не является частью зависимости). **Аннотация `@Autowired` позволяет пометить свойство объекта, в которое мы хотим включить значение из контекста Spring.** Мы отмечаем это свойство непосредственно в классе, характеризующем объект, куда нужно внедрить зависимость. Благодаря такому подходу связь между двумя объектами становится более заметной, чем при использовании других вариантов. Есть следующие три способа применения аннотации `@Autowired`:
- **внедрение значения в поле класса** — именно такие примеры вам будут встречаться в большинстве описаний данной концепции;
- **внедрение значения через параметры конструктора класса** — этот способ вы будете чаще всего использовать на практике;
- **внедрение значения через сеттер** — в готовом к эксплуатации коде этот метод встречается очень редко.
## Внедрение значений через поля класса с использованием аннотации `@Autowired`
Начнём с самого простого из трёх вариантов использования аннотации `@Autowired`, который также встречается в примерах разработчиков: применение аннотации к полю класса. Несмотря на всю простоту, у данного способа есть свои недостатки — именно поэтому мы избегаем его при написании кода для промышленных программных продуктов.
![spring_3.7](/pictures/spring_3.7.png)

Для начала создадим классы, описывающие два объекта, — `Person` и `Parrot`. Описание класса `Parrot` представлено в следующем примере кода:
```java
@Component
public class Parrot {

	private String name = "Koko";
	
	// геттеры и сеттеры
	
	@Override
	public String toString() {
		return "Parrot : " + name;
	}
}
```

Здесь мы воспользовались стереотипной аннотацией `@Component`. Мы использовали её как альтернативу созданию бина в классе конфигурации. Встретив класс с аннотацией `@Component`, Spring создаёт экземпляр этого класса и добавляет данный экземпляр в контекст. Определение класса `Person` представлено в следующем фрагменте кода:
```java
@Component
public class Person { 

	private String name = "Ella";
	
	@Autowired 
	private Parrot parrot; 
	
	// геттеры и сеттеры
}
```

Определение класса конфигурации представлено в следующем фрагменте кода:
```java
@Configuration
@ComponentScan(basePackages = "beans")
public class ProjectConfig {
}
```

Убедимся, что Spring правильно внедрил ссылку на `parrot`:
```java
public class Main {

	public static void main(String[] args) {
		var context = new AnnotationConfigApplicationContext(ProjectConfig.class);

		Person p = context.getBean(Person.class);

		System.out.println("Person's name: " + p.getName());
		System.out.println("Person's parrot: " + p.getParrot());
	}
}
```

В результате в консоль будет выведено примерно следующее.
```
Person's name: Ella
Person's parrot: Parrot : Koko
```

Почему же этот способ нежелательно применять в рабочем коде? Не то чтобы его там вообще нельзя было использовать, однако в реальных приложениях необходимо гарантировать удобство поддержки и тестирования кода. Внедрение значения непосредственно в поле класса имеет следующие недостатки:
- **нет возможности отметить это поле как `final`** и таким образом гарантировать, что никто не сможет изменить его после того, как оно будет использовано:
```java
@Component
public class Person { 

	private String name = "Ella"; 
	
	// Этот код не скомпилируется. Поле без начального значения нельзя определить final
	@Autowired 
	private final Parrot parrot;
}
```
- **при инициализации приходится самостоятельно управлять значением**, а это сложнее.
## Использование аннотации `@Autowired` для внедрения значения через конструктор
Второй способ внедрения значений в атрибуты объектов при создании бина Spring — это **использование конструктора класса, который определяет экземпляр этого класса**.
![spring_3.8](/pictures/spring_3.8.png)

Мы можем легко переделать реализацию проекта так, чтобы в нём вместо внедрения в поле использовалось внедрение в конструктор. Для этого достаточно изменить класс `Person`. Необходимо определить конструктор класса и снабдить его аннотацией `@Autowired`. Теперь можно установить поле `parrot` как `final`. Никакие изменения в классе конфигурации не нужны.
```java
@Component
public class Person { 

	private String name = "Ella"; 
	
	private final Parrot parrot; 
	
	@Autowired 
	public Person(Parrot parrot) { 
		this.parrot = parrot; 
	} 
	
	// геттеры и сеттеры
}
```

Запустив приложение, мы увидим, что в консоль выводятся те же результаты, что и в примере ранее.
```
Person's name: Ella
Person's parrot: Parrot : Koko
```

> Начиная со Spring 4.3, если класс состоит только из одного конструктора, аннотацию `@Autowired` можно пропустить.
## Внедрение зависимости через сеттер
Разработчики используют внедрение зависимостей в сеттерах нечасто. У этого способа больше недостатков, чем преимуществ: код сложнее читать, нельзя пометить поле как `final`, тестирование не становится проще. Как вы заметите, для этого пришлось лишь изменить класс `Person`.
```java
@Component
public class Person {

	private String name = "Ella";
	
	private Parrot parrot;
	
	// другие геттеры и сеттеры
	
	@Autowired
	public void setParrot(Parrot parrot) {
		this.parrot = parrot;
	}
}
```

При запуске приложения вы получите в консоли те же результаты, что и в примерах ранее.
# Циклические зависимости
Очень удобно, когда созданием и назначением всех зависимостей занимается Spring. Передав фреймворку всю работу, вам не приходится писать множество строк кода, а оставшуюся часть приложения легче читать и понимать. Однако иногда Spring может вносить путаницу. На практике часто встречаются ситуации, когда фреймворк по ошибке создает циклическую зависимость.

**Циклическая зависимость** — это ситуация, когда для создания бина (назовём его Bean A) Spring должен внедрить зависимость от другого бина, пока ещё не существующего (Bean B). Но Bean B, в свою очередь, также требует зависимости от Bean A. И Spring заходит в тупик: он не может создать Bean A, так как для этого нужен Bean B, и не может создать Bean B, так как для этого нужен Bean A.
![spring_3.9](/pictures/spring_3.9.png)

Циклической зависимости легко избежать. **Достаточно убедиться, что у вас нет объектов, при создании которых возникает взаимная зависимость этих объектов друг от друга.** Наличие такой зависимости — пример плохой разработки классов. В этом случае нужно переписать код.

Как показано в следующем фрагменте кода для создания бина `Parrot` требуется бин `Person` и наоборот.
```java
@Component
public class Person {

	private final Parrot parrot;
	
	@Autowired
	public Person(Parrot parrot) { // Для создания экземпляра Person нужен бин Parrot
		this.parrot = parrot;
	}
	
	// Остальной код
}

@Component
public class Parrot {

	private String name = "Koko";
	
	private final Person person;
	
	@Autowired
	public Parrot(Person person) { // Для создания экземпляра Parrot нужен бин Person
		this.person = person;
	}
	
	// Остальной код
}
```

При попытке выполнить приложение с подобной конфигурацией получим примерно следующее исключение:
```
Caused by:
org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'parrot': Requested bean is currently in creation:
Is there an unresolvable circular reference?
at
org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.before
SingletonCreation(DefaultSingletonBeanRegistry.java:347)
```

Этим исключением Spring пытается сообщить о возникшей проблеме. Смысл сообщения вполне понятен: фреймворк столкнулся с циклической зависимостью и говорит о том, какие именно классы её вызвали.
# Выбор из нескольких бинов в контексте Spring
Рассмотрим ситуацию, когда Spring должен внедрить значение в параметр или поле класса, но в контексте существует несколько бинов одного типа и нужно выбрать один из них. Предположим, в контексте Spring есть три бина типа `Parrot`. Согласно конфигурации фреймворк должен включить значение типа `Parrot` в параметр. Что будет делать Spring в этом случае? Какой из нескольких бинов данного типа фреймворк выберет для внедрения?

В зависимости от конкретной реализации возможны следующие варианты.
1. **Идентификатор параметра совпадает с именем одного из бинов, добавленных в контекст** (которое, в свою очередь, идентично имени метода, снабжённого аннотацией `@Bean` и возвращающего значение этого бина). В подобном случае Spring выберет бин с таким же именем, как и у параметра.
2. Идентификатор параметра не совпадает ни с одним из имен бинов, имеющихся в контексте. Тогда можно поступить следующим образом:
	- **отметить один из бинов как первичный** (с помощью аннотации `@Primary`). В этом случае Spring выберет для внедрения первичный бин;
	- **выбрать некий бин и отметить его аннотацией `@Qualifier`**;
	- не делать ничего из выше перечисленного — однако в подобном случае приложение завершится ошибкой и выдаст исключение, сообщающее о том, что в контексте есть несколько бинов одного типа и Spring не может выбрать один из них.

Ниже показан класс конфигурации, в котором определены два экземпляра `Parrot` и используется внедрение через параметры метода.
```java
@Configuration
public class ProjectConfig { 

	@Bean 
	public Parrot parrot1() { 
		Parrot p = new Parrot(); 
		p.setName("Koko"); 
		return p; 
	} 
	
	@Bean 
	public Parrot parrot2() { 
		Parrot p = new Parrot(); 
		p.setName("Miki"); 
		return p; 
	} 
	
	@Bean 
	public Person person(Parrot parrot2) { 
		Person p = new Person(); 
		p.setName("Ella"); 
		p.setParrot(parrot2); 
		return p; 
	}
}
```

Запустив приложение с такой конфигурацией, получим в консоли следующий результат. Обратите внимание на то, что Spring связал бин, описывающий человека, с бином попугая `Miki`, так как имя этого бина — `parrot2`.
```
Parrot created
Person's name: Ella
Person's parrot: Parrot : Miki
```
![spring_3.10](/pictures/spring_3.10.png)

На практике лучше не опираться на имя параметра, так как эти имена часто меняются при рефакторинге или по ошибке. Для надёжности лучше использовать более наглядный вариант, подчёркивающий стремление внедрить определённый бин: **аннотацию `@Qualifier`**. Но и здесь, как показывает опыт, мнения разделились: многие разработчики выступают как за, так и против этой аннотации. В данном случае лучше применять именно аннотацию `@Qualifier`, поскольку она явно обозначает ваши намерения. Другие разработчики полагают, что при ее использовании создаётся ненужный (шаблонный) код.

Ниже применяется аннотация `@Qualifier`. Обратите внимание, что вместо того, чтобы создавать специальный идентификатор для параметра, указано, какой бин нужно внедрить, использовав значение атрибута аннотации `@Qualifier`.
```java
@Configuration
public class ProjectConfig { 

	@Bean public Parrot parrot1() { 
		Parrot p = new Parrot(); 
		p.setName("Koko"); 
		return p; 
	} 
	
	@Bean 
	public Parrot parrot2() { 
		Parrot p = new Parrot(); 
		p.setName("Miki"); 
		return p; 
	} 
	
	@Bean 
	public Person person(@Qualifier("parrot2") Parrot parrot) { 
		Person p = new Person(); 
		p.setName("Ella"); 
		p.setParrot(parrot); 
		return p; 
	}
}
```

Снова запустив приложение, получим в консоли тот же результат:
```
Parrot created
Person's name: Ella
Person's parrot: Parrot : Miki
```

Аналогичная ситуация получается и при использовании аннотации `@Autowired`. В нём мы создадим два бина типа `Parrot` (с аннотацией `@Bean`) и экземпляр `Person` (со стереотипной аннотацией). И настроим Spring так, чтобы один из двух бинов типа `Parrot` внедрялся в бин типа `Person`.

Как показано в следующем фрагменте кода, в класс `Parrot` не добавлена аннотация `@Component`, поскольку в классе конфигурации будет создано два бина типа `Parrot` с помощью аннотации `@Bean`:
```java
public class Parrot {

	private String name;
	
	// геттеры, сеттеры и функция toString()
	}
```

Мы определили бин `Person`, использовав стереотипную аннотацию `@Component`. Обратите внимание на идентификатор, присвоенный параметру конструктора в следующем фрагменте кода. Этот идентификатор называется `parrot2`, потому что бин из контекста Spring, который надо внедрить в этот параметр, назван аналогичным образом:
```java
@Component
public class Person {

	private String name = "Ella";
	
	private final Parrot parrot;

	@Autowired
	public Person(Parrot parrot2) {
		this.parrot = parrot2;
	}
	
	// геттеры и сеттеры
}
```

Определение класса конфигурации c двумя бинами типа `Parrot`.
```java
@Configuration
@ComponentScan(basePackages = "beans")
public class ProjectConfig {

	@Bean
	public Parrot parrot1() {
		Parrot p = new Parrot();
		p.setName("Koko");
		return p;
	}
	
	@Bean // Теперь Spring внедряет бин с именем parrot2 в бин типа Person
	public Parrot parrot2() { 
		Parrot p = new Parrot();
		p.setName("Miki");
		return p;
	}
}
```

Поскольку имя в параметре конструктора совпадает с именем одного из бинов в контексте Spring (`parrot2`), фреймворк внедрит этот бин — как результат, приложение выведет в консоль имя попугая `Miki`:
```java
public class Main {

	public static void main(String[] args) {
		var context = new AnnotationConfigApplicationContext(ProjectConfig.class);

		Person p = context.getBean(Person.class);

		System.out.println("Person's name: " + p.getName());
		System.out.println("Person's parrot: " + p.getParrot());
	}
}
```

Запустив приложение, получим следующий результат:
```
Person's name: Ella
Person's parrot: Parrot : Miki
```

Как и в случае с параметром метода с аннотацией `@Bean`, лучше не полагаться на имя переменной. Вместо этого лучше использовать аннотацию `@Qualifier`, чтобы явно показать: я внедряю определённый бин из контекста. Таким образом мы сводим к минимуму вероятность изменения имени переменной при рефакторинге и, как результат, сбоев в работе приложения.
```java
@Component
public class Person {

	private String name = "Ella";
	
	private final Parrot parrot;
	
	@Autowired
	public Person(@Qualifier("parrot2") Parrot parrot) {
		this.parrot = parrot;
	}
	
	// геттеры и сеттеры
}
```

Поведение приложения не изменится, вывод в консоли останется тем же, но вероятность ошибок в таком коде будет меньше.
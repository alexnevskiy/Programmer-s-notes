Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 6.

**Аспекты** — это способ, которым фреймворк перехватывает вызов метода и может изменить его выполнение. Вы можете повлиять на метод при определённом его вызове. Данная технология позволяет извлечь часть логики, принадлежащей методу. Существуют сценарии, в которых после отделения части кода метод выглядит более понятным. Это позволяет разработчику, разбирающему логику метода, сконцентрировать внимание только на важных деталях. Такой подход называется **аспектно-ориентированным программированием (АОП)**.
# Аспекты в Spring
**Аспект** — это просто часть логики, которую фреймворк реализует, вызывая определённые, выбранные вами методы. При разработке аспекта нужно определить следующее:
- какой код должен выполнять Spring при вызове данных методов. Именно это и называется **аспектом**;
- когда приложение должно выполнять логику аспекта (например, перед, после или вместо вызова метода). Это называется **советом**;
- выполнение каких методов должен перехватывать фреймворк и реализовывать аспект. Это называется **срезом**.

В терминологии аспектов вам также встретится понятие «**точка соединения**» — событие, запускающее выполнение аспекта. Но в Spring это событие всегда одно и то же — вызов метода.

Как при внедрении зависимости, при использовании аспектов объекты, к которым применяются аспекты, должны находиться под управлением фреймворка. Для добавления бинов в контекст Spring, чтобы фреймворк мог их контролировать и применить к ним созданные вами аспекты, вы будете использовать ранее рассмотренные способы. Бин, в котором объявляется прерываемый аспектом метод, называют **целевым объектом**. Все эти новые термины сведены в одну схему ниже.
![spring_6.1](/pictures/spring_6.1.png)
*Терминология аспектов. При вызове определённого метода (**точки соединения**) Spring выполняет некую логику (**аспект**). Нужно определить, в какой момент данная логика должна реализоваться относительно точки соединения (например, перед ней). Вот это «в какой момент» и называется **советом**. Чтобы фреймворк мог перехватить выполнение метода, объект, в котором определён метод, должен быть бином, размещённым в контексте Spring. Таким образом, этот бин становится **целевым объектом** для аспекта.*

Но каким образом Spring перехватывает выполнение метода и применяет логику аспекта? Как уже говорилось выше, для этого соответствующий объект должен быть бином в контексте Spring. Но, поскольку мы сделали этот объект целевым для аспекта, Spring не даст нам прямую ссылку на бин, если мы запросим его из контекста. Вместо этого Spring предоставит объект, который вызывает не метод, а логику аспекта. Принято говорить, что взамен бину Spring предлагает **прокси-объект**. Теперь при получении бина из контекста нам всегда будет даваться его прокси-объект, независимо от того, вызывается ли непосредственно метод `getBean()` для контекста, или же используется DI. Данная технология называется **вплетением**.
![spring_6.2](/pictures/spring_6.2.png)

Ниже показано сравнение процессов, когда вызов метода не перехватывается и перехватывается аспектом. Как видим, в случае с аспектом предполагается, что метод вызывается через прокси-объект, предоставленный Spring. Прокси же применяет логику аспекта и делегирует вызов самому методу.
![spring_6.3](/pictures/spring_6.3.png)
# Реализация аспектов в Spring с помощью АОП
Предположим, что есть некое приложение с классами сервисов, реализующими многочисленные сценарии использования. В соответствии с новыми требованиями приложение должно запоминать время начала и конца выполнения каждого сценария. На совещании вы предложили взять на себя разработку функционала по записи в журнал всех событий старта и окончания сценариев использования.
## Реализация простого аспекта
Создадим новый проект и определим класс сервиса. В этом классе создадим метод, который будем использовать, чтобы проверить наше решение и убедиться, что определённый нами аспект в итоге работает так, как нужно.

Кроме зависимости от контекста Spring, в этот раз нам понадобится зависимость от аспектов Spring.
```xml
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.2.8.RELEASE</version>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-aspects</artifactId>
	<version>5.2.8.RELEASE</version>
</dependency>
```

Чтобы пример был короче и вы могли сконцентрировать внимание на синтаксисе аспектов, мы будем рассматривать только один сервисный объект `CommentService` и его сценарий использования `publishComment(Comment comment)`. Этот метод, определённый в классе `CommentService`, принимает параметр типа `Comment`. `Comment` — это класс модели, который выглядит так:
```java
public class Comment {

	private String text;
	private String author;
	
	// геттеры и сеттеры
}
```

Мы снабдили класс стереотипной аннотацией `@Service`, чтобы создать бин в контексте Spring. В `CommentService` определён метод `publishComment(Comment comment)`, который реализует заданный сценарий использования.
```java
@Service
public class CommentService { 

	private Logger logger = Logger.getLogger(CommentService.class.getName()); 
	
	public void publishComment(Comment comment) { 
		logger.info("Publishing comment:" + comment.getText()); 
	}
}
```

Вы также заметите, что в данном примере для записи сообщений в консоль используется не `System.out`, а объект типа `Logger`. В реальных приложениях для выполнения данного действия `System.out` не применяется. Вместо этого обычно используют фреймворки журналирования, которые предоставляют больше возможностей для записи в журнал и стандартизации журнальных сообщений. Вот несколько хороших:
- [Log4j](https://logging.apache.org/log4j/2.x/);
- [Logback](http://logback.qos.ch/);
- Java Logging API, в комплект которого входит [JDK](http://mng.bz/v4Xq).

Фреймворки журналирования совместимы со всеми Java-приложениями, независимо от того, используется ли в них Spring.

В данном примере используются средства журналирования JDK, чтобы не добавлять в проект лишних зависимостей. При объявлении объекта `logger` необходимо дать ему имя в качестве параметра. Затем данное имя будет появляться в записях журнала, и вам будет проще отслеживать источники сообщений. Для этого часто используют имя класса: `CommentService.class.getName()`.

Нам также нужно создать класс конфигурации, чтобы сообщить Spring, где находятся классы со стереотипными аннотациями.
```java
@Configuration
@ComponentScan(basePackages = "services")
public class ProjectConfig {
}
```

Напишем класс `Main`, который вызывает метод `publishComment()`, определённый в классе сервиса, и проследим за поведением приложения.
```java
public class Main { 

	public static void main(String[] args) { 
		var c = new AnnotationConfigApplicationContext(ProjectConfig.class); 

		var service = c.getBean(CommentService.class); 

		Comment comment = new Comment();
		comment.setText("Demo comment"); 
		comment.setAuthor("Natasha"); 

		service.publishComment(comment); 
	}
}
```

Запустив приложение, вы увидите в консоли примерно следующее:
```
Sep 26, 2020 12:39:53 PM services.CommentService publishComment
INFO: Publishing comment:Demo comment
```

Эти сообщения генерируются методом `publishComment()`. Так работает приложение перед решением описанной ранее задачи. Напомню: нам нужно выводить в консоль сообщения перед вызовом метода сервиса и после него. Теперь добавим в проект класс аспекта, который будет перехватывать вызов метода и добавлять вывод сообщений до и после него.

Чтобы создать аспект, нужно выполнить следующие действия.
1. Активируйте механизм аспектов в Spring-приложении, поставив перед классом конфигурации аннотацию `@EnableAspectJAutoProxy`.
2. Создайте новый класс и внедрите перед ним аннотацию `@Aspect`. Затем, используя либо аннотацию `@Bean`, либо одну из стереотипных аннотаций, добавьте бин этого класса в контекст Spring.
3. Определите метод, в котором будет реализована логика аспекта, и с помощью аннотаций советов сообщите Spring, где и какие методы следует перехватывать.
4. Реализуйте логику аспекта.
![spring_6.4](/pictures/spring_6.4.png)
### Шаг 1. Активировать механизм аспектов в приложении
Прежде всего необходимо сообщить Spring, что в приложении используются аспекты. Когда вы применяете один из механизмов фреймворка, следует его ясно внедрить, снабдив класс конфигурации соответствующей аннотацией. Как правило, имена этих аннотаций начинаются с `Enable`. В данном примере, чтобы реализовать возможность использования аспектов, нам нужна аннотация `@EnableAspectJAutoProxy`.
```java
@Configuration
@ComponentScan(basePackages = "services")
@EnableAspectJAutoProxy // Активирует аспекты в Spring-приложении
public class ProjectConfig {
}
```
### Шаг 2. Создать класс с определением аспекта и добавить экземпляр этого класса в контекст Spring
Теперь нужно создать в контексте Spring новый бин, в котором будет определён аспект. В данном объекте находятся методы, которые будут перехватывать вызов заданного метода и добавлять туда свою логику.
```java
@Aspect
public class LoggingAspect {

	public void log() {
		// позже мы его реализуем
	}
}
```

Чтобы добавить этот экземпляр в контекст Spring, вы можете воспользоваться любым способом. Если выберете аннотацию `@Bean`, не забудьте изменить класс конфигурации, как показано в следующем фрагменте кода. Разумеется, вы также можете воспользоваться стереотипными аннотациями:
```java
@Configuration
@ComponentScan(basePackages = "services")
@EnableAspectJAutoProxy
public class ProjectConfig {

	@Bean
	public LoggingAspect aspect() {
		return new LoggingAspect();
	}
}
```

Напомню: данный объект необходимо сделать бином и добавить в контекст Spring, чтобы передать под контроль фреймворка.

Учтите, что **аннотация `@Aspect` не является стереотипной**. **С помощью `@Aspect` мы сообщаем Spring, что в данном классе содержится определение аспекта, но это не значит, что Spring сразу создаст для него бин**. Для выполнения последнего действия необходимо ясно прописать одну из синтаксических конструкций. Не добавить класс с аннотацией `@Aspect` в контекст — типичная ошибка.
### Шаг 3. С помощью аннотации совета сообщить Spring, какой метод и в какой момент нужно перехватывать
Теперь, когда определён класс аспекта, можно выбрать совет и снабдить метод соответствующей аннотацией. Ниже показан метод с аннотацией `@Around`.
```java
@Aspect
public class LoggingAspect {

	@Around("execution(* services.*.*(..))") // Определение перехватываемых методов
	public void log(ProceedingJoinPoint joinPoint) {
		joinPoint.proceed(); // Делегирование управления перехваченному методу
	}
}
```

Кроме аннотации `@Around`, вы также заметите здесь необычное строковое выражение в качестве значения аннотации и параметр, добавленный в метод аспекта. Что это такое?

Рассмотрим данные детали по очереди. Странный оборот, использованный в качестве параметра аннотации `@Around`, сообщает Spring, какой метод нужно перехватить. Этот язык выражений называется **языком срезов AspectJ**, но ничего не придётся заучивать наизусть, чтобы им пользоваться. На практике сложные выражения вам не встретятся. Когда нужно написать что-то подобное, обычно обращаются к [документации](http://mng.bz/4K9g).

Теоретически на AspectJ можно составлять очень сложные выражения срезов, чтобы описывать определённые наборы вызовов методов, которые нужно перехватывать. Это действительно очень мощный язык. Но, как вы увидите далее, всегда лучше по возможности избегать сложных конструкций. В большинстве случаев можно найти варианты попроще.

Взгляните на использованное выражение. Оно означает, что Spring будет перехватывать любой метод, принадлежащий классу из пакета `services`, независимо от того, какой тип данных возвращает этот метод, к какому именно классу принадлежит, какое ему присвоено имя и какие параметры он принимает.
![spring_6.5](/pictures/spring_6.5.png)

При ближайшем рассмотрении данная конструкция не выглядит такой уж сложной, правда? Выражения срезов на AspectJ часто пугают новичков, но вам не нужно становиться экспертом по AspectJ, чтобы использовать их в приложениях Spring.

Теперь обратим внимание на второй элемент — параметр `ProceedingJoinPoint`. Этот параметр обозначает перехватываемый метод. Главное, что он делает, — сообщает аспекту, в какой момент следует делегировать управление исходному методу.
### Шаг 4. Реализация логики аспекта
Ниже добавлена логика аспекта. Теперь аспект делает следующее.
1. Перехватывает метод.
2. Перед вызовом перехваченного метода выводит что-нибудь в консоль.
3. Вызывает перехваченный метод.
4. После вызова перехваченного метода выводит что-нибудь в консоль.
```java
@Aspect
public class LoggingAspect { 

	private Logger logger = Logger.getLogger(LoggingAspect.class.getName());
	
	@Around("execution(* services.*.*(..))") 
	public void log(ProceedingJoinPoint joinPoint) throws Throwable { 
		logger.info("Method will execute"); 
		joinPoint.proceed(); 
		logger.info("Method executed"); 
	}
}
```

Поведение аспекта визуально представлено ниже.
![spring_6.6](/pictures/spring_6.6.png)

Метод `proceed()` параметра `ProceedingJoinPoint` вызывает перехваченный метод `publishComment()`, принадлежащий бину `CommentService`. Если не использовать `proceed()`, аспект никогда не будет делегировать управление перехваченному методу.
![spring_6.7](/pictures/spring_6.7.png)

Мы даже можем реализовать логику, при которой перехваченный метод вообще не будет вызываться. Например, можно создать аспект, который будет проверять некие условия авторизации и затем решать, передавать ли управление дальше защищённому методу. Если условия авторизации не выполнены, аспект не будет делегировать контроль перехваченному методу, таким образом защищая его.

Обратите также внимание, что метод `proceed()` выбрасывает исключение `Throwable`. `proceed()` рассчитан на то, чтобы выдавать любое исключение, поступающее от перехваченного метода. В данном примере выбран простейший способ передать его дальше, но при необходимости можно обработать его с помощью блока `try-catch-finally`.

Вернёмся к нашему приложению. Мы обнаружим в консоли записи, выведенные и аспектом, и перехваченным методом. Сообщения должны выглядеть примерно так:
```
Sep 27, 2020 1:11:11 PM aspects.LoggingAspect log
INFO: Method will execute
Sep 27, 2020 1:11:11 PM services.CommentService publishComment
INFO: Publishing comment:Demo comment
Sep 27, 2020 1:11:11 PM aspects.LoggingAspect log
INFO: Method executed
```
## Изменение параметров и возвращаемого значения перехваченного метода
Аспекты невероятно эффективны. Они не только перехватывают метод и изменяют его выполнение, но также могут перехватывать параметры, использованные при вызове метода, и при необходимости модифицировать их или значение, возвращаемое методом. Далее мы перепишем пример, с которым до сих пор работали, чтобы показать, каким образом аспект может влиять на параметры перехваченного метода и возвращаемое им значение.

Предположим, что нам нужно записывать в журнал параметры, используемые при вызове метода сервиса, а также то, что этот метод возвращает. Чтобы продемонстрировать реализацию подобного сценария. Поскольку нам также понадобится ссылка на то, что возвращает метод, добавим в сервисный метод возвращаемое значение:
```java
@Service
public class CommentService {

	private Logger logger = Logger.getLogger(CommentService.class.getName());
	
	public String publishComment(Comment comment) {
		logger.info("Publishing comment:" + comment.getText());
		return "SUCCESS";
	}
}
```

Аспект легко получает имя перехватываемого метода и его параметры. Напомню, что любую информацию о перехватываемом методе (параметры, имя, целевой объект и т. п.) можно получить с помощью параметра `ProceedingJoinPoint`, которым данный метод представлен в методе аспекта. В следующем фрагменте кода показано, как получить имя метода и параметры, использованные при его вызове, прежде чем перехватить вызов:
```java
String methodName = joinPoint.getSignature().getName();
Object[] arguments = joinPoint.getArgs();
```

Теперь можно изменить аспект так, чтобы выводить данную информацию в консоль.
```java
@Aspect
public class LoggingAspect { 

	private Logger logger = Logger.getLogger(LoggingAspect.class.getName()); 
	
	@Around("execution(* services.*.*(..))") 
	public Object log(ProceedingJoinPoint joinPoint) throws Throwable { 
		String methodName = joinPoint.getSignature().getName(); 
		Object [] arguments = joinPoint.getArgs(); 

		logger.info("Method " + methodName + 
			" with parameters " + Arrays.asList(arguments) + 
			" will execute"); 

		Object returnedByMethod = joinPoint.proceed(); 

		logger.info("Method executed and returned " + returnedByMethod); 

		return returnedByMethod; 
	}
}
```

Благодаря рисунку ниже вам будет проще представить себе весь процесс. Обратите внимание, что аспект перехватывает вызов и получает доступ к параметрам метода и возвращаемому им значению.
![spring_6.8](/pictures/spring_6.8.png)

Изменим метод `main()` таким образом, чтобы выводилось значение, возвращаемое `publishComment()`.
```java
public class Main {

	private static Logger logger = Logger.getLogger(Main.class.getName());
	
	public static void main(String[] args) {
		var c = new AnnotationConfigApplicationContext(ProjectConfig.class);
		var service = c.getBean(CommentService.class);

		Comment comment = new Comment();
		comment.setText("Demo comment");
		comment.setAuthor("Natasha");

		String value = service.publishComment(comment);

		logger.info(value); // Вывести значение, возвращаемое методом publishComment()
	}
}
```

При выполнении приложения вы увидите в консоли значения, полученные методом `main()` от аспекта и перехваченного метода:
```
Sep 28, 2020 10:49:39 AM aspects.LoggingAspect log
INFO: Method publishComment with parameters [Comment{text='Demo comment', author='Natasha'}] will execute
Sep 28, 2020 10:49:39 AM services.CommentService publishComment
INFO: Publishing comment:Demo comment
Sep 28, 2020 10:49:39 AM aspects.LoggingAspect log
INFO: Method executed and returned SUCCESS
Sep 28, 2020 10:49:39 AM main.Main main
INFO: SUCCESS
```

Но и на этом возможности аспектов не заканчиваются. Аспекты позволяют влиять на выполнение перехватываемого метода следующими способами:
- модифицируя значения параметров, передаваемых методу;
- изменяя значение, возвращаемое перехваченным методом и передаваемое вызывающему методу;
- выбрасывая исключение и передавая его вызывающему методу либо перехватывая и обрабатывая исключение, которое выдает перехваченный метод.

Есть очень много вариантов воздействия на перехватываемый метод. Вы можете даже полностью изменить его поведение. Но будьте осторожны! Меняя логику посредством аспекта, вы делаете часть этой логики прозрачной. Убедитесь, что не скрываете неочевидные моменты. Вообще, цель отделения части логики состоит в том, чтобы избежать дублирования кода и скрыть то, что не имеет отношения к делу, чтобы разработчику было легче сконцентрироваться на бизнес-логике. Собираясь создать аспект, поставьте себя на место того, кому понадобится разобраться в коде и быстро понять, что происходит с приложением.
![spring_6.9](/pictures/spring_6.9.png)

Ниже демонстрируется, каким образом аспекты могут влиять на вызов перехватываемого метода, изменяя его параметры или возвращаемое значение. Если вызвать метод `proceed()`, не передав ему никаких параметров, то аспект даст перехватываемому методу свои параметры. Но если передать методу `proceed()` параметр, представляющий собой массив объектов, то аспект даст перехватываемому методу этот массив вместо своих параметров. Аспект выводит в консоль значение, возвращаемое перехваченным методом, но вызывающий метод получает другое значение.
```java
@Aspect
public class LoggingAspect { 

	private Logger logger = Logger.getLogger(LoggingAspect.class.getName()); 
	
	@Around("execution(* services.*.*(..))") 
	public Object log(ProceedingJoinPoint joinPoint) throws Throwable { 
		String methodName = joinPoint.getSignature().getName(); 
		Object [] arguments = joinPoint.getArgs(); 

		logger.info("Method " + methodName + 
			" with parameters " + Arrays.asList(arguments) + 
			" will execute"); 

		Comment comment = new Comment(); 
		comment.setText("Some other text!"); 
		Object [] newArguments = {comment};

		Object returnedByMethod = joinPoint.proceed(newArguments); 

		logger.info("Method executed and returned " + returnedByMethod); 

		return "FAILED"; 
	}
}
```

При запуске приложения получим результат, показанный ниже. Значения параметров, полученных методом `publishComment()`, отличаются от тех, которые были ему переданы вызывающим методом. Метод `publishComment()` возвращает одно значение, а `main()` получает другое:
```
Sep 29, 2020 10:43:51 AM aspects.LoggingAspect log
INFO: Method publishComment with parameters [Comment{text='Demo comment', author='Natasha'}] will execute
Sep 29, 2020 10:43:51 AM services.CommentService publishComment
INFO: Publishing comment:Some other text!
Sep 29, 2020 10:43:51 AM aspects.LoggingAspect log
INFO: Method executed and returned SUCCESS
Sep 29, 2020 10:43:51 AM main.Main main
INFO: FAILED
```
## Перехват методов с аннотациями
Далее мы рассмотрим важную методику, часто применяемую в Spring-приложениях, чтобы отметить методы, которые должны перехватываться аспектами, — использование аннотаций. Они так удобны, что с момента своего появления в Java 5 практически стали стандартом для конфигурации приложений, использующих те или иные фреймворки. Пожалуй, сейчас не найдётся Java-фреймворка, в котором бы не было аннотаций. С их помощью также можно отмечать методы, которые должны перехватываться аспектами. Этот удобный синтаксис позволяет избежать написания сложных выражений среза AspectJ.

Для изучения данной методики мы создадим новый пример, подобный описанному ранее. Мы добавим в класс `CommentService` три метода: `publishComment()`, `deleteComment()` и `editComment()`. Мы хотим создать свою аннотацию и записывать в журнал данные о выполнении только тех методов, которые ею отмечены. Для этого нужно сделать следующее.

1. Определить аннотацию и сделать её доступной при выполнении приложения. Мы назовем ее `@ToLog`.
2. С помощью ещё одного выражения среза AspectJ сообщить методу аспекта, что нужно перехватывать методы с новой аннотацией.

Данные действия визуально представлены ниже.
![spring_6.10](/pictures/spring_6.10.png)

Логику аспекта менять не нужно. В этом примере аспект делает то же самое, что и в предыдущих: записывает в журнал данные о выполнении перехватываемых методов.

В следующем фрагменте кода содержится объявление новой аннотации. Здесь очень важно определить политику хранения с помощью аннотации `@Retention(RetentionPolicy.RUNTIME)`. По умолчанию в Java аннотации не могут перехватываться во время выполнения приложения. Нужно конкретно заявить, что нечто может перехватывать аннотации, определив политику хранения как `RUNTIME`. `@Target` определяет, для каких элементов языка может использоваться конкретная аннотация. По умолчанию ею можно сопровождать любые элементы, но всегда лучше ограничить область применения только тем, для чего она создаётся, — в данном случае методами:
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ToLog {
}
```

Ниже представлен класс `CommentService`, в котором теперь определены три метода. Мы снабдим аннотацией только метод `deleteComment()`, и в результате, по идее, аспект будет перехватывать лишь данный метод.
```java
@Service
public class CommentService { 
	private Logger logger = Logger.getLogger(CommentService.class.getName()); 
	
	public void publishComment(Comment comment) { 
		logger.info("Publishing comment:" + comment.getText()); 
	} 
	
	@ToLog 
	public void deleteComment(Comment comment) { 
		logger.info("Deleting comment:" + comment.getText()); 
	} 
	
	public void editComment(Comment comment) { 
		logger.info("Editing comment:" + comment.getText()); 
	}
}
```

Чтобы вплести аспект в методы, отмеченные новой аннотацией, мы воспользовались следующим выражением среза AspectJ: `@annotation(ToLog)`. Это выражение указывает на любой метод с аннотацией `@ToLog` (которую мы создали). Ниже представлен класс аспекта, в котором использовано новое выражение среза, чтобы вплести логику аспекта в перехватываемые методы.
```java
@Aspect
public class LoggingAspect {

	private Logger logger = Logger.getLogger(LoggingAspect.class.getName());
	
	@Around("@annotation(ToLog)") // Вплетение аспекта в методы с аннотацией @ToLog
	public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
		// код метода
	}
}
```
![spring_6.11](/pictures/spring_6.11.png)

После запуска приложения будет перехватываться только метод с созданной нами аннотацией (в данном случае `deleteComment()`), и аспект будет выводить в консоль записи о выполнении этого метода. Там должно появиться примерно следующее:
```
Sep 29, 2020 2:22:42 PM services.CommentService publish Comment
INFO: Publishing comment:Demo comment
Sep 29, 2020 2:22:42 PM aspects.LoggingAspect log
INFO: Method deleteComment with parameters [Comment{text='Demo comment', author='Natasha'}] will execute
Sep 29, 2020 2:22:42 PM services.CommentService deleteComment
INFO: Deleting comment:Demo comment
Sep 29, 2020 2:22:42 PM aspects.LoggingAspect log
INFO: Method executed and returned null
Sep 29, 2020 2:22:42 PM services.CommentService editComment
INFO: Editing comment:Demo comment
```
## Другие полезные аннотации советов
Есть и другие аннотации советов, которые можно использовать с аспектами Spring. До сих пор упоминалась только аннотация совета `@Around`. Она действительно встречается в приложениях Spring чаще других, поскольку покрывает практически все варианты реализации: с её помощью можно что-то сделать до, после и даже вместо перехваченного метода. В аспекте можно изменить логику перехваченного метода любым способом.

Но на практике часто нужны далеко не все эти возможности сразу. Иногда имеет смысл поискать более быстрый способ реализовать желаемое. Любое приложение следует стремиться сделать как можно более простым. Избегая излишней сложности, вы получите продукт, более удобный в поддержке. Для простых сценариев в Spring предусмотрены ещё четыре аннотации советов, не такие мощные, как `@Around`. Их рекомендуется использовать, когда возможностей этих аннотаций достаточно, чтобы упростить приложение.

Кроме `@Around`, в Spring есть следующие аннотации советов:
- **`@Before`** — вызывает метод, определяющий логику аспекта, перед выполнением перехватываемого метода;
- **`@AfterReturning`** — вызывает метод, определяющий логику аспекта, после успешного завершения перехватываемого метода. При этом значение, возвращаемое перехваченным методом, передаётся методу аспекта в качестве параметра. Если перехваченный метод выдаст исключение, метод аспекта не вызывается;
- **`@AfterThrowing`** — вызывает метод, определяющий логику аспекта, если перехваченный метод выдаёт исключение. Экземпляр исключения передаётся методу аспекта в качестве параметра;
- **`@After`** — вызывает метод, определяющий логику аспекта, после выполнения перехватываемого метода, независимо от того, завершится ли перехваченный метод успешно или выдаст исключение.

Данные аннотации советов используются так же, как и `@Around`. Они сопровождаются выражением среза AspectJ, позволяющим вплести логику аспекта в выполнение соответствующих методов. **При этом методы аспектов не получают параметр `ProceedingJoinPoint`, и поэтому с ними нельзя выбирать, в какой момент делегировать управление перехваченному методу.** Теперь это событие происходит в соответствии с выбранной аннотацией (например, в случае `@Before` перехватываемый метод всегда выполняется после логики аспекта).

Образец применения аннотации `@AfterReturning` также показан в следующем фрагменте кода. Обратите внимание, что эта аннотация используется точно так же, как `@Around`.
```java
@Aspect
public class LoggingAspect { 
	private Logger logger = Logger.getLogger(LoggingAspect.class.getName()); 
	
	@AfterReturning(value = "@annotation(ToLog)", returning = "returnedValue") 
	public void log(Object returnedValue) { 
		logger.info("Method executed and returned " + returnedValue); 
	}
}
```
# Цепочки выполнения аспектов
До сих пор во всех рассмотренных примерах мы обращали внимание на то, что происходит, когда один аспект перехватывает выполнение метода. В реальных приложениях таких аспектов может быть несколько. Предположим, у нас есть метод, данные о выполнении которого нужно заносить в журнал и одновременно применять некие ограничения по безопасности. Для реализации этих действий обычно используются аспекты. Поэтому в данном случае у нас будут два аспекта, которые активируются при выполнении одного и того же метода. Мы можем создать сколько угодно аспектов, это совершенно нормально. Но тогда необходимо сформулировать для себя ответы на следующие вопросы.
- В какой последовательности Spring будет выполнять эти аспекты?
- Имеет ли значение порядок выполнения?

В примере ниже мы ответим на эти вопросы.

Итак, у нас есть метод, к которому необходимо применить некие ограничения по безопасности, а также заносить данные о выполнении этого метода в журнал. Для реализации этих обязанностей у нас есть следующие аспекты:
- `SecurityAspect` — применяет ограничения по безопасности. Данный аспект перехватывает метод, валидирует его вызов и, если не выполняются некие условия, не передает вызов дальше перехваченному методу (подробности работы `SecurityAspect` в данном случае не имеют значения; просто запомним, что он иногда не вызывает перехваченный метод);
- `LoggingAspect` — заносит в журнал сообщения о начале и завершении работы перехваченного метода.

Когда в один и тот же метод вплетаются несколько аспектов, они выполняются по очереди. Один из способов состоит в том, чтобы сначала подключался `SecurityAspect`, затем он передавал бы управление аспекту `LoggingAspect`, а тот, в свою очередь, делегировал контроль перехваченному методу. Второй вариант — сначала выполнить `LoggingAspect`, а затем делегировать управление `SecurityAspect`, который в итоге передаст контроль перехваченному методу. Так образуется **цепочка выполнения аспектов**.

Последовательность работы аспектов имеет значение, поскольку при их выполнении в другом порядке мы получим другие результаты. Так, в нашем примере `SecurityAspect` не всегда передаёт управление дальше; поэтому если вначале будет выполняться этот аспект, то до `LoggingAspect` дело будет доходить не всегда. Если мы ожидаем, что `LoggingAspect` будет регистрировать попытки выполнения метода, которые оказались неудачными из-за ограничений по безопасности, то такой вариант нам не подходит.
![spring_6.12](/pictures/spring_6.12.png)

Ну хорошо, последовательность выполнения аспектов важна. Как тогда определить эту последовательность? По умолчанию **Spring не гарантирует, что каждый раз при запуске приложения цепочка аспектов будет выполняться в одном и том же порядке**. Если последовательность неважна, достаточно создать аспекты и позволить фреймворку задействовать их по своему усмотрению. **Если же порядок выполнения аспектов имеет значение, то можно воспользоваться аннотацией `@Order`**. Эта аннотация получает порядковый номер (число), соответствующий очерёдности выполнения данного аспекта в цепочке. Чем меньше это число, тем раньше заработает аспект. В случае двух одинаковых чисел очередность выполнения снова не будет определена. Рассмотрим применение аннотации `@Order` на примере.

Ниже представлен аспект `LoggingAspect`. Пока что порядок выполнения аспектов не определён.
```java
@Aspect
public class LoggingAspect { 

	private Logger logger = Logger.getLogger(LoggingAspect.class.getName()); 
	
	@Around(value = "@annotation(ToLog)") 
	public Object log(ProceedingJoinPoint joinPoint) throws Throwable { 
		logger.info("Logging Aspect: Calling the intercepted method"); 

		Object returnedValue = joinPoint.proceed(); 

		logger.info("Logging Aspect: Method executed and returned " + returnedValue); 

		return returnedValue; 
	}
}
```

Второй аспект в нашем примере называется `SecurityAspect`. Из соображений простоты, чтобы вы могли сконцентрироваться на главной теме нашего обсуждения, этот аспект не делает ничего особенного. Он, как и `LoggingAspect`, выводит сообщение в консоль — так мы можем легко убедиться, что метод выполняется.
```java
@Aspect
public class SecurityAspect { 

	private Logger logger = Logger.getLogger(SecurityAspect.class.getName()); 
	
	@Around(value = "@annotation(ToLog)") 
	public Object secure(ProceedingJoinPoint joinPoint) throws Throwable { 
	logger.info("Security Aspect: Calling the intercepted method"); 
	
	Object returnedValue = joinPoint.proceed(); 
	
	logger.info("Security Aspect: Method executed and returned " + returnedValue);
	 
	return returnedValue; 
	}
}
```

Класс `CommentService` не отличается от используемого в предыдущих примерах.

Как мы помним, оба аспекта должны быть бинами, размещенными в контексте Spring. В данном примере добавим аспекты в контекст с помощью аннотации `@Bean`.
```java
@Configuration
@ComponentScan(basePackages = "services")
@EnableAspectJAutoProxy
public class ProjectConfig { 

	@Bean 
	public LoggingAspect loggingAspect() { 
		return new LoggingAspect(); 
	} 
	
	@Bean 
	public SecurityAspect securityAspect() { 
		return new SecurityAspect(); 
	}
}
```

Метод `main()` вызывает метод `publishComment()` для бина `CommentService`.
```
Sep 29, 2020 6:04:22 PM aspects.LoggingAspect log
INFO: Logging Aspect: Calling the intercepted method
Sep 29, 2020 6:04:22 PM aspects.SecurityAspect secure
INFO: Security Aspect: Calling the intercepted method
Sep 29, 2020 6:04:22 PM services.CommentService publishComment
INFO: Publishing comment:Demo comment
Sep 29, 2020 6:04:22 PM aspects.SecurityAspect secure
INFO: Security Aspect: Method executed and returned SUCCESS
Sep 29, 2020 6:04:22 PM aspects.LoggingAspect log
INFO: Logging Aspect: Method executed and returned SUCCESS
```

Чтобы вам было проще понять последовательность появления записей в консоли, цепочка выполнения аспектов наглядно представлена ниже.
![spring_6.13](/pictures/spring_6.13.png)

Чтобы аспекты `LoggingAspect` и `SecurityAspect` выполнялись в обратном порядке, воспользуемся аннотацией `@Order`.
```java
@Aspect
@Order(1) // Определяет порядковый номер аспекта в цепочке выполнения
public class SecurityAspect {
	// код аспекта
}
```

Для `LoggingAspect` также использовался `@Order`, чтобы присвоить этому аспекту более поздний номер в цепочке выполнения:
```java
@Aspect
@Order(2) // LoggingAspect будет выполняться вторым
public class LoggingAspect {
	// код аспекта
}
```

Запустив приложение ещё раз, увидим, что последовательность выполнения аспектов изменилась. Теперь записи в консоли должны выглядеть так:
```
Sep 29, 2020 6:38:20 PM aspects.SecurityAspect secure
INFO: Security Aspect: Calling the intercepted method
Sep 29, 2020 6:38:20 PM aspects.LoggingAspect log
INFO: Logging Aspect: Calling the intercepted method
Sep 29, 2020 6:38:20 PM services.CommentService publishComment
INFO: Publishing comment:Demo comment
Sep 29, 2020 6:38:20 PM aspects.LoggingAspect log
INFO: Logging Aspect: Method executed and returned SUCCESS
Sep 29, 2020 6:38:20 PM aspects.SecurityAspect secure
INFO: Security Aspect: Method executed and returned SUCCESS
```

Чтобы лучше понять, почему записи в консоли появляются именно в такой последовательности, цепочка выполнения наглядно представлена ниже.
![spring_6.14](/pictures/spring_6.14.png)
Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 14.
# Что такое Spring Data
**Spring Data** — это проект экосистемы Spring, который упрощает разработку уровня хранения данных, предоставляя реализацию необходимых объектов в соответствии с выбранной технологией хранения данных. Благодаря этому нам, чтобы определить репозитории Spring-приложения, остаётся написать лишь несколько строк кода. Ниже предлагается визуальное представление места, которое занимает Spring Data в структуре приложения.
![spring_15.1](/pictures/spring_15.1.png)

Посмотрим, какое место занимает Spring Data в Spring-приложении. Существуют различные технологии для взаимодействия приложения с сохраненными данными. Ранее мы использовали технологию JDBC, которая обеспечивает непосредственное соединение с реляционной СУБД через менеджер драйверов. Но JDBC не единственный способ подключиться к реляционной базе данных. Другой распространённый способ организации хранения информации — использование **ORM-фреймворка**, такого как Hibernate. Кроме того, реляционные базы данных не единственный тип технологии хранения сведений. Для реализации этого функционала в приложении может применяться также одна из технологий NoSQL.

Ниже показаны некоторые возможности хранения данных в Spring. У каждой из них есть свой способ реализации репозиториев. У некоторых технологий (таких как JDBC) есть даже несколько вариантов работы с уровнем хранения данных в приложении. Например, в случае JDBC можно использовать `JdbcTemplate`, но можно и взаимодействовать непосредственно с интерфейсами JDK (`Statement`, `PreparedStatement`, `ResultSet` и др.). Такое разнообразие лишь добавляет сложностей.
![spring_15.2](/pictures/spring_15.2.png)

Картина ещё больше усложняется, если добавить в неё ORM-фреймворки, например Hibernate. Ниже показано, какое место занимает Hibernate в этой схеме. Есть разные способы непосредственного использования JDBC в приложении, но вместо этого можно взять фреймворк, который является надстройкой над JDBC.
![spring_15.3](/pictures/spring_15.3.png)

Spring Data упрощает реализацию уровня хранения данных следующими способами:
- **предоставляет общий набор абстракций (интерфейсов) для различных технологий хранения данных.** Это обеспечивает один и тот же подход при использовании этих технологий;
- **позволяет пользователю создавать операции с сохранёнными данными, используя только абстракции, реализации которых предоставляет Spring Data.** Таким образом приходится писать меньше кода и можно быстрее настроить функции приложения. Кроме того, благодаря меньшему количеству строк приложение становится более понятным и его проще поддерживать.

Ниже показано наглядно, какое место занимает Spring Data в Spring-приложении. Как видим, **Spring Data** — это высокоуровневая надстройка над различными способами реализации хранения данных. Таким образом, **какой бы вариант хранения данных вы ни выбрали, при использовании Spring Data операции с сохранёнными данными будут выглядеть одинаково**.
![spring_15.4](/pictures/spring_15.4.png)
# Как работает Spring Data
Говоря о Spring Data, разработчики обычно имеют в виду все возможности, предоставляемые этим проектом для работы Spring-приложения с той или иной технологией хранения данных. Но в конкретном приложении обычно используется только одна технология: JDBC, Hibernate, MongoDB или какая-то другая.

В Spring Data есть разные модули, предназначенные для соответствующих технологий. Эти модули не зависят друг от друга, и их можно подключать к проекту, используя различные зависимости Maven. Таким образом **при разработке приложения вам не нужна зависимость Spring Data**. Её просто не существует. **Spring Data предоставляет отдельные зависимости Maven для каждой поддерживаемой им технологии хранения данных**. Например, для соединения с СУБД непосредственно через JDBC используется модуль Spring Data JDBC, а для подключения к базе данных MongoDB — Spring Data Mongo. Ниже показано, как Spring Data взаимодействует с JDBC.
![spring_15.5](/pictures/spring_15.5.png)

Полный список модулей Spring Data находится на официальной странице [Spring Data](https://spring.io/projects/spring-data).

Какая бы технология хранения данных ни использовалась в приложении, **Spring Data предоставляет один и тот же набор интерфейсов (контрактов), которые нужно расширить, чтобы описать соответствующие функции**. Ниже представлены следующие интерфейсы:
- **`Repository`** — наиболее абстрактный контракт. Если его расширить, приложение распознаёт интерфейс, написанный как любой репозиторий Spring Data. Однако этот интерфейс не сможет унаследовать какие-либо предопределённые операции (такие как создание записи, чтение всех записей или чтение записи по первичному ключу). В интерфейсе `Repository` не объявлен ни один метод;
- **`CrudRepository`** — простейший контракт Spring Data, который, кроме всего прочего, предоставляет некоторые функции по взаимодействию с сохранёнными данными. Если его расширить, чтобы эти функции определить, то станут доступны простейшие операции создания, чтения, изменения и удаления записей;
- **`PagingAndSortingRepository`** — расширяет `CrudRepository`, добавляя операции сортировки и чтения определённого количества записей (постранично).
![spring_15.6](/pictures/spring_15.6.png)

Возможно, вам интересно: почему Spring Data предоставляет несколько интерфейсов, расширяющих один другой? Почему бы не сделать один интерфейс, включив в него все эти операции? Благодаря подобному подходу (который ещё называют **принципом изоляции интерфейсов**), когда **вместо одного «большого» контракта в Spring Data реализовано несколько контрактов, расширяющих друг друга, можно описать в приложении только необходимые операции**. Например, если в приложении нужны только операции CRUD, достаточно расширить контракт `CrudRepository`. Операции сортировки и постраничного чтения записей не будут доступны, благодаря чему приложение получится более простым.
![spring_15.7](/pictures/spring_15.7.png)

Если в приложении, помимо операций CRUD, также нужны функции сортировки и постраничного чтения данных, следует расширить более специализированный интерфейс `PagingAndSortingRepository`.

В некоторых модулях Spring Data могут быть и другие контракты, в зависимости от технологии, которую они представляют. Например, с помощью Spring Data JPA можно непосредственно расширить интерфейс `JpaRepository`. **`JpaRepository`** — еще более специализированный контракт, чем `PagingAndSortingRepository`. Он добавляет операции, применимые только при использовании определённых технологий, реализующих спецификацию Jakarta Persistence API (JPA), таких как Hibernate.
![spring_15.8](/pictures/spring_15.8.png)

Другой пример — реализация технологии NoSQL, такой как MongoDB. Чтобы использовать Spring Data для MongoDB, нужно подключить к приложению модуль Spring Data Mongo. Этот модуль предоставляет, в частности, специализированный контракт `MongoRepository`, который добавляет в приложение операции, свойственные данной технологии хранения информации.

Если в приложении используется определённая технология, то в нём обычно расширяются те контракты Spring Data, в которых объявлены операции, свойственные именно этой технологии. Если в приложении не требуется ничего сверх операций CRUD, можно по-прежнему ограничиться расширением `CrudRepository`, но специализированные контракты, как правило, предоставляют более удобные решения, созданные для конкретной технологии. Ниже показан класс `AccountRepository` (класс приложения), который расширяет `JpaRepository` (специальный модуль Spring Data JPA).
![spring_15.9](/pictures/spring_15.9.png)
# Использование Spring Data JDBC
Для реализации уровня хранения данных в Spring-приложении мы воспользуемся модулем Spring Data JDBC. Как уже было сказано, нужно только расширить контракт Spring Data.

Мы рассмотрим задачу — создадим приложение, представляющее собой электронный кошелёк для управления счетами пользователей. Пользователь может перевести деньги с одного счета на другой. В этом примере мы разработаем сценарий использования «перевод денег», который позволит отправлять средства с одного счёта на другой. Операция перевода состоит из двух частей.
1. Снять заданную сумму со счёта отправителя.
2. Положить эту сумму на счёт получателя.
![spring_15.10](/pictures/spring_15.10.png)

Мы будем держать информацию о счетах в таблице базы данных. Чтобы пример был как можно более простым и коротким и вы могли сосредоточиться на теме этого раздела, мы будем использовать базу данных H2, хранящуюся в оперативной памяти.

Таблица счетов будет состоять из следующих полей:
- `id` — первичный ключ, автоматически увеличивающееся поле типа `INT`;
- `name` — имя владельца счёта;
- `amount` — сумма денег, которую владелец хранит на счету.

К проекту (в файле *pom.xml*) необходимо подключить следующие зависимости:
```xml
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
<dependency> 
	<groupId>com.h2database</groupId> 
	<artifactId>h2</artifactId> 
	<scope>runtime</scope>
</dependency>
```

Мы также добавим в папку ресурсов проекта Maven файл *schema.sql*, чтобы создать таблицу счетов в базе данных H2, хранящейся в оперативной памяти. В этом файле содержится следующий DDL-запрос, необходимый для создания таблицы счетов:
```sql
create table account (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(50) NOT NULL,
	amount DOUBLE NOT NULL
);
```

Нам также нужно добавить пару записей в таблицу счетов. Впоследствии, когда мы закончим разработку приложения, эти записи понадобятся для его тестирования. Создадим в папке ресурсов Maven файл *data.sql*. Чтобы добавить две записи в таблицу счетов, мы внесём в *data.sql* два оператора *INSERT*:
```sql
INSERT INTO account VALUES (NULL, 'Jane Down', 1000);
INSERT INTO account VALUES (NULL, 'John Read', 1000);
```

Построим модель записи из таблицы счетов в виде класса `Account`. Для представления каждого столбца таблицы в этом классе мы создадим поле соответствующего типа.

Для некоторых операций Spring Data, таких как чтение данных из базы, Spring Data должен знать, какое поле соответствует первичному ключу таблицы. Чтобы обозначить первичный ключ, мы будем применять аннотацию `@Id`.
```java
public class Account { 
	@Id 
	private long id; 
	
	private String name; 
	private BigDecimal amount; 
	
	// Геттеры и сеттеры
}
```

Теперь, построив класс модели, можно разработать репозиторий Spring Data. Для этого приложения нам нужны только операции CRUD, поэтому мы напишем интерфейс, который расширяет `CrudRepository`. Во всех интерфейсах Spring Data содержатся следующие два типа, которые необходимо реализовать:
- **класс модели** (которую иногда называют **сущностью**), для которого мы пишем репозиторий;
- **тип поля первичного ключа**.
```java
public interface AccountRepository extends CrudRepository<Account, Long> {
}
```

В результате расширения интерфейса `CrudRepository` нам станут доступны простейшие операции Spring Data, такие как получение значения по его первичному ключу, чтение всех записей из таблицы, удаление записей и т. п. Но это далеко не всё, что можно реализовать посредством SQL-запросов. В реальном приложении нам также понадобились бы дополнительные операции подобного плана. Как создать такую операцию для репозитория Spring Data?

В Spring Data это делается очень просто — иногда даже не приходится писать SQL-запрос. **Проект интерпретирует имена методов на основе ряда правил для создания таких имён и генерирует запросы.** Предположим, вы хотите написать операцию получения данных для всех счетов по заданному имени. В Spring Data для этого достаточно метода с именем `findAccountsByName`. Если имя метода начинается с `find`, Spring Data знает, что вы хотите прочитать что-то из базы с помощью запроса `SELECT`. Следующее слово, `Accounts`, сообщает, что именно вы хотите выбрать. Spring Data даже догадается, что вы имели в виду, назвав метод `findByName`. Он поймет ваше стремление, поскольку этот метод принадлежит репозиторию `AccountRepository`. После `By` в имени метода Spring Data ожидает получить условие запроса (`WHERE`). В данном случае мы хотим выбрать записи по имени, то есть `ByName`, что Spring Data переведет как `WHERE name = ?`.

Преобразование имени метода в запрос, автоматически выполняемое Spring Data, визуально представлено ниже.
![spring_15.11](/pictures/spring_15.11.png)

Ниже показано определение метода в интерфейсе `AccountRepository`.
```java
public interface AccountRepository extends CrudRepository<Account, Long> {

	List<Account> findAccountsByName(String name);
}
```

На первый взгляд магия перевода имени метода в запрос кажется невероятной. Но со временем вы поймёте, что это не панацея. У данного подхода есть ряд недостатков, поэтому лучше определять запрос явно, вместо того чтобы рассчитывать на Spring Data. Главные недостатки состоят в следующем:
- если операция требует более сложного запроса, имя метода получится слишком длинным и его будет трудно читать;
- если при рефакторинге имя метода по ошибке изменят, нарушится поведение приложения, а вы этого можете даже не заметить (к сожалению, не все приложения тщательно тестируются — учитывайте данный факт);
- если только вы не работаете в IDE, где среда сама подсказывает правильное имя метода, правила именования методов в Spring Data придётся выучить. Поскольку вы уже знакомы с SQL, то ничего не выиграете, изучив ещё и набор правил, применимый только для Spring Data;
- необходимость перевести имя метода в запрос снижает производительность, из-за чего замедляется инициализация приложения (так как процесс перевода происходит при запуске приложения).

Самый простой способ избежать этих проблем состоит в применении аннотации **`@Query`**. Она определяет SQL-запрос, который должно выполнить приложение при вызове метода. Если перед методом стоит `@Query`, то уже неважно, как вы его назовёте. Spring Data не станет переводить имя метода в запрос, а возьмёт тот запрос, который предоставите вы. Такое поведение также является более эффективным для производительности. Пример использования аннотации `@Query` показан ниже.
```java
public interface AccountRepository extends CrudRepository<Account, Long> { 

	@Query("SELECT * FROM account WHERE name = :name") 
	List<Account> findAccountsByName(String name);
}
```

Аннотация `@Query` используется одинаково для любых запросов. Но, если в запросе содержатся данные, необходимо также снабдить метод аннотацией **`@Modifying`**. **`@Modifying` нужен и при запросах `UPDATE`, `INSERT` или `DELETE`.** Ниже показано, как использовать аннотацию `@Query` для создания метода репозитория с запросом `UPDATE`.
```java
public interface AccountRepository extends CrudRepository<Account, Long> { 

	@Query("SELECT * FROM account WHERE name = :name") 
	List<Account> findAccountsByName(String name); 
	
	@Modifying 
	@Query("UPDATE account SET amount = :amount WHERE id = :id") 
	void changeAmount(long id, BigDecimal amount);
}
```

Чтобы получить бин, реализующий интерфейс `AccountRepository`, можно воспользоваться DI. Не стоит беспокоиться из-за того, что вы написали только интерфейс. Spring Data сам создаст динамическую реализацию и добавит бин в контекст приложения. Ниже показано, как компонент приложения `TransferService` получает бин `AccountRepository` посредством внедрения в конструктор. При запросе DI для поля интерфейсного типа Spring понимает, что нужно найти бин, который реализует этот интерфейс.

```java
@Service
public class TransferService {

	private final AccountRepository accountRepository;
	
	public TransferService(AccountRepository accountRepository) {
		this.accountRepository = accountRepository;
	}
}
```

Ниже показана реализация сценария использования «перевод денег». С помощью `AccountRepository` мы получаем данные о счёте и изменяем его баланс. Мы по-прежнему применяем аннотацию `@Transactional`, чтобы логика выполнялась в рамках транзакции и данные бы не нарушились в случае, если одна из операций завершится неудачно.
```java
@Service
public class TransferService { 

	private final AccountRepository accountRepository; 
	
	public TransferService(AccountRepository accountRepository) { 
		this.accountRepository = accountRepository; 
	} 
	
	@Transactional 
	public void transferMoney(long idSender, long idReceiver, BigDecimal amount) {
	 
		Account sender = accountRepository.findById(idSender) 
			.orElseThrow(() -> new AccountNotFoundException());
			 
		Account receiver = accountRepository.findById(idReceiver) 
			.orElseThrow(() -> new AccountNotFoundException()); 
			
		BigDecimal senderNewAmount = sender.getAmount().subtract(amount); 
		BigDecimal receiverNewAmount = receiver.getAmount().add(amount);
		 
		accountRepository.changeAmount(idSender, senderNewAmount); 
		accountRepository.changeAmount(idReceiver, receiverNewAmount); 
	}
}
```

В сценарии использования «перевод денег» мы применили простой класс исключения при выполнении, который называется `AccountNotFoundException`. Определение этого класса выглядит так:
```java
public class AccountNotFoundException extends RuntimeException {
}
```

Создадим метод сервиса, который будет читать записи из базы данных и получать все сведения о счетах для заданного владельца. Эти операции нам понадобятся при тестировании приложения. Чтобы получить все записи, нам не нужно писать метод вручную. Интерфейс `AccountRepository` наследует метод `findAll()` от контракта `CrudRepository`, как показано ниже.
```java
@Service
public class TransferService { 

	// Остальной код 
	
	public Iterable<Account> getAllAccounts() { 
		return accountRepository.findAll(); 
	} 
	
	public List<Account> findAccountsByName(String name) { 
		return accountRepository.findAccountsByName(name); 
	}
}
```

Ниже показано, как `AccountController` предоставляет доступ к сценарию использования «перевод денег» через конечную точку REST.
```java
@RestController
public class AccountController { 

	private final TransferService transferService; 
	
	public AccountController(TransferService transferService) { 
		this.transferService = transferService; 
	} 
	
	@PostMapping("/transfer") 
	public void transferMoney(@RequestBody TransferRequest request) {
		transferService.transferMoney(
			request.getSenderAccountId(),
			request.getReceiverAccountId(), 
			request.getAmount()); 
	}
}
```

В следующем фрагменте кода показана реализация DTO `TransferRequest`, который используется в конечной точке` /transfer` для преобразования тела HTTP-запроса:
```java
public class TransferRequest {

	private long senderAccountId;
	private long receiverAccountId;
	private BigDecimal amount;
	
	// Геттеры и сеттеры
}
```

Ниже создаётся конечная точка для чтения записей из базы данных.
```java
@RestController
public class AccountController { 

	// Остальной код 
	
	@GetMapping("/accounts") 
	public Iterable<Account> getAllAccounts(
		@RequestParam(required = false) String name) { 
		if (name == null) { 
			return transferService.getAllAccounts(); 
		} else { 
			return transferService.findAccountsByName(name); 
		} 
	}
}
```

Запустим приложение и проверим записи, вызвав конечную точку `/accounts`, которая возвращает все счета из базы данных:
```
curl http://localhost:8080/accounts
```

Выполнив эту команду, вы увидите в консоли примерно следующее:
```json
[
	{"id":1,"name":"Jane Down","amount":1000.0},
	{"id":2,"name":"John Read","amount":1000.0}
]
```

Чтобы перевести $100 Джону от Джейн, вызовем конечную точку `/transfer`, использовав команду cURL:
```
curl -XPOST -H "content-type:application/json" -d '{"senderAccountId":1, "receiverAccountId":2, "amount":100}' http://localhost:8080/transfer
```

Если снова вызовем конечную точку `/accounts`, увидим, что суммы на счетах изменились. После выполнения перевода у Джейн осталось всего $900, а у Джона теперь есть $1100.

Результат вызова конечной точки `/accounts` после перевода денег должен выглядеть так:
```json
[
	{"id":1,"name":"Jane Down","amount":900.0},
	{"id":2,"name":"John Read","amount":1100.0}
]
```

Если при вызове конечной точки `/accounts` использовать параметр запроса `name`, сформируется другой запрос, который позволит увидеть только счета Джейн:
```
curl http://localhost:8080/accounts?name=Jane+Down
```

Как показано в следующем фрагменте, в теле ответа, полученного в результате выполнения этой команды, присутствует информация, касающаяся только Джейн:
```json
[
	{
		"id": 1,
		"name": "Jane Down",
		"amount": 900.0
	}
]
```
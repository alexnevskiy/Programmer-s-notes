Взято с Habr ([1](https://habr.com/ru/articles/470305/)), ([2](https://habr.com/ru/articles/893614/)), ([3](https://habr.com/ru/articles/720794/)).
# Что такое контейнер и какой у него жизненный цикл
**Основа Spring Framework** — контейнер, и наши объекты "живут" в этом контейнере. Контейнер обычно создаёт множество объектов на основе их конфигураций и управляет их жизненным циклом от создания объекта до уничтожения.

**Контейнер** — это объект, реализующий интерфейс **`ApplicationContext`**.
## Основные понятия
- [`BeanDefinition`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html) - **описывает bean-компоненты**. Создаётся на основе разобранной мета-информации.
- [`BeanFactory`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html) - это интерфейс, который **создаёт и предоставляет bean-компоненты на основе `BeanDefinition`'ов**. Он является ядром `ApplicationContext`.
- [`ApplicationContext`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html) - это **центральный интерфейс, который предоставляет следующий список возможностей**:
	- возможности `BeanFactory`;
	- загрузка ресурсов;
	- публикация событий;
	- интернационализация;
	- автоматическая регистрация `BeanPostProcessor` и `BeanFactoryPostProcessor`.
- [`BeanFactoryPostProcessor`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html) - это интерфейс, который **позволяет настраивать определения bean-компонентов контекста приложения**. Он создаётся и запускается перед `BeanPostProcessor`. Если требуется взаимодействие с экземпляром компонента, то необходимо использовать `BeanPostProcessor`.
- [`BeanPostProcessor`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html) - это интерфейс для **обеспечения интеграции кастомной логики создания экземпляров, разрешения зависимостей и т. д.** Каждый компонент, созданный `BeanFactory`, проходит через каждый зарегистрированный `BeanPostProcessor`.
- [`ApplicationContextEvent`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/ApplicationContextEvent.html) - основной класс для событий, возникающих в процессе жизненного цикла `ApplicationContext`. Его подклассы:
	- `ContextRefreshedEvent` - публикуется автоматически после поднятия контекста;
	- `ContextStartedEvent` - публикуется методом `ApplicationContext#start`;
	- `ContextStoppedEvent` - публикуется методом `ApplicationContext#stop`;
	- `ContextClosedEvent` - публикуется автоматически перед закрытием контекста.
- [`ApplicationListener`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationListener.html) - интерфейс, который **позволяет обрабатывать [`ApplicationEvent`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationEvent.html) события**. Можно использовать аннотацию [`@EventListener`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/EventListener.html) вместо интерфейса.
- [`Lifecycle`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/Lifecycle.html) - **интерфейс похожий на `ApplicationListener`, но в нём определено 2 метода, которые срабатывают во время запуска (start) и остановки (stop) контекста**.
- [`SmartLifecycle`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html) - это **расширение `Lifecycle` интерфейса**. Отличие в том, что **он срабатывает во время обновления (refresh) и закрытия (close) контекста**.
- [`Ordered`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/Ordered.html) - интерфейс, позволяющий **управлять порядком работы компонентов**. Например, если компоненты реализуют `BeanPostProcessor`/`BeanFactoryPostProcessor` и `Ordered` интерфейсы, то мы можем контролировать порядок их выполнения.
- [`FactoryBean`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/FactoryBean.html) - интерфейс, позволяющий **внедрить сложную логику создания объекта**. Если у вас есть сложный код инициализации, который лучше выражается на Java, вы можете создать свой собственный `FactoryBean`, написать сложную инициализацию внутри этого класса, а затем подключить свой собственный `FactoryBean` к контейнеру.
- [`ApplicationStartup`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html) - это **инструмент, который помогает понять, на что тратится время на этапе запуска**.
## Жизненный цикл контекста
Жизненный цикл контекста состоит из 4 этапов:
1. **Этап обновления (refresh)** - автоматический;
2. **Этап запуска (start)** - вызывается методом `ApplicationContext#start`;
3. **Этап остановки (stop)** - вызывается методом `ApplicationContext#stop`;
4. **Этап закрытия (close)** - автоматический.
### Этап обновления контекста
1. `BeanFactory` создаёт `BeanFactoryPostProcessor`-ы используя конструктор без аргументов:
	- `BeanFactory` может создать экземпляр `BeanFactoryPostProcessor` только с конструктором без аргументов. В противном случае вы получите сообщение об ошибке со следующим сообщением: `No default constructor found.`
	- Обратные вызовы инициализации и уничтожения не работают как у обычных bean-компонентов, если вы используете конфигурацию на основе аннотаций. Но они работают если использовать конфигурации на основе XML.
	- Если вы пометили `BeanFactoryPostProcessor` как лениво инициализируемый, то `BeanFactory` проигнорирует это.
2. `ApplicationContext` вызывает метод `BeanFactoryPostProcessor#postProcessBeanFactory`.
3. `BeanFactory` создаёт `BeanPostProcessor`-ы:
	- `ApplicationContext` позволяет внедрять зависимости в конструктор `BeanPostProcessor`, но такой компонент не будет обрабатываться `BeanPostProcessor` и вы получите следующее сообщение: `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying`;
	- Обратные вызовы инициализации и уничтожения работают как обычные bean-компоненты.
4. `ApplicationContext` регистрирует `BeanPostProcessor`-ы.
5. Инициализация **singleton** bean-компонентов.
6. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#start`, если флаг имеет значение `false`:
	- Метод `SmartLifecycle#start` вызывается автоматически на этапе обновления (refresh), поскольку флаг `SmartLifecycle#isAutoStartup` по умолчанию имеет значение `true`;
	- Метод `Lifecycle#start`не вызывается на этапе обновления. Он вызывается на этапе запуска (start). Начальная фаза запускается только с помощью `ApplicationContext#start`.
7. `ApplicationContext` публикует `ContextRefreshedEvent`.
8. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextRefreshedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`:
	- Один метод может обрабатывать несколько событий.
### Этап запуска контекста
1. `ApplicationContext` проверяет флаг `Lifecycle#isRunning` и вызывает метод `Lifecycle#start`, если флаг имеет значение `false`.
2. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#start`, если флаг имеет значение `false`. Да-да, контекст второй раз проходится по объектам, реализующим интерфейс `SmartLifecycle`.
3. `ApplicationContext` публикует `ContextStartedEvent`.
4. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextStartedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`.
### Этап остановки контекста
1. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#stop`, если флаг имеет значение `true`.
2. `ApplicationContext` проверяет флаг `Lifecycle#isRunning` и вызывает метод `Lifecycle#stop`, если флаг имеет значение `true`.
3. `ApplicationContext` публикует `ContextStoppedEvent`.
4. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextStoppedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`.
### Этап закрытия контекста
1. `ApplicationContext` публикует `ContextClosedEvent`.
2. Методы обратного вызова, помеченные аннотацией `@EventListener` с типом параметра метода `ContextClosedEvent`, обрабатывают это событие. Также здесь может быть `ApplicationListener`.
3. `ApplicationContext` проверяет флаг `SmartLifecycle#isRunning` и вызывает метод `SmartLifecycle#stop`, если флаг имеет значение `true`:
	- Это выполнится раньше, если был запущен этап остановки контекста.
4. `ApplicationContext` проверяет флаг `Lifecycle#isRunning` и вызывает метод `Lifecycle#stop`, если флаг имеет значение `true`:
	- Это выполнится раньше, если был запущен этап остановки контекста.
5. Уничтожение bean-компонентов.
## Жизненный цикл контейнера
1. Контейнер создаётся при запуске приложения  
2. Контейнер считывает конфигурационные данные  
3. Из конфигурационных данных создаётся описание бинов  
4. `BeanFactoryPostProcessors` обрабатывают описание бина  
5. Контейнер создаёт бины используя их описание  
6. Бины инициализируются — значения свойств и зависимости внедряются в бин  
7. `BeanPostProcessor` запускают методы обратного вызова (callback methods)  
8. Приложение запущено и работает  
9. Инициализируется закрытие приложения  
10. Контейнер закрывается  
11. Вызываются callback methods
# Жизненный цикл бина
![spring_bean_lifecycle](/pictures/spring_bean_lifecycle.jpg)
## 1. Создание бина
Spring создаёт объект бина с помощью конструктора, но пока не внедряет в него зависимости.

**Шаги жизненного цикла**:
1. Загрузка описаний бинов, создание графа зависимостей (между бинами).
2. Создание и запуск `BeanFactoryPostProcessors`.
3. Создание бинов.
## 2. Внедрение свойств и зависимостей
Spring автоматически добавляет в бин все его зависимости.

**Шаги жизненного цикла**:
4. Spring внедряет значения и зависимости в свойства бина.
## 3. Пре-инициализация
### 3.1. Aware-интерфейсы
Если бин реализует `BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware`, то Spring передаёт ему информацию о контексте:
- `BeanNameAware` — получает **имя бина**.
- `BeanFactoryAware` — доступ к **`BeanFactory`**.
- `ApplicationContextAware` — доступ ко **всему контексту Spring**.

**Шаги жизненного цикла**:
5. Если бин реализует метод `setBeanName()` из интерфейса `NameBeanAware`, то ID бина передаётся в метод.
6. Если бин реализует `BeanFactoryAware`, то Spring устанавливает ссылку на bean factory через `setBeanFactory()` из этого интерфейса.
7. Если бин реализует интерфейс `ApplicationContextAware`, то Spring устанавливает ссылку на `ApplicationContext` через `setApplicationContext()`.
### 3.2. `BeanPostProcessor` до инициализации
Spring вызывает `postProcessBeforeInitialization` у всех `BeanPostProcessor`.

**Примеры использования:**
- **Валидация бинов** – проверка корректности данных перед их использованием.
- **Изменение свойств** – настройка конфигурации бина в зависимости от профиля приложения (`@Profile`).
- **Логирование** – запись информации о бине перед его инициализацией.

**Шаги жизненного цикла**:
8. `BeanPostProcessor` это специальный интерфейс, и Spring позволяет бинам имплементировать этот интерфейс. Реализуя метод `postProcessBeforeInitialization()`, можно изменить экземпляр бина перед его (бина) инициализацией (установка свойств и т.п.)
## 4. Инициализация
Spring выполняет методы:
- `@PostConstruct`;
- `InitializingBean#afterPropertiesSet()`;
- Метод, указанный в `@Bean(initMethod = "init")`.

**Шаги жизненного цикла**:
9. Если определены методы обратного вызова, то Spring вызывает их. Например, это метод, аннотированный `@PostConstruct` или метод `initMethod` из аннотации `@Bean`.
## 5. Пост-инициализация. `BeanPostProcessor` после инициализации
Spring вызывает `postProcessAfterInitialization` у `BeanPostProcessor`.

**Где применяется:**
- **Проксирование бинов** – создание AOP-прокси для аннотаций `@Transactional`, `@Async` и подобных.
- **Кэширование** – автоматическое добавление механизма кэширования для методов.
- **Изменение бинов** – динамическое добавление новых методов или обёртывание логикой безопасности.
## 6. Использование бина
**Шаги жизненного цикла**:
10. Теперь бин готов к использованию. Его можно получить с помощью метода `ApplicationContext#getBean()`.
## 7. Завершение работы
Spring вызывает:
- `@PreDestroy`.
- `DisposableBean#destroy()`.
- Метод, указанный в `@Bean(destroyMethod = "cleanup")`.

**Шаги жизненного цикла**:
11. После того как контекст будет закрыт (метод `close()` из `ApplicationContext`), бин уничтожается.
12. Если в бине есть метод, аннотированный `@PreDestroy`, то перед уничтожением вызовется этот метод. Если бин имплементирует `DisposibleBean`, то Spring вызовет метод `destroy()`, чтобы очистить ресурсы или убить процессы в приложении. Если в аннотации `@Bean` определён метод `destroyMethod`, то вызовется и он.
## Пример кода
```java
// Главный бин с логами всех этапов
@Component
class MyBean implements BeanNameAware, ApplicationContextAware, InitializingBean, DisposableBean {
    
    private String beanName;
    private ApplicationContext context;

    public MyBean() {
        System.out.println("1. Конструктор MyBean вызван (Instantiation)");
    }

    @Autowired
    public void setDependency(MyDependency dependency) {
        System.out.println("2. Зависимость MyDependency внедрена (DI)");
    }

    @Override
    public void setBeanName(String name) {
        this.beanName = name;
        System.out.println("3. BeanNameAware: Имя бина - " + name);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.context = applicationContext;
        System.out.println("3. ApplicationContextAware: Контекст передан");
    }

    @PostConstruct
    public void postConstruct() {
        System.out.println("5. @PostConstruct: Бин проинициализирован");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("5. InitializingBean: Бин завершил инициализацию");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("7. @PreDestroy: Перед уничтожением бина");
    }

    @Override
    public void destroy() {
        System.out.println("7. DisposableBean: Бин уничтожен");
    }
}

// Дополнительный бин для DI
@Component
class MyDependency {
    public MyDependency() {
        System.out.println("1. Конструктор MyDependency вызван (Instantiation)");
    }
}

// BeanPostProcessor для логирования этапов postProcessBeforeInitialization и postProcessAfterInitialization
@Component
class MyBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        if (bean instanceof MyBean) {
            System.out.println("4. BeanPostProcessor: Before Init - " + beanName);
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        if (bean instanceof MyBean) {
            System.out.println("6. BeanPostProcessor: After Init - " + beanName);
        }
        return bean;
    }
}

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

Вывод в консоль:
```
1. Конструктор MyDependency вызван (Instantiation)
2. Конструктор MyBean вызван (Instantiation)
3. Зависимость MyDependency внедрена (DI)
4. BeanNameAware: Имя бина - myBean
5. ApplicationContextAware: Контекст передан
6. BeanPostProcessor: Before Init - myBean
7. @PostConstruct: Бин проинициализирован
8. InitializingBean: Бин завершил инициализацию
9. BeanPostProcessor: After Init - myBean
>>> Контекст запущен

>>> Закрытие контекста
10. @PreDestroy: Перед уничтожением бина
11. DisposableBean: Бин уничтожен
```
Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 13.

Один из самых важных моментов, которые следует учитывать при управлении данными, — это сохранение их точности. Нам бы не хотелось, чтобы выполнение какого-либо сценария привело к появлению неверных или несогласованных данных. Предположим, вы разрабатываете приложение для перевода денег — электронный кошелёк. В этом приложении у пользователей есть счета, где они хранят деньги. Вы создаёте функционал, позволяющий переводить средства с одного счета на другой. В качестве примера рассмотрим простейшую реализацию этой опции, которая состоит из двух операций.
1. Снять деньги со счёта отправителя.
2. Положить деньги на счёт получателя.
![spring_14.1](/pictures/spring_14.1.png)

Обе эти операции изменяют данные (изменяющие операции), и для правильного перевода денег обе должны завершиться успешно. Но что случится, если во время выполнения второй операции возникнет проблема и она не выполнится? Если первая операция будет проведена, а вторая — нет, то данные перестанут быть согласованными.

Предположим, Джон переводит Джейн $100. До перевода на счету Джона есть $1000, а у Джейн — $500. После того как перевод завершится, мы ожидаем, что на счету Джона станет на $100 меньше (то есть $1000 – $100 = $900), а у Джейн — на $100 больше: $500 + $100 = $600.

Если вторая операция завершится неудачно, возникнет ситуация, при которой деньги были сняты со счета Джона, но так и не дошли до Джейн. У Джона останется $900, а у Джейн по-прежнему будет $500. Куда девались $100? Это поведение программы показано ниже.
![spring_14.2](/pictures/spring_14.2.png)

Во избежание подобных ситуаций, когда нарушается согласованность данных, необходимо гарантировать, что будут проведены либо обе операции, либо ни одна из них. **Транзакции предоставляют возможность сделать так, чтобы несколько операций либо выполнялись правильно, либо не выполнялись вовсе.**
# Транзакции
**Транзакция** — это определённый набор изменяющих операций, которые либо выполняются корректно все, либо не выполняются вообще. Подобное явление называется **атомарностью**. Транзакции — необходимая часть приложений, они гарантируют согласованность данных в случае, если один из этапов сценария использования, выполняемый после изменения данных, завершится неудачно. Снова рассмотрим (упрощённую) процедуру перевода денег, которая состоит из двух операций.
1. Снять деньги со счёта отправителя.
2. Положить деньги на счёт получателя.

Мы начнём транзакцию перед п. 1 и завершим её после п. 2. Тогда, если оба этапа будут выполнены успешно, при завершении транзакции (после п. 2) приложение сохранит изменения, внесённые на обоих этапах. В этом случае также принято говорить, что транзакция будет «зафиксирована». «**Фиксация**» имеет место в конце транзакции в том случае, если все операции были удачными и приложение может сохранить изменённые данные.
![spring_14.3](/pictures/spring_14.3.png)

Если п. 1 выполнится без проблем, но п. 2 по какой-то причине завершится неудачно, приложение вернётся к состоянию, в котором оно находилось до работы с п. 1. Эта операция называется **откатом**.
# Транзакции в Spring
Рассмотрим, как транзакции работают в Spring и какие возможности предлагает фреймворк для построения их кода. Собственно говоря, транзакции в Spring выполняются на основе аспекта Spring AOP.

Аспект — это код, который вмешивается в работу конкретных методов способом, определяемым программистом. Сегодня методы, выполнение которых должно перехватываться и изменяться посредством аспектов, обычно отмечаются аннотациями. В случае транзакций в Spring происходит то же самое. Чтобы отметить метод, который должен быть задействован в рамках транзакции, используется аннотация **`@Transactional`**. При этом Spring невидимо для нас настраивает конфигурацию аспекта (вы не должны создавать его; за вас это сделает Spring) и применяет логику транзакции для тех операций, которые выполняются в данном методе.
![spring_14.4](/pictures/spring_14.4.png)

Spring знает, что **если при выполнении метод выбросит исключение, то транзакцию нужно откатить.** Часто считают достаточными исключения, возникающие при проведении какой-либо операции внутри метода `transferMoney()`. Но это не так! **Чтобы аспект понял, что нужно откатить изменения, метод транзакции должен передать исключение дальше.** Если метод этого не сделает, а лишь сам обработает исключение своей логикой, аспект так и не узнает, что исключение возникло.
![spring_14.5](/pictures/spring_14.5.png)

> **А КАК БЫТЬ С ПРОВЕРЯЕМЫМИ ИСКЛЮЧЕНИЯМИ В ТРАНЗАКЦИЯХ?**
> 
> До сих пор мы говорили только об исключениях, возникающих при выполнении приложения. А как быть с проверяемыми исключениями? **Проверяемыми исключениями** в Java называют такие исключения, которые нужно обработать или выбросить, иначе приложение не будет скомпилировано. Если метод выдаст подобное исключение, приведет ли это тоже к откату транзакции? По умолчанию — нет! **Spring откатывает транзакцию автоматически только в случае исключения при выполнении.** Это поведение большинства реальных приложений.
> 
> В ситуациях с проверяемым исключением используется условие `throws` в сигнатуре метода, поэтому если они возникают, то не являются причиной, которая может привести к несогласованности данных. Наоборот, это контролируемый процесс, который должен управляться логикой, написанной разработчиком.
> 
> Но если вы хотите, чтобы Spring в случае проверяемых исключений тоже откатывал транзакции, вы можете изменить поведение фреймворка, предусмотренное по умолчанию. **У аннотации `@Transactional` есть атрибуты, позволяющие определить, какие исключения должны приводить к откату транзакций в Spring.**
# Использование транзакций в Spring-приложениях
Начнём с примера, который научит вас использовать транзакции в Spring-приложении. Чтобы объявить транзакцию в приложении Spring, достаточно воспользоваться аннотацией **`@Transactional`** — ею отмечается метод, который Spring должен заключить в транзакцию. Больше ничего делать не нужно. Фреймворк сам создаёт аспект, который будет перехватывать методы с `@Transactional`. Этот аспект запускает транзакцию и либо фиксирует изменения, вносимые методом, если все заканчивается успешно, либо откатывает их, если при выполнении возникает исключение.

Мы напишем приложение, которое сохраняет информацию о состоянии счёта в таблице базы данных. Предположим, что это бэкенд разрабатываемого нами электронного кошелька. Мы создадим функционал для перевода денег с одного счёта на другой. Для реализации этого сценария использования нам понадобится создать транзакцию, чтобы гарантировать согласованность данных в случае, если возникнет исключение.

Структура классов нашего приложения очень проста. Мы будем хранить данные о счетах (включая количество денег) в таблице базы данных. Для работы с этими данными мы создадим репозиторий, а бизнес-логику (реализующую перевод денег) разместим в классе сервиса. Именно для метода сервиса, реализующего бизнес-логику, нам и понадобится транзакция. Чтобы открыть доступ к этому сценарию использования, мы создадим конечную точку в классе контроллера. Для перевода денег с одного счёта на другой нужно будет её вызвать. Структура классов нашего приложения показана ниже.
![spring_14.6](/pictures/spring_14.6.png)

Мы создадим проект Spring Boot и добавим в его файл *pom.xml* зависимости, как показано ниже. Мы продолжим использовать Spring JDBC и базу данных H2, хранящуюся в оперативной памяти:
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>
<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<scope>runtime</scope>
</dependency>
```

Приложение взаимодействует всего с одной таблицей базы данных. Мы назовем эту таблицу `account`, и она будет содержать следующие поля:
- `id` — первичный ключ. Мы определим это поле как автоматически увеличивающееся значение типа `INT`;
- `name` — имя владельца счёта;
- `amount` — сумма денег, которую владелец держит на этом счету.

Для создания таблицы воспользуемся файлом *schema.sql* в папке ресурсов проекта. Запишем туда следующий SQL-запрос для создания таблицы:
```sql
create table account (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(50) NOT NULL,
	amount DOUBLE NOT NULL
);
```

Кроме *schema.sql*, мы разместим в папке ресурсов файл *data.sql*, чтобы сделать две записи, которые впоследствии понадобятся для тестирования приложения. В *data.sql* содержатся два SQL-запроса, создающие в базе данных две записи счетов. Эти запросы выглядят так:
```sql
INSERT INTO account VALUES (NULL, 'Helen Down', 1000);
INSERT INTO account VALUES (NULL, 'Peter Read', 1000);
```

Чтобы получить доступ к данным из приложения, нам нужен класс, моделирующий таблицу счетов. Поэтому мы создадим класс `Account`, который будет моделировать записи счетов в базе данных.
```java
public class Account {

	private long id;
	private String name;
	private BigDecimal amount;
	
	// Геттеры и сеттеры
}
```

Чтобы реализовать сценарий использования «перевод денег», нам понадобятся следующие функции на уровне репозитория.
1. Поиск информации о счёте по ID этого счета.
2. Изменение баланса для заданного счёта.

Мы реализуем эти функции с помощью `JdbcTemplate`. Для выполнения пункта 1 создадим метод `findAccountById(long id)`, который получает ID счёта в виде параметра и благодаря `JdbcTemplate` берёт из базы данных информацию о счёте с заданным ID. Для выполнения пункта 2 нам понадобится метод `changeAmount(long id, BigDecimal amount)`. Он присваивает сумму, которую получает в виде второго параметра, счёту, ID которого является первым параметром метода. Реализация этих двух методов показана ниже.
```java
@Repository
public class AccountRepository { 

	private final JdbcTemplate jdbc; 
	
	public AccountRepository(JdbcTemplate jdbc) { 
		this.jdbc = jdbc; 
	} 
	
	public Account findAccountById(long id) { 
		String sql = "SELECT * FROM account WHERE id = ?"; 
		return jdbc.queryForObject(sql, new AccountRowMapper(), id); 
	} 
	
	public void changeAmount(long id, BigDecimal amount) { 
		String sql = "UPDATE account SET amount = ? WHERE id = ?"; 
		jdbc.update(sql, amount, id); 
	}
}
```

При использовании `JdbcTemplate` для получения информации из базы данных посредством запроса `SELECT` необходимо создать объект `RowMapper`, который покажет `JdbcTemplate`, как преобразовать каждую строку результата из базы данных в конкретную модель объекта. В данном случае нам нужно показать `JdbcTemplate`, как модифицировать строку в объект `Account`.
```java
public class AccountRowMapper implements RowMapper<Account> { 

	@Override public Account mapRow(ResultSet resultSet, int i) throws SQLException { 
		Account a = new Account(); 
		a.setId(resultSet.getInt("id")); 
		a.setName(resultSet.getString("name")); 
		a.setAmount(resultSet.getBigDecimal("amount")); 
		return a; 
	}
}
```

Чтобы нам было проще проверить работу приложения, добавим ещё одну функцию, позволяющую получить из базы данных информацию о счёте. Мы будем использовать эту функцию для уверенности, что приложение работает как положено.
```java
@Repository
public class AccountRepository {

	// Остальной код
	
	public List<Account> findAllAccounts() {
		String sql = "SELECT * FROM account";
		return jdbc.query(sql, new AccountRowMapper());
	}
}
```

В классе сервиса мы реализовали логику сценария использования «перевод денег». Для управления данными в таблице счетов в классе `TransferService` использован класс `AccountRepository`. В методе реализована следующая логика.
1. Получить информацию о счетах отправителя и получателя и извлечь оттуда баланс для каждого счета.
2. Снять сумму перевода со счёта отправителя. Для этого счёту присваивается новое значение, представляющее собой старый баланс минус сумма перевода.
3. Положить сумму перевода на счёт получателя. Для этого счету присваивается новое значение, представляющее собой старый баланс плюс сумма перевода.

Ниже представлен метод `transferMoney()` класса сервиса, в котором реализована эта логика. Обратите внимание, что пункты 2 и 3 являются изменяющими операциями — обе изменяют сохранённые данные (баланс счета). Если выполнять их не в транзакции, то неудачное завершение одной из них может привести к несогласованности данных.
```java
@Service
public class TransferService { 
	
	private final AccountRepository accountRepository; 
	
	public TransferService(AccountRepository accountRepository) { 
		this.accountRepository = accountRepository; 
	} 
	
	@Transactional 
	public void transferMoney(long idSender, long idReceiver, BigDecimal amount) { 
		Account sender = accountRepository.findAccountById(idSender); 
		Account receiver = accountRepository.findAccountById(idReceiver); 
		
		BigDecimal senderNewAmount = sender.getAmount().subtract(amount); 
		BigDecimal receiverNewAmount = receiver.getAmount().add(amount); 
		
		accountRepository.changeAmount(idSender, senderNewAmount); 
		accountRepository.changeAmount(idReceiver, receiverNewAmount); 
	}
}
```

К счастью, чтобы отметить метод как транзакционный и сообщить Spring, что его выполнение необходимо перехватить и заключить в транзакцию, достаточно поставить перед методом аннотацию `@Transactional`.

Ниже визуально представлена область транзакции и операции, которые выполняет метод `transferMoney()`.
![spring_14.7](/pictures/spring_14.7.png)

Напишем также метод, получающий данные для всех счетов. Мы предоставим доступ к нему посредством конечной точки в классе контроллера, который создадим позже. Мы будем применять этот метод при тестировании сценария использования «перевод денег», чтобы убедиться, что данные были изменены правильно.

> **ИСПОЛЬЗОВАНИЕ АННОТАЦИИ `@TRANSACTIONAL`**
> 
> **Аннотацию `@Transactional` можно использовать и для всего класса.** Если аннотация относится к классу (как показано в следующем примере кода), то она применяется ко всем его методам. В реальных приложениях `@Transactional` часто применяют именно к классу, поскольку методы класса сервиса определяют сценарии использования и, как правило, все эти сценарии должны выполняться в рамках транзакций. Чтобы не ставить аннотацию перед каждым методом, проще сразу отметить ею весь класс. **При использовании `@Transactional` и для класса, и для метода уровень метода переопределяет уровень класса**:
```java
@Service
@Transactional
public class TransferService { 
	// Остальной код 
	
	public void transferMoney(long idSender, long idReceiver, BigDecimal amount) { 
		// Остальной код 
	}
}
```

Ниже показана реализация метода `getAllAccounts()`, который возвращает список всех записей счетов, существующих в базе данных.
```java
@Service
public class TransferService {

	// Остальной код
	
	public List<Account> getAllAccounts() {
		return accountRepository.findAllAccounts();
	}
}
```

Ниже представлена реализация класса `AccountController`, в котором определены конечные точки для доступа к методам сервиса.
```java
@RestController
public class AccountController {

	private final TransferService transferService;
	 
	public AccountController(TransferService transferService) { 
		this.transferService = transferService; 
	}
	
	@PostMapping("/transfer") 
	public void transferMoney(@RequestBody TransferRequest request) {
		transferService.transferMoney(request.getSenderAccountId(), 
			request.getReceiverAccountId(), 
			request.getAmount()); 
	} 
	
	@GetMapping("/accounts") 
	public List<Account> getAllAccounts() { 
		return transferService.getAllAccounts(); 
	}
}
```

В качестве параметра для действия контроллера `transferMoney()` мы будем использовать объект типа `TransferRequest`, моделирующий тело HTTP-запроса. Подобные объекты, обязанность которых состоит в моделировании данных, передаваемых между двумя приложениями, являются DTO. Ниже показано определение DTO `TransferRequest`.
```java
public class TransferRequest {

	private long senderAccountId;
	private long receiverAccountId;
	private BigDecimal amount;
	
	// Остальной код
}
```

Запустим приложение и проверим, как работает транзакция. Для вызова конечных точек, предоставляемых приложением, можно использовать cURL или Postman. Вначале вызовем конечную точку `/accounts`, чтобы посмотреть, как выглядят данные до перевода денег. Ниже представлена команда cURL для вызова конечной точки `/accounts`:
```
curl http://localhost:8080/accounts
```

После выполнения этой команды в консоли должен появиться следующий вывод:
```json
[
	{"id":1,"name":"Helen Down","amount":1000.0},
	{"id":2,"name":"Peter Read","amount":1000.0}
]
```

В базе данных есть два счёта. У Хелен и Питера есть по $1000. Теперь выполним сценарий использования «перевод денег» и переведем Питеру от Хелен $100. Для этого нужно вызвать конечную точку `/transfer` с помощью следующей команды cURL:
```
curl -XPOST -H "content-type:application/json" -d '{"senderAccountId":1, "receiverAccountId":2, "amount":100}' http://localhost:8080/transfer
```

Если теперь снова вызовем конечную точку `/accounts`, увидим, что суммы на счетах изменились. После перевода денег у Хелен осталось $900, а у Питера теперь есть $1100:
```
curl http://localhost:8080/accounts
```

Результат вызова конечной точки `/accounts` после перевода денег выглядит так:
```json
[
	{"id":1,"name":"Helen Down","amount":900.0},
	{"id":2,"name":"Peter Read","amount":1100.0}
]
```

Приложение работает, и выполнение сценария использования приводит к ожидаемому результату. Но как убедиться, что транзакция действительно функционирует? Пока всё идёт хорошо, приложение правильно сохраняет данные, но как узнать, вернёт ли оно данные к исходному состоянию, если что-то внутри метода приведёт к исключению при выполнении? Следует ли просто принять это на веру? Конечно же, нет!

Проверим, работает ли откат транзакции так, как ожидается, в случае исключения при выполнении. Добавим туда всего одну строку кода в конце метода сервиса `transferMoney()` — эта строка выдаёт исключение при выполнении, как показано ниже.
```java
@Service
public class TransferService { 
	
	// Остальной код
	
	@Transactional 
	public void transferMoney(long idSender, long idReceiver, BigDecimal amount) { 
		Account sender = accountRepository.findAccountById(idSender); 
		Account receiver = accountRepository.findAccountById(idReceiver); 
		
		BigDecimal senderNewAmount = sender.getAmount().subtract(amount); 
		BigDecimal receiverNewAmount = receiver.getAmount().add(amount); 
		
		accountRepository.changeAmount(idSender, senderNewAmount); 
		accountRepository.changeAmount(idReceiver, receiverNewAmount); 
		
		throw new RuntimeException("Oh no! Something went wrong!");
	}
}
```

Ниже показано, какие изменения мы внесли в метод сервиса `transferMoney()`.
![spring_14.8](/pictures/spring_14.8.png)

Запустим приложение и проверим данные о счетах, вызвав конечную точку `/accounts`, которая возвращает все записи о счетах, хранящиеся в базе данных:
```
curl http://localhost:8080/accounts
```

После выполнения этой команды в консоли должно появиться следующее:
```json
[
	{"id":1,"name":"Helen Down","amount":1000.0},
	{"id":2,"name":"Peter Read","amount":1000.0}
]
```

Как и в предыдущем тесте, вызовем конечную точку `/transfer`, чтобы перевести Питеру от Хелен $100. Для этого воспользуемся следующей командой cURL:
```
curl -XPOST -H "content-type:application/json" -d '{"senderAccountId":1, "receiverAccountId":2, "amount":100}' http://localhost:8080/transfer
```

Но теперь метод `transferMoney()` класса сервиса выбрасывает исключение, из-за чего в ответ на запрос клиент получает ошибку 500. Вы увидите это исключение в консоли приложения. Трассировка стека исключения выглядит приблизительно так:
```
java.lang.RuntimeException: Oh no! Something went wrong!
at
com.example.services.TransferService.transferMoney(TransferService.java:30) ~[classes/:na]
at
com.example.services.TransferService$$FastClassBySpringCGLIB$$338bad6b.invoke (<generated>) ~[classes/:na]
at
org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.3.jar:5.3.3]
```

Cнова вызовем конечную точку `/accounts` и посмотрим, изменились ли данные о счетах:
```
curl http://localhost:8080/accounts
```

После выполнения этой команды в консоли приложения должно появиться следующее:
```json
[
	{"id":1,"name":"Helen Down","amount":1000.0},
	{"id":2,"name":"Peter Read","amount":1000.0}
]
```

Как видим, данные остались теми же, несмотря на то что исключение возникло после выполнения двух операций, изменяющих балансы счетов. На счету Хелен должно было быть $900, а на счету Питера — $1100. Однако там остались те же суммы, что и раньше. Так произошло потому, что приложение выполнило откат транзакции, из-за чего данные вернулись к состоянию, в котором они находились в начале транзакции. Были выполнены обе операции, изменяющие данные, но потом аспект транзакций Spring получил исключение при выполнении — и всё отменил.
Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 11.

**REST-сервисы** — типичный способ организации обмена данными между двумя системными компонентами. С помощью REST-сервисов клиент веб-приложения может обратиться к бэкенду или же один из компонентов бэкенда — к другому. В серверных решениях, состоящих из нескольких сервисов, таким компонентам нужен способ «поговорить друг с другом» и обменяться данными. Поэтому при реализации подобных сервисов с помощью Spring нужно уметь вызывать конечные точки REST других сервисов.
![spring_12.1](/pictures/spring_12.1.png)

Мы рассмотрим следующие три способа вызова конечных точек REST из Spring-приложения.
1. **OpenFeign** — инструмент из проекта Spring Cloud.
2. **RestTemplate** — инструмент, который применяется для вызова конечных точек REST, начиная со Spring 3. RestTemplate и сегодня популярен у разработчиков и широко используется в Spring-приложениях.
3. **WebClient** — функция Spring, призванная стать заменой для RestTemplate. Основана на другой концепции — **реактивном программировании**.

Чтобы изучить эти три фундаментальные методики, мы напишем примеры для них. Вначале разработаем проект, в котором используется конечная точка. Нашей целью будет вызов конечной точки каждым из трёх описанных способов: OpenFeign, RestTemplate и WebClient. Предположим, вы хотите создать приложение, позволяющее пользователям выполнять электронные платежи. Чтобы совершить платеж, нужно вызвать конечную точку другого приложения. Этот сценарий наглядно представлен ниже, а также подробно показана схема передачи запроса и ответа.
![spring_12.2](/pictures/spring_12.2.png)
![spring_12.3](/pictures/spring_12.3.png)

В первом проекте мы создадим приложение сервиса платежей — оно нам понадобится во всех остальных примерах.

Поскольку это веб-приложение, здесь нужно добавить веб-зависимость в файл *pom.xml*:
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

Модель платежа опишем в виде класса `Payment`:
```java
public class Payment {
	private String id;
	private double amount;
	
	// Геттеры и сеттеры
}
```

Реализация конечной точки в классе контроллера показана ниже. В техническом отношении здесь нет ничего сложного. Метод получает экземпляр `Payment`, присваивает платежу случайный ID и возвращает его. Конечная точка очень проста, но вполне подходит для демонстрационных целей. В ней используется HTTP-метод POST. Нам нужно определить заголовок и тело запроса. При вызове конечной точки возвращается HTTP-ответ с заголовком и объектом `Payment` в теле запроса.
```java
@RestController
public class PaymentsController { 

	private static Logger logger = Logger.getLogger(PaymentsController.class.getName());
	
	@PostMapping("/payment") 
	public ResponseEntity<Payment> createPayment(@RequestHeader String requestId, 
		@RequestBody Payment payment) { 
		logger.info("Received request with ID " + requestId + 
			" ;Payment Amount: " + payment.getAmount()); 
		
		payment.setId(UUID.randomUUID().toString()); 
		
		return ResponseEntity 
			.status(HttpStatus.OK) 
			.header("requestId", requestId) 
			.body(payment); 
	}
}
```
# Вызов конечной точки REST с помощью OpenFeign из Spring Cloud
Рассмотрим современную технологию вызова конечных точек REST. В большинстве Spring-приложений разработчики используют инструмент RestTemplate. Как мы помним, начиная с версии Spring 5, данный инструмент переведён в режим обслуживания. Более того, он скоро устареет, так что лучше начнем с инструмента, который рекомендуется использовать как альтернативу RestTemplate, — **OpenFeign**.

Для OpenFeign нужно написать только интерфейс — остальное этот инструмент сделает сам.

Чтобы понять, как функционирует OpenFeign, мы создадим проект и разработаем приложение, в котором будем использовать OpenFeign для вызова конечной точки приложения.
![spring_12.4](/pictures/spring_12.4.png)

Мы определим интерфейс и объявим в нём методы, которые будут использовать конечные точки REST. Единственное, что для этого нужно, — снабдить методы аннотациями, где определены путь, HTTP-метод и при необходимости параметры, заголовки и тело запроса. Интересный момент: нам не нужно описывать сами методы. Как только мы определим те из них, которые будут основаны на аннотациях, фреймворк сам напишет их реализацию. Таким образом, мы снова полагаемся на прекрасную магию Spring.

Ниже показана структура класса для создаваемого нами приложения, которое использует конечные точки REST.
![spring_12.5](/pictures/spring_12.5.png)

В файле *pom.xml* нужно определить следующую зависимость:
```xml
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

Определив эту зависимость, мы можем создать прокси-интерфейс. В терминологии OpenFeign такой интерфейс также называют **клиентом OpenFeign**. OpenFeign создаёт его реализацию, так что нам не придётся писать код, вызывающий конечную точку, — хватит нескольких аннотаций, сообщающих, как именно нужно отправлять запрос. Ниже видно, как легко создаются описания запросов при использовании OpenFeign.
```java
@FeignClient(name = "payments", url = "${name.service.url}")
public interface PaymentsProxy {

	@PostMapping("/payment") 
	Payment createPayment(@RequestHeader String requestId, 
		@RequestBody Payment payment);
}
```

Прежде всего необходимо снабдить интерфейс аннотацией **`@FeignClient`**. Она сообщает OpenFeign, что нужно создать реализацию данного контракта. С помощью атрибута `name` аннотации `@FeignClient` определяется имя прокси для внутреннего использования в OpenFeign. Это имя однозначно идентифицирует данного клиента в приложении. В `@FeignClient` также формируется базовый URI запроса, представляющий собой строку, которая является значением атрибута `url`.

> Всегда храните URI и другие параметры, которые могут зависеть от среды, только в файлах свойств. Никогда не вписывайте их жёстко в код приложения.

Свойства проекта хранятся в файле *application.properties* и доступны в коде с помощью синтаксиса `${property_name}`. Благодаря этому вам не придётся заново компилировать код всякий раз, когда потребуется запускать приложение в новой среде.

Каждый метод, объявленный в интерфейсе, соответствует вызову конечной точки REST. Для предоставления доступа к точкам для действий контроллера применяются те же аннотации, которые вам уже знакомы:
- для определения пути и HTTP-метода: `@GetMapping`, `@PostMapping`, `@PutMapping` и т. п.;
- для определения заголовка запроса: `@RequestHeader`;
- для определения тела запроса: `@RequestBody`.

Возможность многократного использования аннотаций (одних и тех же и для OpenFeign, и для определения конечных точек) является очень полезной. Получается, для работы с OpenFeign вам не придётся специально что-то изучать — просто используйте те же инструменты, что и в Spring MVC.

Нам нужно сообщить OpenFeign, где находятся интерфейсы, определяющие контракты клиентов. Для этого воспользуйтесь аннотацией **`@EnableFeignClients`**. Ниже представлен класс конфигурации проекта, в котором активированы клиенты OpenFeign.
```java
@Configuration
@EnableFeignClients(basePackages = "com.example.proxy")
public class ProjectConfig {
}
```

Теперь можно внедрить клиент OpenFeign через интерфейс, определённый ранее. Поскольку инструмент OpenFeign активирован, он знает, как реализовать интерфейсы с аннотациями `@FeignClient`. Spring сам знает, как создать экземпляр бина из контекста при использовании абстракций, — именно это мы сейчас и делаем. Ниже представлен класс контроллера, в котором внедряется OpenFeign.
```java
@RestController
public class PaymentsController {

	private final PaymentsProxy paymentsProxy;
	
	public PaymentsController(PaymentsProxy paymentsProxy) {
		this.paymentsProxy = paymentsProxy;
	}
	
	@PostMapping("/payment")
	public Payment createPayment(@RequestBody Payment payment) {
		String requestId = UUID.randomUUID().toString();
		return paymentsProxy.createPayment(requestId, payment);
	}
}
```

Теперь запустим оба проекта (сервис платежей и приложение, которое мы написали в этом разделе) и вызовем конечную точку `/payment` приложения, используя cURL или Postman. В случае cURL команда запроса выглядит так:
```
curl -X POST -H 'content-type:application/json' -d '{"amount":1000}' http://localhost:9090/payment
```

После выполнения команды cURL в консоли появится такой ответ:
```json
{
	"id":"1c518ead-2477-410f-82f3-54533b4058ff",
	"amount":1000.0
}
```

В консоли сервиса платежей вы обнаружите запись, подтверждающую, что приложение корректно передало запрос сервису платежей:
```
Received request with ID 1c518ead-2477-410f-82f3-54533b4058ff ;Payment Amount: 1000.0
```
# Вызов конечных точек REST с помощью RestTemplate
Далее мы снова создадим приложение, вызывающее конечную точку `/payment` сервиса платежей, но на этот раз воспользуемся другим инструментом — **RestTemplate**.

Этот инструмент отправляют на покой не потому, что он работает неправильно, и не потому, что он плохой. Просто приложения совершенствуются и требуют более широкого функционала. Разработчики хотят пользоваться разными технологиями, но не ко всем из них можно легко получить доступ при помощи RestTemplate. Среди них:
- синхронный и асинхронный вызов конечных точек;
- возможность писать меньше кода и обрабатывать меньше исключений (избегать шаблонного кода);
- возможность выполнять повторные вызовы и операции отката (логика, которая осуществляется, когда приложение по какой-то причине не может выполнить определённый вызов REST).

Другими словами, разработчики предпочитают по возможности получать больше готовых функций, чтобы меньше писать код самим. Напомню: как раз в этом — в повторном использовании кода и возможности избежать шаблонного кода — заключается главная цель применения фреймворков. Сравнив примеры, созданные нами ранее, вы сможете оценить сами, насколько проще использовать OpenFeign по сравнению с RestTemplate.

Чтобы создать вызов, нужно выполнить следующие операции.
1. Описать HTTP-заголовки, создав и настроив конфигурацию экземпляра `HttpHeaders`.
2. Создать экземпляр `HttpEntity`, в котором представлены данные запроса (заголовки и тело).
3. С помощью метода `exchange()` отправить HTTP-вызов и получить HTTP-ответ.
![spring_12.6](/pictures/spring_12.6.png)

Выполним этот пример. Определение прокси-класса вы найдете ниже. Обратите внимание, как описан заголовок с помощью экземпляра `HttpHeaders` в методе `createPayment()` и как с помощью метода `add()` к этому экземпляру добавлен заголовок `requestId`. На базе имеющихся заголовков и тела (которые метод получает в качестве параметров) создаётся экземпляр `HttpEntity`. После этого с помощью принадлежащего RestTemplate метода `exchange()` отправляется HTTP-запрос. Параметрами `exchange()` являются URI и HTTP-метод, а также экземпляр `HttpEntity` (в котором хранятся данные запроса) и тип, который ожидается в теле ответа.
```java
@Component
public class PaymentsProxy { 

	private final RestTemplate rest; 
	
	@Value("${name.service.url}") 
	private String paymentsServiceUrl; 
	
	public PaymentsProxy(RestTemplate rest) { 
		this.rest = rest; 
	} 
	
	public Payment createPayment(Payment payment) { 
		String uri = paymentsServiceUrl + "/payment"; 
		
		HttpHeaders headers = new HttpHeaders(); 
		headers.add("requestId", UUID.randomUUID().toString()); 
		
		HttpEntity<Payment> httpEntity = new HttpEntity<>(payment, headers); 
		
		ResponseEntity<Payment> response = rest.exchange(uri, 
			HttpMethod.POST, 
			httpEntity, 
			Payment.class); 
		
		return response.getBody(); 
	}
}
```

Мы определили простую конечную точку, которую можно будет вызывать с помощью этой реализации. Ниже показано определение класса контроллера.
```java
@RestController
public class PaymentsController { 

	private final PaymentsProxy paymentsProxy; 
	
	public PaymentsController(PaymentsProxy paymentsProxy) { 
		this.paymentsProxy = paymentsProxy; 
	} 
	
	@PostMapping("/payment") 
	public Payment createPayment(@RequestBody Payment payment) { 
		return paymentsProxy.createPayment(payment); 
	}
}
```

Запустив оба приложения — сервис платежей и новое приложение — на разных портах, мы убедимся, что всё работает, как предполагалось.

Чтобы вызвать конечную точку приложения, можно воспользоваться следующей командой cURL:
```
curl -X POST -H 'content-type:application/json' -d '{"amount":1000}' http://localhost:9090/payment
```

В результате в консоли появится следующий ответ:
```json
{
	"id":"21149959-d93d-41a4-a0a3-426c6fd8f9e9",
	"amount":1000.0
}
```

В консоли сервиса платежей вы найдете журнал, подтверждающий, что приложение правильно отправило запрос сервиса:
```
Received request with ID 21149959-d93d-41a4-a0a3-426c6fd8f9e9 ;Payment Amount: 1000.0
```
# Вызов конечной точки REST с помощью WebClient
Обсудим вызов конечных точек REST с помощью WebClient. **WebClient** — это инструмент, используемый в различных приложениях и построенный на базе методологии, называемой **реактивным программированием**.

В документации Spring рекомендуется использовать WebClient, но это **имеет смысл только для приложений, написанных по технологии реактивного программирования**. Если вы не создаёте реактивный продукт, лучше применять OpenFeign. Как и всё остальное в мире программного обеспечения, WebClient хорошо работает в одних случаях и может создавать проблемы в других. Выбирая WebClient для вызова конечных точек REST, вы обрекаете приложение на то, чтобы быть реактивным.

**В нереактивных приложениях процесс бизнес-логики выполняется в потоке.** Этот процесс состоит из множества задач, которые не являются независимыми друг от друга. Все они выполняются в одном потоке. Рассмотрим пример, чтобы проследить, в каких случаях при таком подходе могут возникнуть проблемы и что здесь можно улучшить.

Предположим, мы разрабатываем банковское приложение, в котором у пользователя есть один или несколько кредитных счетов. Мы создаём компонент, который вычисляет общий долг клиента банка. Этот функционал реализуют другие элементы системы, выполняя REST-вызовы, где передаётся уникальный ID пользователя. Для вычисления долга в разрабатываемом нами процессе проводятся следующие операции.
1. Приложение получает ID пользователя.
2. Приложение вызывает другой сервис системы, который определяет, есть ли у данного пользователя кредиты в других учреждениях.
3. Приложение вызывает ещё один сервис системы, сообщающий о долгах пользователя по внутренним кредитам.
4. Если у пользователя есть внешние долги, приложение вызывает внешний сервис, который вычисляет размер внешнего долга.
5. Приложение суммирует все долги и возвращает значение в виде HTTP-ответа.
![spring_12.7](/pictures/spring_12.7.png)

Это всего лишь примерные шаги функционала, чтобы показать, в каких случаях может быть полезно создание реактивного приложения. Тщательно проанализируем эти операции. Ниже показана схема выполнения рассматриваемого сценария с точки зрения потока.
![spring_12.8](/pictures/spring_12.8.png)

Для каждого запроса приложение создаёт новый поток, где операции выполняются последовательно, одна за другой. Прежде чем перейти к следующей операции, поток вынужден ожидать, пока не завершится предыдущая. **Всякий раз, когда приложение выполняет операцию ввода-вывода, поток блокируется.**

Здесь мы наблюдаем две серьёзные проблемы.
1. **Операции ввода-вывода блокируют поток**: пока они выполняются, поток бездействует и лишь занимает место в памяти приложения. Он потребляет ресурсы, не принося никакой пользы. При таком подходе возможны ситуации, когда приложение получит сразу десять запросов, но все потоки будут заняты, ожидая информацию от других систем.
2. **Некоторые задачи не зависят друг от друга**. Например, приложение может одновременно выполнять п. 2 и 3. Нет необходимости ждать, пока закончится действие в п. 2, чтобы перейти к п. 3. Приложению просто нужно в итоге получить результат обеих операций и вычислить суммарный долг.

При реактивном программировании мы отказываемся от идеи существования одного неделимого процесса, все задачи которого от начала и до конца выполняются в единственном потоке. **В реактивных приложениях задачи считаются независимыми друг от друга, и для выполнения процесса, состоящего из нескольких задач, могут совместно использоваться несколько потоков.**

Теперь функционал представляется не как последовательность операций, расположенных вдоль одной временной оси, а как пул задач, которые выполняет целая команда разработчиков. Пользуясь данной аналогией, вам будет проще представить работу реактивного приложения: разработчики — это потоки, а пул задач — операции функционала.

Два разработчика могут выполнять две разные задачи одновременно, если они не зависят одна от другой. Если задача стопорится из-за внешней зависимости, разработчик может временно её приостановить и заняться чем-нибудь ещё. Когда она разблокируется, разработчик сможет снова к ней вернуться или же эту задачу закончит его коллега.
![spring_12.9](/pictures/spring_12.9.png)

При таком подходе нам больше не нужен отдельный поток для каждого запроса. Мы можем обрабатывать несколько запросов и с меньшим количеством потоков, так как им больше не приходится простаивать. Если выполнение одной из задач блокируется, поток может оставить её и заняться другой, свободной.

В техническом отношении в реактивном приложении создаётся процесс, в котором определены задачи и зависимости между ними. Спецификация реактивного приложения предусматривает два компонента для представления зависимостей между задачами: **поставщик** и **подписчик**.

Задача возвращает поставщика, который позволяет другим задачам подписываться на него, тем самым обозначая их зависимость. Задача использует подписчика, чтобы присоединиться к поставщику другой задачи и получить результат выполнения этой задачи, когда она завершится.

Ниже показан обсуждавшийся нами ранее сценарий, реализованный по принципу реактивного программирования. Уделите пару минут и сравните эту схему с рисунком ранее. Теперь задачи не являются последовательными точками на шкале времени — они не зависят от потока и сами объявляют свои зависимости. Задачи выполняются несколькими потоками, и ни одному из них не приходится ждать разблокировки конкретной задачи, пока проводится операция ввода-вывода. Вместо этого поток может выполнить другую задачу.
![spring_12.10](/pictures/spring_12.10.png)

Более того, задачи, зависящие одна от другой, также могут выполняться одновременно. На рисунке выше операции C и D, соответствующие п. 2 и 3 исходного процесса, могут проводиться параллельно, что повышает производительность приложения.

Поскольку WebClient предполагает реактивный подход, вместо стандартной веб-зависимости нужно добавить зависимость, которая называется **WebFlux**. В следующем фрагменте кода показано, как добавить WebFlux в файл *pom.xml* готового проекта или при создании проекта с помощью `start.spring.io`:
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
```

Для вызова конечной точки REST нам понадобится экземпляр `WebClient`. Наилучший способ организовать удобный доступ к такому экземпляру — поместить бин в контекст Spring, создав в классе конфигурации метод с аннотацией `@Bean`. Класс конфигурации приложения представлен ниже.
```java
@Configuration
public class ProjectConfig {

	@Bean
	public WebClient webClient() {
		return WebClient
			.builder()
			.build();
	}
}
```

Ниже показан прокси-класс, где используется `WebClient` для вызова конечной точки, предоставляемой приложением. Логика класса аналогична той, с которой вы познакомились в разделе о RestTemplate: извлекаем из файла свойств базовый URL, определяем HTTP-метод, заголовки и тело, после чего осуществляем вызов. Методы `WebClient` называются иначе, но по их именам нетрудно понять, что именно они делают.
```java
@Component
public class PaymentsProxy { 

	private final WebClient webClient; 
	
	@Value("${name.service.url}") 
	private String url; 
	
	public PaymentsProxy(WebClient webClient) { 
		this.webClient = webClient; 
	} 
	
	public Mono<Payment> createPayment(String requestId, Payment payment) { 
		return webClient.post() 
			.uri(url + "/payment") 
			.header("requestId", requestId) 
			.body(Mono.just(payment), Payment.class) 
			.retrieve() 
			.bodyToMono(Payment.class); 
	}
}
```

В нашем примере мы создали класс с именем `Mono`. Этот класс определяет поставщика. Вы найдете его в коде, где метод, выполняющий вызов, получает входные данные не непосредственно, а через `Mono`. Благодаря этому можно создать независимую задачу, которая будет формировать тело запроса. `WebClient` является подписчиком этой задачи и, таким образом, зависит от неё.

Данный метод также не возвращает значение непосредственно. Вместо этого он возвращает экземпляр `Mono`, что позволяет другим функциям подписываться на него. Таким образом, процесс в приложении формируется не путём соединения задач в поток, а через установление зависимостей между ними посредством поставщиков и потребителей.
![spring_12.11](/pictures/spring_12.11.png)

Выше также показан прокси-метод, который принимает экземпляр `Mono`, формируемый из тела HTTP-запроса, и возвращает этот экземпляр задаче, на которую подписан функционал WebFlux.

Дабы убедиться, что всё работает правильно, мы, как и в предыдущих примерах, создадим класс контроллера, использующий прокси для предоставления доступа к конечной точке. Мы будем вызывать эту конечную точку, чтобы протестировать поведение нашего приложения. Класс контроллера представлен ниже.
```java
@RestController
public class PaymentsController {

	private final PaymentsProxy paymentsProxy;
	
	public PaymentsController(PaymentsProxy paymentsProxy) {
		this.paymentsProxy = paymentsProxy;
	}
	
	@PostMapping("/payment")
	public Mono<Payment> createPayment(@RequestBody Payment payment) {
		String requestId = UUID.randomUUID().toString();
		return paymentsProxy.createPayment(requestId, payment);
	}
}
```

Чтобы протестировать работу обоих приложений можно вызвать конечную точку `/payment` с помощью cURL или Postman. В случае cURL команда запроса выглядит так:
```
curl -X POST -H 'content-type:application/json' -d '{"amount":1000}' http://localhost:9090/payment
```

После выполнения команды cURL увидим в консоли примерно такой ответ:
```json
{
	"id":"e1e63bc1-ce9c-448e-b7b6-268940ea0fcc",
	"amount":1000.0
}
```

В консоли сервиса платежей появится запись, подтверждающая, что приложение, разработанное в этом разделе, правильно отправляет запросы сервису платежей:
```
Received request with ID e1e63bc1-ce9c-448e-b7b6-268940ea0fcc ;Payment Amount: 1000.0
```
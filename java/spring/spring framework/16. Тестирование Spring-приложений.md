Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 15.

**Тест** — это небольшой фрагмент логики, назначение которого — убедиться, что определённая функция приложения работает так, как должна. Тесты делятся на две категории:
- **модульные тесты** — касаются только определённого участка логики;
- **интеграционные тесты** — предназначены для проверки правильного взаимодействия нескольких компонентов.

Тесты необходимы для любого приложения. Они гарантируют, что изменения, которые вносятся в процессе разработки приложения, не нарушат уже существующие функции (или как минимум снизят вероятность появления ошибок). Кроме того, тесты играют роль документации. Многие разработчики, к сожалению, ими пренебрегают, поскольку они не являются непосредственной частью бизнес-логики приложения, но при этом, разумеется, на их написание уходит какое-то время. Из-за этого кажется, что тесты не особенно и важны. Однако в действительности, хоть их значение не всегда заметно с первого взгляда, в долговременной перспективе тесты неоценимы.

Зачем писать тесты, если можно просто отладить функцию вручную и успокоиться? Потому что:
- **тесты можно запускать снова и снова**, постоянно таким образом проверять адекватность функционирования приложения и, затрачивая минимум усилий, убеждаться, что всё работает правильно;
- **тесты можно использовать в качестве документации**: читая этапы тестирования, мы легко понимаем назначение конкретного сценария использования;
- если в процессе разработки **в приложении возникнут проблемы, благодаря тестам вы быстро об этом узнаете**.

Почему приложение вдруг перестаёт работать, если раньше всё было хорошо? Потому что мы постоянно модифицируем его исходный код, исправляем ошибки и добавляем новые опции. Внося изменения, можно нарушить реализованный ранее функционал.

Если написать тесты для этого функционала, можно выполнять их всякий раз, когда в приложении происходят изменения, чтобы проверить адекватность его работы. Если какая-нибудь из уже настроенных опций будет нарушена, вы узнаете об этом прежде, чем код будет сдан в эксплуатацию. **Регрессивное тестирование** — это постоянное тестирование существующего функционала с целью убедиться, что всё работает правильно.

Хорошим подходом является **создать тесты для всех сценариев, соответствующих каждой разработанной функции**. Затем их можно выполнять всякий раз, когда вы что-нибудь измените, для уверенности, что изменения не повлияли на созданный ранее функционал.

В настоящее время нельзя полагаться только на то, что разработчики выполнят все тесты вручную — тестирование становится частью процесса создания приложения. Как правило, в группах разработчиков практикуют то, что принято называть **принципом непрерывной интеграции (continuous integration, CI)**: берётся инструмент наподобие Jenkins или TeamCity и настраивается так, чтобы выполнять сборку всякий раз, когда в приложение вносится изменение. Инструмент непрерывной интеграции — это программный продукт, применяемый для проведения операций, который необходим для сборки и — иногда — установки приложений в процессе разработки. Инструмент CI также выполняет тесты и отправляет уведомления разработчикам, если что-то ломается.
![spring_16.1](/pictures/spring_16.1.png)
# Как писать правильные тесты
Вы научитесь разрабатывать код приложения таким образом, чтобы его было удобно тестировать, и увидите, что существует прямая связь между приложением, которое удобно тестировать, и приложением, которое легко поддерживать (то есть легко вносить изменения для реализации новых функций и устранения ошибок). **Тестируемость** и **поддерживаемость** — характеристики, усиливающие друг друга. Проектируя тестируемое приложение, вы также делаете его поддерживаемым.

Тесты пишут для уверенности, что логика определённого метода, реализованного в проекте, работает так, как предполагалось. При тестировании конкретного метода обычно требуется проверить несколько сценариев (вариантов поведения приложения в зависимости от разных входных условий). Для каждого такого сценария пишется тестовый метод в тестовом классе. В проектах Maven тестовые классы размещаются в папке *test*.

Тестовый класс относится только к тому методу, логика которого проверяется. Даже простая логика требует нескольких сценариев. В тестовом классе нужно для каждого написать метод, который будет проверять этот сценарий.

Рассмотрим пример. Возьмём сценарий использования «перевод денег», рассмотренный ранее. Это была простая реализация отправки заданной суммы с одного счёта на другой. Данный сценарий использования состоял всего из нескольких операций.
1. Найти в базе данные о счёте отправителя.
2. Найти в базе данные о счёте получателя.
3. Вычислить новые балансы для обоих счетов после перевода.
4. Изменить значения балансов в базе данных.

Даже для этих операций есть несколько сценариев, которые требуют тестирования.
1. Что произойдет, если приложение не найдёт данных о счёте отправителя.
2. Что произойдет, если приложение не найдёт данных о счёте получателя.
3. Что произойдет, если на счету отправителя окажется недостаточно денег.
4. Что произойдет, если не удастся изменить балансы счетов.
5. Что произойдет, если все операции будут успешно выполнены.

Для каждого сценария тестирования нужно понять, как должно вести себя приложение, и написать тестовый метод, позволяющий убедиться, что всё работает соответствующим образом. Например, если в тестовом случае 3 необходимо отменить перевод, когда на счету отправителя недостаточно денег, то при тестировании приложение должно выбрасывать определённое исключение и операция не должна выполняться. Однако в зависимости от требований, предъявляемых к приложению, можно ввести кредитный лимит для счёта отправителя. В таком случае тест должен учитывать также и это.

Реализация тестовых сценариев тесно связана с тем, как должно работать конкретное приложение. Но с технической точки зрения идея всегда одна и та же: нужно определить сценарии и написать тестовый метод для каждого из них.
![spring_16.2](/pictures/spring_16.2.png)

Критически важный момент, на который необходимо обратить внимание, — даже для маленького метода существует несколько возможных тестовых сценариев — и это ещё одна причина, почему методы в приложении должны быть как можно короче! Если писать длинные методы с большим количеством строк кода и многими параметрами — выполняющие сразу несколько действий, — то составить список релевантных сценариев для них становится невероятно сложно. Считается, что если создавать для каждой обязанности отдельный небольшой и лёгкий для чтения метод, тестируемость приложения возрастает.
# Реализация тестов в Spring-приложениях
Данные технологии обязательно должен знать любой разработчик:
- **написание модульных тестов для проверки логики метода**. Модульные тесты короткие, быстро выполняются и касаются только одного процесса. Они позволяют сосредоточиться на проверке маленького фрагмента логики, исключив остальные зависимости;
- **написание интеграционных тестов Spring для проверки логики метода в сочетании со специальными возможностями, предоставляемыми фреймворком**. Эти тесты позволяют убедиться, что функции приложения будут правильно работать при обновлении зависимостей.
## Разработка модульных тестов
**Модульные тесты** — это методы, которые вызывают определённый сценарий использования, чтобы проверить его поведение в специфических условиях. В модульном тестовом методе определяются условия, для которых выполняется сценарий использования, и проверяется, соответствует ли поведение метода требованиям приложения. **В модульных тестах исключаются все зависимости тестируемой функции и рассматривается только данный изолированный фрагмент логики.**

Ценность модульных тестов состоит в том, что если один из них выполняется с ошибкой, то вы знаете, с какой частью кода связана проблема, — тест показывает, где именно нужно внести исправления. Модульные тесты подобны лампочкам на приборной панели автомобиля. Если вы заводите машину, а она не заводится, причиной может быть как отсутствие бензина, так и поломка аккумулятора. Автомобиль — сложная система (как и приложение), и только индикаторы способны подсказать, в чём проблема. Если они показывают, что закончился бензин, вы легко поймёте, что случилось!

**Цель модульных тестов** — проверить поведение отдельной части логики. Подобно индикаторам на приборной панели автомобиля, они помогают идентифицировать проблемы, связанные с определёнными компонентами.
### Создание первого модульного теста
Рассмотрим один из сценариев использования: перевод денег. В этом фрагменте логики выполняются следующие операции.
1. Найти данные о счёте отправителя.
2. Найти данные о счёте получателя.
3. Вычислить новый баланс для каждого счёта.
4. Изменить баланс счёта отправителя.
5. Изменить баланс счёта получателя.

Реализация сценария использования представлена ниже.
```java
@Transactional
public void transferMoney(long idSender, long idReceiver, BigDecimal amount) { 
	Account sender = accountRepository.findById(idSender) 
		.orElseThrow(() -> new AccountNotFoundException()); 
	
	Account receiver = accountRepository.findById(idReceiver) 
		.orElseThrow(() -> new AccountNotFoundException());
	
	BigDecimal senderNewAmount = sender.getAmount().subtract(amount); 
	BigDecimal receiverNewAmount = receiver.getAmount().add(amount); 
	
	accountRepository.changeAmount(idSender, senderNewAmount); 
	accountRepository.changeAmount(idReceiver, receiverNewAmount);
}
```

Как правило, самый очевидный сценарий, для которого пишут первый тест, — это сценарий успешного выполнения, где не возникает исключений или ошибок. Успешное выполнение сценария использования «перевод денег» представлено ниже.
![spring_16.3](/pictures/spring_16.3.png)

Напишем модульный тест для сценария успешного выполнения перевода денег. Любой тест состоит из трёх основных частей.
1. **Предпосылки**. Определить входные данные и найти все зависимости для проверяемой логики, чтобы получить желаемый сценарий выполнения. Какие входные данные следует предоставить и как должны вести себя зависимости тестируемой логики, чтобы она работала так, как мы хотим?
2. **Вызов/выполнение**. Вызвать тестируемую логику и проверить её поведение.
3. **Проверки**. Определить все операции проверки, которые нужно выполнить для данной части логики. Что должно произойти при вызове данной логики для заданных условий?
![spring_16.4](/pictures/spring_16.4.png)

> Иногда эти три этапа (предпосылки, вызов, проверки) называют иначе: **Arrange, Act, and Assert (настроить, выполнить, подтвердить) или Given, When, and Then (дано, если, то)**. Но, как бы их ни называли, концепция написания тестов остаётся прежней.

В предпосылках нужно понять, какие зависимости задействованы в том тестовом случае, для которого мы пишем тест. Здесь выбираются такие входные данные и такое поведение зависимостей, чтобы тестируемая логика вела себя определённым образом.

Какие зависимости нужны для сценария использования «перевод денег»? **Зависимости** — это всё, что используется в методе, но не создаётся непосредственно в нём:
- параметры метода;
- экземпляры объектов, которые используются в методе, но не создаются в нём.

Зависимости для нашего примера показаны ниже.
![spring_16.5](/pictures/spring_16.5.png)

Запуская метод для тестирования, мы можем передать любые значения всех трёх параметров, чтобы управлять процессом выполнения. Но с экземпляром `AccountRepository` ситуация немного сложнее. Выполнение метода `transferMoney()` зависит от поведения метода `findById()`, принадлежащего `AccountRepository`.

Следует учитывать, что модульный тест касается только одного фрагмента логики приложения, поэтому он не должен вызывать метод `findById()`. Модульный тест должен предполагать, что `findById()` работает так, как нужно, и что при выполнении тестируемого метода происходит то, что и должно происходить в данной ситуации.

Однако тестируемый метод вызывает метод `findById()`. Как с этим быть? Чтобы контролировать такие зависимости, используют **заглушки (mocks)** — псевдо-объекты, поведением которых можно управлять. В данном случае мы сделаем так, чтобы вместо настоящего объекта `AccountRepository` в тестируемом методе использовался псевдообъект. Мы воспользуемся возможностью повлиять на поведение этого псевдообъекта, чтобы вызвать все возможные варианты выполнения метода `transferMoney()`, которые хотим протестировать.

Ниже показано, что именно мы собираемся сделать: заменить объект `AccountRepository` на заглушку и таким образом убрать зависимость из тестируемого объекта.
![spring_16.6](/pictures/spring_16.6.png)

Ниже мы начнем разработку модульного теста. Создав новый класс в папке *test* проекта Maven, создадим первый тестовый сценарий, написав новый метод с аннотацией `@Test`.
```java
public class TransferServiceUnitTests { 

	@Test 
	public void moneyTransferHappyFlow() { 
		AccountRepository accountRepository = mock(AccountRepository.class); 
		TransferService transferService = new TransferService(accountRepository); 
	}
}
```

Для вызова тестируемого метода `transferMoney()` мы создадим экземпляр `TransferService`. Вместо настоящего экземпляра `AccountRepository` мы возьмём объект-заглушку, которым сможем управлять. Такие заглушки создаются с помощью метода **`mock()`**. Метод `mock()` становится доступен благодаря зависимости Mockito (часто используемой для создания тестов с помощью JUnit).

Теперь мы можем задать поведение объекта-заглушки, после чего вызвать тестируемый метод и убедиться, что он правильно работает в созданных условиях. Как показано ниже, для управления действиями заглушки используется метод **`given()`**. С помощью `given()` можно определить, как будет вести себя заглушка при вызове одного из её методов. В данном случае нам нужно, чтобы метод `findById()` объекта `AccountRepository` возвращал определённый экземпляр `Account` в зависимости от заданного значения параметра.

> Как вы увидите ниже, в реальных проектах хорошим тоном считается описывать сценарии тестирования с помощью аннотации **`@DisplayName`**. В наших примерах пропущен `@DisplayName`, чтобы сэкономить место и чтобы вы могли сосредоточиться на логике выполнения теста. Но в реальных приложениях использование аннотации `@DisplayName` поможет лучше понять сценарий тестирования — не только вам, но и другим участникам процесса разработки.
```java
public class TransferServiceUnitTests { 

	@Test 
	@DisplayName("Test the amount is transferred " + 
		"from one account to another if no exception occurs.") 
	public void moneyTransferHappyFlow() { 
		AccountRepository accountRepository = mock(AccountRepository.class); 
		TransferService transferService = new TransferService(accountRepository); 
		
		Account sender = new Account(); 
		sender.setId(1); 
		sender.setAmount(new BigDecimal(1000)); 
		
		Account destination = new Account(); 
		destination.setId(2); 
		destination.setAmount(new BigDecimal(1000)); 
		
		given(accountRepository.findById(sender.getId())) 
			.willReturn(Optional.of(sender)); 
		given(accountRepository.findById(destination.getId())) 
			.willReturn(Optional.of(destination)); 
			
		transferService.transferMoney(
			sender.getId(), 
			destination.getId(), 
			new BigDecimal(100)); 
	}
}
```

Последнее, что нам осталось сделать, — сообщить тесту, что должно произойти при выполнении метода. Чего мы ожидаем? Мы знаем, что назначение метода состоит в переводе денег с одного заданного счёта на другой. Таким образом, мы ожидаем, что он вызовет экземпляр репозитория и присвоит балансам соответствующие значения. Ниже добавлены тестовые инструкции, которые проверяют, правильно ли метод вызывает методы экземпляра репозитория, чтобы изменить балансы счетов. Чтобы проверить, вызывается ли метод объекта-заглушки, используется метод `verify()`.
```java
public class TransferServiceUnitTests { 

	@Test 
	@DisplayName("Test the amount is transferred " + 
		"from one account to another if no exception occurs.") 
	public void moneyTransferHappyFlow() { 
		AccountRepository accountRepository = mock(AccountRepository.class); 
		TransferService transferService = new TransferService(accountRepository); 
		
		Account sender = new Account(); 
		sender.setId(1); 
		sender.setAmount(new BigDecimal(1000)); 
		
		Account destination = new Account(); 
		destination.setId(2); 
		destination.setAmount(new BigDecimal(1000)); 
		
		given(accountRepository.findById(sender.getId())) 
			.willReturn(Optional.of(sender)); 
		given(accountRepository.findById(destination.getId())) 
			.willReturn(Optional.of(destination)); 
			
		transferService.transferMoney(
			sender.getId(), 
			destination.getId(), 
			new BigDecimal(100)); 
		
		verify(accountRepository) 
			.changeAmount(1, new BigDecimal(900)); 
		
		verify(accountRepository) 
			.changeAmount(2, new BigDecimal(1100));
	}
}
```

Вам будет часто встречаться такое объявление метода `mock()` внутри тестового метода, как показано ранее. Однако обычно предпочитают другой способ создания объекта-заглушки. Нельзя сказать, чтобы он всегда был лучше или охотнее применялся, но так код будет понятнее, если описывать заглушку и тестируемый объект с помощью аннотаций, как в коде ниже.
```java
@ExtendWith(MockitoExtension.class)
public class TransferServiceWithAnnotationsUnitTests { 

	@Mock 
	private AccountRepository accountRepository; 
	
	@InjectMocks 
	private TransferService transferService; 
	
	@Test 
	public void moneyTransferHappyFlow() { 
		Account sender = new Account(); 
		sender.setId(1); 
		sender.setAmount(new BigDecimal(1000)); 
		
		Account destination = new Account(); 
		destination.setId(2); 
		destination.setAmount(new BigDecimal(1000)); 
		
		given(accountRepository.findById(sender.getId())) 
			.willReturn(Optional.of(sender)); 
		given(accountRepository.findById(destination.getId())) 
			.willReturn(Optional.of(destination)); 
		
		transferService.transferMoney(1, 2, new BigDecimal(100)); 
		
		verify(accountRepository) 
			.changeAmount(1, new BigDecimal(900)); 
		verify(accountRepository) 
			.changeAmount(2, new BigDecimal(1100)); 
	}
}
```

Обратите внимание: вместо того чтобы объявлять эти объекты внутри тестового метода, мы вынесли их за пределы метода и объявили атрибуты класса с аннотациями `@Mock` и `@InjectMocks`. Встретив аннотацию **`@Mock`**, фреймворк создаёт объект-заглушку и внедряет его в атрибут, перед которым стоит аннотация. В случае **`@InjectMocks`** фреймворк создаёт тестируемый объект и внедряет все заглушки (созданные с помощью `@Mock`) в его параметры.

Чтобы `@Mock` и `@InjectMocks` работали, нужно также поставить перед тестовым классом аннотацию **`@ExtendWith(MockitoExtension.class)`**. Таким образом мы активируем расширение, позволяющее фреймворку читать `@Mock` и `@InjectMocks` и управлять полями с этими аннотациями.

Ниже показан результат работы нашего теста. На схеме видно, какие операции мы выполнили и какой код написали для выполнения каждой из них. Сравните их с теми, которые мы перечислили перед началом разработки теста.
1. **Предпосылки** — найти все зависимости и взять на себя управление ими.
2. **Выполнение** — выполнить тестируемый метод.
3. **Проверка** — проверить, соответствует ли поведение выполняемого метода нашим ожиданиям.
![spring_16.7](/pictures/spring_16.7.png)
### Создание тестов для выполнения с исключением
В тестировании нуждается не только вариант успешного выполнения метода. Желательно также убедиться, что метод ведёт себя ожидаемым образом при возникновении исключений. Такой вариант называется **выполнением с исключением**. В нашем примере он может иметь место, если не будет найден счёт отправителя или получателя по заданному ID.
![spring_16.8](/pictures/spring_16.8.png)

Ниже показано, как написать модульный тест для выполнения метода с исключением. Дабы убедиться, что тестируемый метод выбрасывает исключение, используем метод **`assertThrows()`**. Ему нужно сообщить, какой метод вам нужен и какое исключение тот должен выбросить. `assertThrows()` вызывает тестируемый метод и проверяет, реагирует ли он ожидаемым исключением.
```java
@ExtendWith(MockitoExtension.class)
public class TransferServiceWithAnnotationsUnitTests { 

	@Mock 
	private AccountRepository accountRepository; 
	
	@InjectMocks 
	private TransferService transferService; 
	
	@Test 
	public void moneyTransferDestinationAccountNotFoundFlow() { 
		Account sender = new Account(); 
		sender.setId(1); 
		sender.setAmount(new BigDecimal(1000)); 
		
		given(accountRepository.findById(1L)) 
			.willReturn(Optional.of(sender)); 
		given(accountRepository.findById(2L)) 
			.willReturn(Optional.empty());
		 
		assertThrows( 
			AccountNotFoundException.class, 
			() -> transferService.transferMoney(1, 2, new BigDecimal(100)) 
		); 
		
		verify(accountRepository, never()) 
			.changeAmount(anyLong(), any()); 
	}
}
```
### Тестирование значения, возвращаемого методом
Часто бывает так, что нужно проверить, какое значение возвращает метод. Как разработать модульный тест для метода ниже в случае, когда пользователь предоставляет правильные данные для аутентификации?
```java
@PostMapping("/")
public String loginPost(
	@RequestParam String username,
	@RequestParam String password,
	Model model
) {
	loginProcessor.setUsername(username);
	loginProcessor.setPassword(password);
	boolean loggedIn = loginProcessor.login();
	
	if (loggedIn) {
		model.addAttribute("message", "You are now logged in.");
	} else {
		model.addAttribute("message", "Login failed!");
	}
	
	return "login.html";
}
```

Нам нужно выполнить все те же операции, о которых уже говорилось ранее.
1. Найти зависимости и взять на себя управление ими.
2. Вызвать тестируемый метод.
3. Убедиться, что при выполнении поведение тестируемого метода соответствует ожидаемому.

Реализация модульного теста показана ниже. Обратите внимание: мы заменили заглушками те зависимости, чьим поведением хотим управлять или чьё поведение хотим проверить, — объекты `Model` и `LoginProcessor`. Мы сделали так, чтобы заглушка для `LoginProcessor` возвращала `true` (что соответствует ситуации, кода пользователь предоставил правильные данные для аутентификации). Теперь мы вызовем метод, который хотим протестировать.
```java
@ExtendWith(MockitoExtension.class)
class LoginControllerUnitTests { 

	@Mock 
	private Model model; 
	
	@Mock 
	private LoginProcessor loginProcessor; 
	
	@InjectMocks 
	private LoginController loginController;
	
	@Test 
	public void loginPostLoginSucceedsTest() { 
		given(loginProcessor.login()) 
			.willReturn(true); 
		
		String result = loginController.loginPost("username", "password", model); 
		
		assertEquals("login.html", result); 
		
		verify(model) 
			.addAttribute("message", "You are now logged in."); 
	}
}
```

Мы проверим следующее:
- что метод возвращает строку `"login.html"`. Для проверки значения, выдаваемого методом, мы воспользуемся одним из методов семейства `assert` — это будет **`assertEquals()`**. Он сравнивает ожидаемое значение с тем значением, которое даёт тестируемый метод;
- что экземпляр `Model` содержит правильное сообщение — `"You are now logged in"`. С помощью метода `verify()` мы убедимся, что при вызове метода `addAttribute()` экземпляра `Model` этому методу в качестве параметра передаётся правильное значение.

Благодаря тому что мы контролируем входные данные (значения параметров и поведение объектов-заглушек), мы можем протестировать, что произойдет при разных вариантах выполнения метода. Ниже мы сделали так, чтобы метод `login()` объекта-заглушки `LoginProcessor` возвращал `false` — теперь можно посмотреть, что будет при неудачной попытке аутентификации.
```java
@ExtendWith(MockitoExtension.class)
class LoginControllerUnitTests {

	// Остальной код
	
	@Test
	public void loginPostLoginFailsTest() {
		given(loginProcessor.login())
			.willReturn(false);
			
		String result = loginController.loginPost("username", "password", model);
		
		assertEquals("login.html", result);
		
		verify(model)
			.addAttribute("message", "Login failed!");
	}
}
```
## Разработка интеграционных тестов
Интеграционные тесты очень похожи на модульные. Мы будем писать их с помощью уже знакомого вам JUnit. Но вместо того, чтобы сосредоточиться на работе отдельных компонентов, благодаря интеграционным тестам мы будем проверять взаимодействие двух и более компонентов.

Помните аналогию с индикаторами на приборной панели автомобиля? Если бак полон, но что-то сломалось в системе подачи бензина из бака в двигатель, машина не поедет. К сожалению, в этом случае индикатор не укажет на проблему: бензина достаточно и бензобак как изолированный компонент работает нормально. Так что мы не поймём, где истинная причина поломки. То же самое может случиться и в приложении. Компоненты могут работать правильно, будучи изолированными друг от друга, но некорректно «общаться» между собой. **Разработка интеграционных тестов позволяет смягчить проблемы, случающиеся, если сами по себе компоненты работают адекватно, но совершают ошибки при взаимодействии.**

Какой вид взаимодействий мы можем протестировать? Здесь возможны следующие варианты.
- **Взаимодействие между двумя (или более) объектами приложения.** Тестирование правильного взаимодействия объектов помогает обнаружить проблемы коммуникации, возникающие в том случае, если один из этих объектов изменяется.
- **Контакт между объектом приложения и функцией фреймворка, которая расширяет возможности этого объекта.** Проверка взаимодействия объекта с функциями помогает обнаружить проблемы обновления версии фреймворка. Интеграционный тест позволяет немедленно узнать, что во фреймворке что-то изменилось и функция, на основе которой создан данный объект, теперь работает иначе.
- **Интеграция приложения с уровнем хранения данных (базой данных).** Тестирование взаимодействия репозитория с базой данных гарантирует быстрое обнаружение проблем, появляющихся при обновлении или изменении зависимости, которая обеспечивает контакт приложения с сохранёнными данными (такой как JDBC-драйвер).

На первый взгляд интеграционный тест очень похож на модульный. Он состоит из тех же этапов предпосылок, вызова тестируемого метода и проверки результатов. Однако теперь он не ограничивается изолированным фрагментом логики, и мы не обязаны заменять все зависимости заглушками. Мы можем позволить тестируемому методу вызывать метод, принадлежащий другому настоящему объекту (не заглушке), если хотим проверить правильное их взаимодействие. Поэтому, если в модульном тесте необходимо заменять репозиторий заглушкой, то для интеграционного это не является обязательным требованием. Мы всё ещё можем использовать заглушку вместо репозитория, если пишем тест, в котором контакт сервиса с репозиторием не имеет значения. Но если мы хотим протестировать взаимодействие этих двух объектов, необходимо вызывать реальные экземпляры.
![spring_16.9](/pictures/spring_16.9.png)

В Spring-приложениях интеграционные тесты обычно используются для уверенности, что приложение правильно взаимодействует с функциями, предоставляемыми фреймворком. Такие тесты называют **интеграционными тестами Spring**. В отличие от модульных **интеграционные тесты позволяют Spring создавать бины и изменять конфигурацию контекста** (как это обычно происходит при запуске приложения).

Ниже показано, как легко можно преобразовать модульный тест в интеграционный тест Spring. Обратите внимание на аннотацию **`@MockBean`**, с помощью которой создаётся объект-заглушка в нашем приложении Spring Boot. Эта аннотация очень похожа на аннотацию `@Mock`, применяемую в модульных тестах, но она также гарантирует, что **объект-заглушка будет добавлен в контекст приложения**. Таким образом, чтобы внедрить объект, поведение которого мы тестируем, достаточно воспользоваться аннотацией `@Autowired`.
```java
@SpringBootTest
class TransferServiceSpringIntegrationTests { 

	@MockBean 
	private AccountRepository accountRepository; 
	
	@Autowired 
	private TransferService transferService; 
	
	@Test 
	void transferServiceTransferAmountTest() { 
		Account sender = new Account(); 
		sender.setId(1); 
		sender.setAmount(new BigDecimal(1000)); 
		
		Account receiver = new Account(); 
		receiver.setId(2); 
		receiver.setAmount(new BigDecimal(1000)); 
		
		when(accountRepository.findById(1L)) 
			.thenReturn(Optional.of(sender)); 
		when(accountRepository.findById(2L)) 
			.thenReturn(Optional.of(receiver)); 
		
		transferService.transferMoney(1, 2, new BigDecimal(100)); 
		
		verify(accountRepository) 
			.changeAmount(1, new BigDecimal(900)); 
		verify(accountRepository) 
			.changeAmount(2, new BigDecimal(1100)); 
	}
}
```

Данный тест выполняется так же, как и любой другой. Однако теперь Spring «видит» тестируемый объект и управляет им так же, как в рабочем приложении. Например, если после обновления версии фреймворка внедрение зависимости почему-либо перестанет работать, тест не будет пройден, несмотря на то что сам проверяемый объект не изменялся. То же самое касается любой функции Spring, которая используется в тестируемом методе: транзакционности, безопасности, кеширования и т. п. Таким образом можно проверить интеграцию со всеми функциями, нужными методу в приложении.

> На практике модульные тесты применяются для проверки поведения отдельных компонентов, а интеграционные тесты Spring — для необходимых сценариев интеграции. Несмотря на то что такие тесты тоже позволяют изучить реакцию компонента (если выполнить все тестовые сценарии для логики метода), использовать их таким образом — плохая идея. **Интеграционные тесты занимают больше времени, поскольку затрагивают конфигурацию контекста Spring.** Каждый вызов метода активирует несколько механизмов Spring, необходимых для работы фреймворка, — в зависимости от того, какие функции нужны данному методу. Нет смысла тратить время и ресурсы на реализацию каждого сценария тестирования логики приложения. Для экономии времени лучший вариант — проверять логику отдельных компонентов посредством модульных тестов и использовать интеграционные тесты только для уверенности, что метод взаимодействует с фреймворком правильно.
Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 12.

Практически любое современное приложение должно где-то хранить информацию, с которой оно работает, и как-то ею управлять. Для этого обычно используются базы данных. Вот уже много лет реляционные базы данных обеспечивают приложениям простой и изящный способ хранения информации, который успешно применяется во многих сценариях использования. Spring-приложения, как и другие приложения, часто используют базы данных, поэтому вам необходимо научиться применять эти возможности в приложениях, написанных на основе Spring.
# Что такое источник данных
Ниже мы рассмотрим важный элемент, необходимый Spring-приложению для доступа к базе данных: источник данных. **Источник данных** — это компонент, отвечающий за соединение с сервером, обслуживающим базу данных (с системой управления базой данных — СУБД).
![spring_13.1](/pictures/spring_13.1.png)

> **СУБД** — это программное обеспечение, назначение которого — организовать эффективное управление имеющимися данными (добавление, изменение, получение) и сохранение их безопасности. СУБД управляет данными, хранящимися в базе данных. **База данных** — это постоянный набор данных.

Если бы не существовало объекта, отвечающего за источник данных, приложению пришлось бы для каждой операции с данными устанавливать новое подключение к базе. На практике это нереально, поскольку подобный процесс кардинально замедлит приложение и приведёт к проблемам с производительностью. **Источник данных позволяет сделать так, чтобы приложение запрашивало установку нового соединения только тогда, когда это действительно необходимо, что значительно повышает его производительность.**

Работа с любым инструментом, имеющим отношение к хранению данных в реляционной базе, в Spring подразумевает наличие источника данных. Поэтому нам важно сначала выяснить место источника данных на уровне управления данными приложения. Затем мы рассмотрим реализацию уровня хранения данных на примерах.

В приложениях Java функционал языка для соединения с реляционной базой данных называется **Java Database Connectivity (JDBC)**. **JDBC** — это способ установить подключение к СУБД для взаимодействия с базой данных. Но в JDK нет отдельных реализаций для работы с конкретными технологиями (такими как MySQL, Postgres или Oracle). JDK только предоставляет абстракции для объектов, необходимых приложению для соединения с базой. Чтобы получить реализацию этой абстракции и позволить приложению подключаться к конкретной СУБД, необходимо добавить так называемый **JDBC-драйвер** — зависимость реального времени. Каждый производитель даёт свой драйвер, который следует подключить к приложению, чтобы оно могло соединяться с СУБД, построенной по соответствующей технологии. JDBC-драйверы не поставляются в комплекте с JDK или фреймворком, таким как Spring.
![spring_13.2](/pictures/spring_13.2.png)

Для каждой технологии существует свой драйвер, и приложению нужен тот самый, предназначенный для конкретного типа сервера, к которому подключается приложение.

JDBC-драйвер обеспечивает соединение с СУБД. Первый вариант — использовать его непосредственно, так что приложение будет запрашивать соединение с базой данных всякий раз, когда потребуется выполнить новую операцию с хранящимися там сведениями. Подобный метод часто встречается в учебниках по основам Java. Если вам доведётся изучать JDBC по такому учебнику, вы, скорее всего, встретите в примерах класс под названием `DriverManager`, используемый для установки соединения, как показано в следующем фрагменте кода:
```java
Connection con = DriverManager.getConnection(url, username, password);
```

В методе `getConnection()` используется URL, передаваемый в метод как значение первого параметра. Этот URL идентифицирует базу данных, нужную приложению, а также имя и пароль для аутентификации доступа к ней. Но постоянно запрашивать новое соединение и выполнять проверку для каждой операции — бессмысленная трата ресурсов и времени клиента и сервера баз данных. Представьте себе, что вы зашли в бар и заказали пиво. Вы выглядите молодо, поэтому бармен попросил вас показать паспорт. Это нормально. Но если бармен станет спрашивать паспорт, когда вы закажете второй и третий бокал (разумеется, гипотетически), это начнёт раздражать.
![spring_13.3](/pictures/spring_13.3.png)

Объект источника данных эффективно управляет соединениями и сводит к минимуму количество ненужных операций. Вместо того чтобы напрямую использовать менеджер JDBC-драйвера, теперь для установки соединений и управления ими будет использоваться **источник данных**.
![spring_13.4](/pictures/spring_13.4.png)

> **Источник данных** — это объект, обязанность которого состоит в управлении соединениями приложения с сервером баз данных. Источник данных гарантирует успешность подключения и повышает производительность операций на уровне хранения данных.

Для Java-приложений существует множество вариантов реализации источников данных, но в настоящее время чаще всего используется HikariCP (Hikari connection pool — пул соединений Hikari). Он является программным обеспечением с открытым кодом, так что вы тоже можете принять участие в его разработке.
# Взаимодействие с сохранёнными данными с помощью `JdbcTemplate`
Далее мы создадим наше первое Spring-приложение, которое будет использовать базу данных, и рассмотрим преимущества, предоставляемые Spring для создания уровня хранения данных. Благодаря источнику данных наше приложение сможет более эффективно устанавливать соединения с базой. Но как с минимальными усилиями написать код для работы с данными? Мы убедились, что использование классов JDBC из JDK не особенно удобный способ взаимодействия с сохранённой информацией — даже для выполнения простейших операций приходится писать многословные блоки кода.

В примерах из учебников по основам Java вам мог встретиться код наподобие этого:
```java
String sql = "INSERT INTO purchase VALUES (?,?)";
try (PreparedStatement stmt = con.prepareStatement(sql)) {
	stmt.setString(1, name);
	stmt.setDouble(2, price);
	stmt.executeUpdate();
} catch (SQLException e) {
	// сделать что-то в случае исключения
}
```

Так много кода, чтобы всего лишь добавить запись в таблицу! А ведь здесь убрана логика из блока `catch`. Но Spring поможет нам максимально сократить код, который нужно написать для выполнения подобных операций. В Spring-приложениях есть множество альтернативных вариантов для реализации уровня хранения данных. В этом разделе мы будем использовать инструмент, который называется `JdbcTemplate` и который позволяет упростить взаимодействие с базой данных посредством JDBC.

**`JdbcTemplate`** — самый простой из инструментов Spring, предназначенных для работы с реляционными базами данных. Но он отлично подходит для небольших приложений, так как не требует применения специализированных фреймворков для хранения информации. `JdbcTemplate` — лучшее из средств, предлагаемых Spring для реализации уровня хранения данных, если вы не хотите вводить в приложение дополнительные зависимости.

Рассмотрим, как работает `JdbcTemplate`, на примере. Для этого выполним следующие операции.
1. Установим соединение с СУБД.
2. Напишем логику для хранилища данных.
3. Вызовем методы хранилища из методов, реализующих действия для конечных точек REST.

Для этого приложения мы создадим в базе данных таблицу `purchase`. В ней хранятся сведения о товарах, приобретённых в онлайн-магазине, а также о стоимости покупок. Таблица состоит из следующих столбцов:
- `id` — автоматически увеличивающееся уникальное значение, играющее роль первичного ключа таблицы;
- `product` — наименование купленного товара;
- `price` — стоимость покупки.
![spring_13.5](/pictures/spring_13.5.png)

Примеры, которые мы рассматриваем, не зависят от конкретной технологии реляционных баз данных — вы можете использовать данный код для любой из них. Но для выполнения примеров нужно выбрать какую-то определенную. Нам понадобятся H2 (база данных, хранящаяся в оперативной памяти: отлично подходит для примеров) и MySQL (бесплатная и нетребовательная к ресурсам СУБД, легко устанавливается на локальных компьютерах и позволяет убедиться, что примеры работают не только для баз данных в оперативной памяти). Вы можете использовать любую другую технологию по вашему выбору: Postgres, Oracle или MS SQL. В таком случае при выполнении приложения необходимо будет использовать соответствующий JDBC-драйвер (как уже говорилось ранее и как вы знаете из основ Java). Кроме того, синтаксис SQL-запросов может различаться для разных технологий реляционных баз данных. Если вы выберете другую технологию, вам понадобится адаптировать SQL-запросы к ней.

> Для базы данных H2 тоже нужен JDBC-драйвер. Но для нее этот драйвер не приходится добавлять специально, он поставляется в комплекте с зависимостью, которую мы добавим в файл *pom.xml*.

Требования к создаваемому нами приложению очень просты. Мы разработаем сервис бэкенда, у которого есть две конечные точки. Клиенты будут вызывать одну из них, чтобы добавить в таблицу покупок новую запись, и вторую, чтобы получить все записи из таблицы.

Работая с базой данных, мы представим все возможности уровня хранения данных в виде классов, которые (по соглашению) называются **репозиториями**. **Репозиторий** — это класс, отвечающий за взаимодействие с базой данных. Структура классов создаваемого нами приложения показана ниже.
![spring_13.6](/pictures/spring_13.6.png)

Как обычно, начнём с того, что добавим все необходимые зависимости. В следующем фрагменте кода показано, какие зависимости нужно внести в файл *pom.xml*:
```xml
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency> 
	<groupId>com.h2database</groupId> 
	<artifactId>h2</artifactId>
	<scope>runtime</scope> 
</dependency>
```

Зависимость H2 эмулирует базу данных на тот случай, если у вас нет сервера баз данных для выполнения примера. H2 — отличный инструмент, который можно использовать как в примерах, так и при тестировании приложений, когда необходимо проверить функционал продукта, исключив при этом его зависимость от базы данных.

Нам нужно сформировать таблицу, в которой будут храниться записи о покупках. В теоретических примерах структура базы данных создаётся легко — достаточно добавить файл *schema.sql* в папку ресурсов проекта Maven.

В этот файл мы запишем все структурообразующие SQL-запросы, то есть запросы, определяющие структуру базы данных. Некоторые разработчики называют их языком описания данных (**data description language, DDL**). Такой файл будет и у нас в проекте. Добавим туда следующий запрос для создания таблицы покупок:
```sql
CREATE TABLE IF NOT EXISTS purchase (
	id INT AUTO_INCREMENT PRIMARY KEY,
	product varchar(50) NOT NULL,
	price double NOT NULL
);
```

> Описание структуры базы данных в файле *schema.sql* подходит только для теоретических примеров. Этот простой и быстрый способ помогает сосредоточиться на предмете, которому посвящён учебник, и не отвлекаться на определение структуры базы данных. Но на практике вам понадобится использовать зависимость, позволяющую управлять версиями скриптов для взаимодействия с базой данных. Лучше обратить внимание на две такие очень популярные зависимости — [Flyway](https://flywaydb.org/) и [Liquibase](https://www.liquibase.org/).

Чтобы описать данные о покупке в приложении, нужно создать класс модели. Экземпляры этого класса соответствуют строкам таблицы покупок в базе данных. Поэтому у каждого из них должны быть атрибуты, где записан ID, наименование товара и цена. В следующем фрагменте кода представлен класс модели `Purchase`:
```java
public class Purchase {

	private int id;
	private String product;
	private BigDecimal price;
	// Геттеры и сеттеры
}
```

Возможно, вас заинтересовал тот факт, что атрибут `price` класса `Purchase` имеет тип `BigDecimal`. Почему мы не объявили его как `double`? Здесь есть один важный момент: в теоретических примерах для представления дробных значений часто используют тип `double`, однако на практике применение `double` или `float` для дробных чисел не лучшая идея. Работая со значениями типа `double` и `float`, можно потерять точность даже при выполнении простых арифметических операций, таких как сложение и вычитание. Всё дело в том, в какой форме Java хранит эти значения в памяти. При работе с такой важной информацией, как цены, требуется `BigDecimal`. В Spring есть все функции, необходимые для его использования, поэтому не беспокойтесь о преобразовании типов.

Чтобы легко получить в контроллере экземпляр `PurchaseRepository`, мы сделаем данный объект бином в контексте Spring. Для этого проще всего использовать стереотипную аннотацию (такую как `@Component` или `@Service`).

Но в нашем случае вместо `@Component` мы воспользуемся специальной стереотипной аннотацией Spring для репозиториев — **`@Repository`**. Определение класса репозитория представлено ниже.
```java
@Repository
public class PurchaseRepository {
}
```

После того как бин `PurchaseRepository` добавлен в контекст приложения, можно внедрить экземпляр `JdbcTemplate`, который мы будем использовать для взаимодействия с базой данных. Я знаю, о чем вы сейчас подумали! «Откуда мы возьмем `JdbcTemplate`? Кто создал этот экземпляр, чтобы мы сейчас могли внедрить его в репозиторий?» В данном примере, как и во многих реальных приложениях, мы снова прибегнем к магии Spring Boot. Когда мы добавили в файл *pom.xml* зависимость H2, Spring Boot автоматически настроил источник данных и создал экземпляр `JdbcTemplate`. В данном примере мы будем использовать непосредственно и то и другое.

При применении Spring без Spring Boot необходимы бины типа `DataSource` и `JdbcTemplate`. Ниже показано, как внедрить экземпляр `JdbcTemplate`, созданный Spring Boot для нашего приложения.
```java
@Repository
public class PurchaseRepository { 

	private final JdbcTemplate jdbc; 
	
	public PurchaseRepository(JdbcTemplate jdbc) { 
		this.jdbc = jdbc; 
	}
}
```

Итак, у нас есть экземпляр `JdbcTemplate`; теперь можно создать приложение в соответствии с заданными требованиями. У `JdbcTemplate` есть метод **`update()`**, позволяющий выполнять запросы по изменению данных — `INSERT`, `UPDATE` и `DELETE`. Чтобы выполнить такой запрос, достаточно передать в метод код и параметры SQL-запроса, остальное `JdbcTemplate` сделает сам (установит соединение, создаст SQL-оператор, обработает `SQLException` и т. д.). Ниже показано, как добавить метод `storePurchase()` в класс `PurchaseRepository`. В `storePurchase()` мы с помощью `JdbcTemplate` создаём новую запись в таблице покупок.
```java
@Repository
public class PurchaseRepository { 

	private final JdbcTemplate jdbc; 
	
	public PurchaseRepository(JdbcTemplate jdbc) { 
		this.jdbc = jdbc; 
	} 
	
	public void storePurchase(Purchase purchase) { 
		String sql = "INSERT INTO purchase VALUES (NULL, ?, ?)"; 
		jdbc.update(sql, purchase.getProduct(), purchase.getPrice()); 
	}
}
```

Написав всего пару строк кода, мы теперь можем вставлять, изменять и удалять записи в таблицах. Но с получением данных ситуация сложнее. Как и при создании записи, для этого нужно написать и отправить на сервер запрос — в нашем случае это соответственно `SELECT`. Но потом, чтобы сообщить `JdbcTemplate`, как преобразовать данные в объекты `Purchase` (наш класс модели), необходим **`RowMapper`** — объект, выполняющий преобразование строки из `ResultSet` в заданный объект. Например, чтобы получить данные из базы и представить их в виде модели `Purchase`, необходимо создать `RowMapper` и описать в нём способ преобразования строки таблицы в экземпляр `Purchase`.
![spring_13.7](/pictures/spring_13.7.png)

Ниже показано, как реализовать модель репозитория, чтобы извлечь все записи из таблицы покупок.
```java
@Repository
public class PurchaseRepository { 

	// Остальной код 
	
	public List<Purchase> findAllPurchases() { 
		String sql = "SELECT * FROM purchase"; 
		
		RowMapper<Purchase> purchaseRowMapper = (r, i) -> { 
			Purchase rowObject = new Purchase(); 
			rowObject.setId(r.getInt("id")); 
			rowObject.setProduct(r.getString("product")); 
			rowObject.setPrice(r.getBigDecimal("price")); 
			return rowObject; 
		}; 
		
		return jdbc.query(sql, purchaseRowMapper); 
	}
}
```

Теперь, когда мы написали методы репозитория и знаем, как сохранять записи в базе данных и получать их оттуда, можно открыть доступ к этим методам через конечные точки. Реализация контроллера представлена ниже.
```java
@RestController
@RequestMapping("/purchase")
public class PurchaseController { 

	private final PurchaseRepository purchaseRepository; 
	
	public PurchaseController(PurchaseRepository purchaseRepository) { 
		this.purchaseRepository = purchaseRepository; 
	} 
	
	@PostMapping 
	public void storePurchase(@RequestBody Purchase purchase) { 
		purchaseRepository.storePurchase(purchase); 
	} 
	
	@GetMapping 
	public List<Purchase> findPurchases() { 
		return purchaseRepository.findAllPurchases(); 
	}
}
```

Запустив приложение, можно протестировать эти две конечные точки через Postman или cURL.

Чтобы добавить запись в таблицу покупок, используйте путь `/purchase` и HTTP-метод POST следующим образом:
```
curl -XPOST 'http://localhost:8080/purchase' \
-H 'Content-Type: application/json' \
-d '{
	"product" : "Spring Security in Action",
	"price" : 25.2
}'
```

Затем, вызвав конечную точку `/purchase` с HTTP-методом GET, можно убедиться, что приложение правильно сохранило запись о покупке. Вот команда cURL для этого запроса:
```
curl 'http://localhost:8080/purchase'
```

Тело HTTP-ответа на этот запрос представляет собой список всех записей о покупках, хранящихся в базе данных:
```json
[
	{
		"id": 1,
		"product": "Spring Security in Action",
		"price": 25.2
	}
]
```
# Изменение конфигурации источника данных
Теперь давайте научимся изменять источник данных, используемый `JdbcTemplate` для взаимодействия с базой данных. База данных H2 отлично подходит для примеров и учебных пособий, а также на начальных стадиях создания уровня хранения данных в приложении. Но в реальных продуктах вам понадобится нечто большее, чем база в оперативной памяти. Кроме того, вам часто придётся вносить изменения в источник данных.

Чтобы показать, как используются СУБД в реальных условиях, мы модифицируем пример, созданный ранее, таким образом, чтобы задействовать MySQL-сервер. Как вы заметите, логику это не затронет — потребуется изменить лишь источник данных, который будет ссылаться на другую базу данных, и это нетрудно сделать. Нужно выполнить следующие операции.
1. Мы добавим JDBC-драйвер MySQL и изменим конфигурацию источника данных с помощью файла *application.properties* таким образом, чтобы источник ссылался на базу данных MySQL. Мы по-прежнему будем полагаться на Spring Boot, который автоматически поместит бин DataSource в контекст Spring в соответствии с заданными нами свойствами.
2. Мы внесем изменения в проект, определив собственный бин `DataSource`, и подумаем, в каких случаях это может пригодиться на практике.
## Определение источника данных в файле свойств приложения
Для начала подключим приложение к СУБД MySQL. В реальных приложениях используются внешние серверы баз данных, так что этот навык вам ещё пригодится.

Если вы захотите выполнить пример самостоятельно, вам понадобится установить сервер MySQL и создать базу данных, к которой вы будете подключаться. Вы также можете при желании адаптировать этот пример для другой технологии (такой как Postgres или Oracle).

Для внесения изменений нам нужно выполнить следующее.
1. Изменить зависимости проекта, убрав оттуда H2 и добавив соответствующий JDBC-драйвер.
2. Добавить в файл *application.properties* свойства для соединения с новой базой данных.

Чтобы выполнить пункт 1, откройте файл *pom.xml* и удалите оттуда зависимость H2. Если вы намерены использовать MySQL, нужно добавить JDBC-драйвер MySQL. Сейчас в проекте понадобятся следующие зависимости:
```xml
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency> 
	<groupId>mysql</groupId> 
	<artifactId>mysql-connector-java</artifactId> 
	<scope>runtime</scope>
</dependency>
```

Для выполнения пункта 2 нужно привести файл *application.properties* в соответствие со следующим фрагментом кода. Добавим в этот файл свойство `spring.datasource.url`, чтобы указать местонахождение базы данных, а также свойства `spring.datasource.username` и `spring.datasource.password`, соответствующие параметрам доступа приложения для аутентификации и установки соединения с СУБД. Нам понадобится свойство `spring.datasource.initialization-mode` со значением `always`, чтобы Spring Boot использовал файл *schema.sql* для создания таблицы покупок. Для H2 нам это свойство не было нужно, так как в случае H2 Spring Boot по умолчанию выполняет запросы из *schema.sql*, если этот файл существует:
```
spring.datasource.url=jdbc:mysql://localhost/spring_quickly?useLegacyDatetimeCode=false&serverTimezone=UTC

spring.datasource.username=<dbms username>
spring.datasource.password=<dbms password>
spring.datasource.initialization-mode=always
```

> Хранить в файле свойств секретные данные, например пароли, — не лучшая идея для реальных приложений. Подобная конфиденциальная информация должна содержаться в закрытых хранилищах.

После этих небольших изменений приложение использует базу данных MySQL. На основании свойств `spring.datasource`, предоставленных в *application.properties*, Spring Boot сможет создавать бин `DataSource`. Можно запустить приложение и проверить работу конечных точек.

Чтобы добавить новую запись в таблицу покупок, вызовите путь `/purchase` с HTTP-методом POST:
```
curl -XPOST 'http://localhost:8080/purchase' \
-H 'Content-Type: application/json' \
-d '{
	"product" : "Spring Security in Action",
	"price" : 25.2
}'
```

Затем можно вызвать конечную точку с путём `/purchase` и HTTP-методом GET, дабы убедиться, что приложение правильно сохранило запись о покупке. Команда cURL для этого запроса выглядит так:
```
curl 'http://localhost:8080/purchase'
```

Тело HTTP-ответа представляет собой список всех записей о покупках, сохранённых в базе данных:
```json
[
	{
		"id": 1,
		"product": "Spring Security in Action",
		"price": 25.2
	}
]
```
## Использование нестандартного бина `DataSource`
Чтобы Spring Boot смог использовать бин `DataSource`, нужно предоставить информацию о соединении в файле *application.properties*. Иногда этого достаточно. Но вы не всегда сможете рассчитывать на то, что Spring Boot создаст `DataSource` автоматически. Следовательно, придётся сделать это самостоятельно. Вот ситуации, в которых может потребоваться создать бин `DataSource` вручную:
- необходима специфическая реализация `DataSource`, в зависимости от условий, возникающих в процессе выполнения приложения;
- приложение подключается к нескольким базам данных, так что нужно создать несколько источников данных и различать их посредством префиксов;
- необходимо определить специфические параметры объекта `DataSource` в некоторых случаях в процессе выполнения приложения — например, в зависимости от среды, из которой запускается приложение, пул соединений для оптимизации производительности может содержать больше или меньше подключений к базе данных;
- приложение использует фреймворк Spring без Spring Boot.

Ничего страшного здесь нет! `DataSource` — обычный бин, который добавляется в контекст Spring так же, как и любой другой. Вместо того чтобы предоставить Spring Boot автоматически создать и настроить конфигурацию объекта `DataSource`, вы можете определить в классе конфигурации метод с аннотацией `@Bean` и самостоятельно добавить объект в контекст. Тогда вы сможете полностью контролировать процесс его создания.

Модифицируем проект таким образом, чтобы бин источника данных не создавался автоматически посредством Spring Boot, а был определён вами. Мы создадим файл конфигурации и определим в нём метод с аннотацией `@Bean`. Этот метод будет возвращать экземпляр `DataSource`, который мы добавим в контекст Spring. Класс конфигурации и определение метода с аннотацией `@Bean` показаны в следующем листинге.
```java
@Configuration
public class ProjectConfig { 

	@Value("${custom.datasource.url}") 
	private String datasourceUrl; 
	
	@Value("${custom.datasource.username}") 
	private String datasourceUsername; 
	
	@Value("${custom.datasource.password}") 
	private String datasourcePassword; 
	
	@Bean public DataSource dataSource() { 
		HikariDataSource dataSource = new HikariDataSource();
		 
		dataSource.setJdbcUrl(datasourceUrl); 
		dataSource.setUsername(datasourceUsername); 
		dataSource.setPassword(datasourcePassword); 
		dataSource.setConnectionTimeout(1000); 
		
		return dataSource; 
	}
}
```

Не забудьте определить значения свойств, которые вы внедряете, с помощью аннотации `@Value`. В файле *application.properties* эти свойства должны выглядеть так, как показано в следующем фрагменте. Слово `custom` намеренно используется в их именах, чтобы подчеркнуть, что свойства не определяет Spring Boot и что мы сами выбираем имена. Вы можете присвоить любые:
```
custom.datasource.url=jdbc:mysql://localhost/spring_quickly?useLegacyDatetimeCode=false&serverTimezone=UTC

custom.datasource.username=root
custom.datasource.password=password
```

Теперь можно запустить проект и проверить его работу. Результаты должны быть такими же, как и для двух предыдущих проектов.

Чтобы добавить новую запись в таблицу покупок, вызываем путь `/purchase` с HTTP-методом POST:
```
curl -XPOST 'http://localhost:8080/purchase' \
-H 'Content-Type: application/json' \
-d '{
	"product" : "Spring Security in Action",
	"price" : 25.2
}'
```

Затем можно вызвать конечную точку `/purchase` с HTTP-методом GET, дабы убедиться, что приложение правильно сохранило запись о покупке. Команда cURL для этого запроса выглядит так:
```
curl 'http://localhost:8080/purchase'
```

Тело HTTP-ответа на запрос представляет собой список всех записей о покупках, хранящихся в базе данных:
```json
[
	{
		"id": 1,
		"product": "Spring Security in Action",
		"price": 25.2
	}
]
```
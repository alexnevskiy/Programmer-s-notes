Взято с JavaRush ([1](https://javarush.com/groups/posts/isklyucheniya-java)), ([2](https://javarush.com/groups/posts/1944-iskljuchenija-checked-unchecked-i-svoi-sobstvennihe)) и [ProgLang](https://proglang.su/java/exceptions).
# Контролируемые исключения (Checked exceptions)
**Контролируемое исключение** представляет собой вид исключения, которое происходит на стадии компиляции, их также именуют **исключениями периода компиляции**. Обозначенные исключения не следует игнорировать в ходе компиляции, они требуют должного обращения (разрешения) со стороны программиста.

К примеру, если вы используете класс `FileReader` в вашей программе для считывания данных из файла, в случае, если указанный в конструкторе файл не существует, происходит `FileNotFoundException`, и компилятор подсказывает программисту обработку данного исключения.
```java
import java.io.File;
import java.io.FileReader;

public class Test {

	public static void main(String args[]) {		
		File f = new File("D://java/file.txt");
		FileReader fr = new FileReader(f); 
	}
}
```

При попытке компиляции обозначенной выше программы будут выведены следующие исключения:
```
C:\>javac Test.java
Test.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown
      FileReader fr = new FileReader(f);
                      ^
1 error
```

**Примечание**. В виду того, что методы `read()` и `close()` класса `FileReader` вызывают `IOException`, компилятор может уведомить вас об обработке `IOException`, совместно с `FileNotFoundException`.
# Неконтролируемые исключения (Unchecked exceptions)
**Неконтролируемое исключение** представляет собой исключение, которое происходит во время выполнения. Они также носят название **исключения на этапе выполнения**. Данная категория может включать погрешности программирования, такие как логические ошибки либо неверный способ использования API. Исключения на этапе выполнения игнорируются в ходе компиляции.

К примеру, если вами в вашей программе был объявлен массив из 5 элементов, попытка вызова 6-го элемента массива повлечёт за собой возникновение `ArrayIndexOutOfBoundsExceptionexception`.
```java
public class Test {
   
	public static void main(String args[]) {
		int array[] = {1, 2, 3};
		System.out.println(array[4]);
	}
}
```

При компиляции и выполнении обозначенной выше программы будет получено следующее исключение:
```
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
	at Exceptions.Test.main(Test.java:8)
```
# Ошибки (Error)
**Ошибки** – не являются исключениями, однако представляют проблемы, которые возникают независимо от пользователя либо программиста. Ошибки в вашем коде обычно игнорируются в виду того, что в редких случаях их обработка окажется результативной. К примеру, ошибка возникнет при переполнении стека. На этапе компиляции они также игнорируются.
# Иерархия исключений
Все классы исключений в Java представляют подтипы класса `java.lang.Exception`. Класс исключений является подклассом класса `Throwable`. Помимо класса исключений существует также подкласс ошибок, образовавшихся из класса `Throwable`.
![exceptions](pictures/exceptions.webp)

Ошибки представляют аварийное состояние вследствие значительных сбоев, которые не обрабатываются программами Java. Генерирование ошибок предназначено для отображения ошибок, выявленных средой выполнения. Примеры: JVM исчерпал имеющийся объём памяти. Обычно, программы не могут восстановить неполадки, вызванные ошибками.

Класс исключений делится на два основных подкласса: класс `IOException` и класс `RuntimeException`.

По ссылке представлен перечень наиболее распространённых контролируемых (checked) и неконтролируемых (unchecked) [встроенных исключений](https://proglang.su/java/exceptions-built-in-exceptions "Встроенные исключения в Java") в Java.
# Методы исключений
| №   | Метод и описание                                                                                                                                                                                                                             |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | `public String getMessage() ` <br>Возврат подробного сообщения о произошедшем исключении. Инициализация данного сообщения производится в конструкторе `Throwable`.                                                                           |
| 2   | `public Throwable getCause()`  <br>Возврат причины исключения, представленной объектом `Throwable`.                                                                                                                                          |
| 3   | `public String toString()`  <br>Возврат имени класса, соединенного с результатом `getMessage()`.                                                                                                                                             |
| 4   | `public void printStackTrace()`  <br>Выведение результата `toString()` совместно с трассировкой стека в `System.err`, поток вывода ошибок.                                                                                                   |
| 5   | `public StackTraceElement [] getStackTrace()`  <br>Возврат массива, содержащего каждый элемент в трассировке стека. Элемент с номером 0 представляет вершину стека вызовов, последний элемент массива отображает метод на дне стека вызовов. |
| 6   | `public Throwable fillInStackTrace()`  <br>Заполняет трассировку стека данного объекта `Throwable` текущей трассировкой стека, дополняя какую-либо предшествующую информацию в трассировке стека.                                            |
# Обработка исключений
Метод производит обработку исключения при использовании ключевых слов `try` и `catch`.

**Блок `try`/`catch` размещается в начале и конце кода, который может сгенерировать исключение**. Код в составе блока `try`/`catch` является защищённым кодом, синтаксис использования `try`/`catch` выглядит следующим образом:
```java
try {
	// Защищённый код
} catch (НазваниеИсключения e1) {
	// Блок catch
}
```

**Код, предрасположенный к исключениям, размещается в блоке `try`.** **В случае возникновения исключения, обработка данного исключения будет производиться соответствующим блоком `catch`.** За каждым блоком `try` должен немедленно следовать блок `catch` либо блок `finally`.

Оператор `catch` включает объявление типа исключения, которое предстоит обработать. При возникновении исключения в защищённом коде, блок `catch` (либо блоки), следующий за `try`, будет проверен. В случае, если тип произошедшего исключения представлен в блоке `catch`, исключение передается в блок `catch` аналогично тому, как аргумент передаётся в параметр метода.

Ниже представлен массив с заявленными двумя элементами. Попытка кода получить доступ к третьему элементу массива повлечёт за собой генерацию исключения.
```java
import java.io.*;

public class Test {

	public static void main(String args[]) {
	    try {
			int array[] = new int[2];
	        System.out.println("Доступ к третьему элементу:" + array[3]);
		} catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("Исключение:" + e);
	    }
	    System.out.println("Вне блока");
	}
}
```

Вследствие этого будет получен следующий результат:
```
Исключение:java.lang.ArrayIndexOutOfBoundsException: 3
Вне блока
```
## Многократные блоки `catch`
**За блоком `try` могут следовать несколько блоков `catch`**. Синтаксис многократных блоков catch выглядит следующим образом:
```java
try {
	// Защищённый код
} catch(ИсключениеТип1 e1) {
	// Блок catch
} catch(ИсключениеТип2 e2) {
	// Блок catch
} catch(ИсключениеТип3 e3) {
	// Блок catch
}
```

Представленные выше операторы демонстрируют три блока `catch`, однако, после однократного `try` количество данных используемых блоков может быть произвольным. В случае возникновения исключения в защищённом коде, исключение выводится в первый блок `catch` в списке. Если тип данных генерируемого исключения совпадает с `ИсключениеТип1`, он перехватывается в указанной области. В обратном случае, исключение переходит ко второму оператору `catch`. Это продолжается до тех пор, пока не будет произведён перехват исключения, либо оно не пройдёт через все операторы, в случае чего выполнение текущего метода будет прекращено, и исключение будет перенесено к предшествующему методу в стеке вызовов.

Далее представлен сегмент кода, демонстрирующий использование многократных операторов `try`/`catch`.
```java
try {
	file = new FileInputStream(fileName);
	x = (byte) file.read();
} catch(IOException e1) {
	e1.printStackTrace();
	return -1;
} catch(FileNotFoundException e2) { // Недействительно!
	e2.printStackTrace();
	return -1;
}
```
## Перехват многотипных исключений
В среде Java 7, **можно произвести обработку более чем одного исключения при использовании одного блока `catch`**, данное свойство упрощает код. Ниже представлена модель реализации:
```java
catch (IOException | FileNotFoundException ex) {
	logger.log(ex);
	throw ex;
}
```
## Ключевые слова `throws`/`throw`
В случае **если метод не может осуществить обработку контролируемого исключения, производится соответствующее уведомление при использовании ключевого слова `throws`** в Java. Ключевое слово `throws` появляется в конце сигнатуры метода.

При использовании ключевого слова `throw` вы можете **произвести обработку вновь выявленного исключения либо исключения, которое было только что перехвачено**.

Следует внимательно различать ключевые слова `throw` и `throws` в Java, так как `throws` используется для отложенной обработки контролируемого исключения, а `throw`, в свою очередь, используется для вызова заданного исключения.

Представленный ниже метод отображает, что им генерируется `RemoteException`:
```java
import java.rmi.RemoteException;
public class Test {

	public void deposit(double amount) throws RemoteException {
		// Реализация метода
		throw new RemoteException();
	}
	// Остаток определения класса
}
```

**Метод также может объявить о том, что им генерируется более чем одно исключение**, в случае чего исключения представляются в виде перечня, отделённые друг от друга запятыми. К примеру, следующий метод оповещает о том, что им генерируются `RemoteException` и `InsufficientFundsException`:
```java
import java.rmi.RemoteException;
public class Test {

	public void withdraw(double amount) throws RemoteException,
		InsufficientFundsException {
		// Реализация метода
	}
	// Остаток определения класса
}
```
## Блок `finally`
В Java `finally` следует за блоком `try` либо блоком `catch`. **Блок `finally` в коде выполняется всегда независимо от наличия исключения**.

Использование блока `finally` позволяет запустить какой-либо оператор, предназначенный для очистки, не зависимо от того, что происходит в защищённом коде.

Блок `finally` в Java появляется по окончании блоков `catch`, его синтаксис выглядит следующим образом:
```java
try {
	// Защищенный код
} catch(ИсключениеТип1 e1) {
	// Блок catch
} catch(ИсключениеТип2 e2) {
	// Блок catch
} catch(ИсключениеТип3 e3) {
	// Блок catch
} finally {
	// Блок finally всегда выполняется.
}
```

Пример:
```java
public class Test {

	public static void main(String args[]) {
		int array[] = new int[2];
		try {
			System.out.println("Доступ к третьему элементу:" + array[3]);
		} catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("Исключение:" + e);
		} finally {
			array[0] = 6;
			System.out.println("Значение первого элемента: " + array[0]);
			System.out.println("Оператор finally выполнен.");
		}
	}
}
```

Вследствие этого будет получен следующий результат:
```
Исключение:java.lang.ArrayIndexOutOfBoundsException: 3
Значение первого элемента: 6
Оператор finally выполнен.
```
Следует помнить, что:
- Выражение `catch` не может существовать без оператора `try`.
- При наличии блока `try`/`catch`, выражение `finally` не является обязательным.
- Блок `try` не может существовать при отсутствии выражения `catch` либо выражения `finally`.
- Существование какого-либо кода в промежутке между блоками `try`, `catch`, `finally` является невозможным.
## Конструкция try-with-resources
В норме, при использовании различных видов ресурсов, таких как потоки, соединения и др., нам предстоит закрыть их непосредственно при использовании блока `finally`. В программе, представленной ниже, нами производится считывание данных из файла при использовании `FileReader`, после чего он закрывается блоком `finally`.
```java
import java.io.FileReader;
import java.io.File;
import java.io.IOException;

public class Test {

	public static void main(String args[]) {
		FileReader fr = null;		
		try {
			File f = new File("file.txt");
			fr = new FileReader(f); 
			char[] array = new char[10];
			fr.read(array); // чтение содержимого массива
			for (char c : array) {
				System.out.print(c); // вывод символов на экран, один за одним
			}
		} catch(IOException e1) {
			e1.printStackTrace();
		} finally {
			try {
				fr.close();
			} catch(IOException e2) {		
				e2.printStackTrace();
			}
		}
	}
}
```

Конструкция try-with-resources, также именуемая как **автоматическое управление ресурсами**, представляет новый механизм обработки исключений, который был представлен в 7-ой версии Java, осуществляя автоматическое закрытие всех ресурсов, используемых в рамках блока `try`/`catch`.

Чтобы воспользоваться данным оператором, вам всего лишь нужно разместить заданные ресурсы в круглых скобках, после чего **созданный ресурс будет автоматически закрыт по окончании блока**. Ниже представлен синтаксис конструкции try-with-resources.
```java
try(FileReader fr = new FileReader("Путь к файлу")) {
	// использование ресурса
} catch() {
	// тело catch 
}
```

Программа ниже производит считывание данных в файле, используя конструкцию try-with-resources.
```java
import java.io.FileReader;
import java.io.IOException;

public class Test {

	public static void main(String args[]) {
		try(FileReader fr = new FileReader("test/file.txt")) {
			char[] array = new char[10];
			fr.read(array); // чтение содержимого массива
			for (char c : array) {
				System.out.print(c); // вывод символов на экран, один за одним
			}
		} catch(IOException e) {
			e.printStackTrace();
		}
	}
}
```

При работе с конструкцией try-with-resources следует принимать во внимание следующие нюансы:
- С целью использования конструкции try-with-resources следует реализовать интерфейс `AutoCloseable`, после чего соответствующий метод `close()` будет вызван автоматически во время выполнения.
- В конструкции try-with-resources возможно указание одного и более классов.
- При указании нескольких классов в блоке `try` конструкции try-with-resources, закрытие данных классов будет производиться в обратном порядке.
- За исключением внесения ресурсов в скобки, все элементы являются равными аналогично нормальному блоку `try`/`catch` в составе блока `try`.
- Ресурсы, внесённые в `try`, конкретизируются до запуска блока `try`.
- Ресурсы непосредственно в составе блока `try` указываются как окончательные.
# Создание собственных исключений
Вы можете создать свои собственные исключения в среде Java. При записи собственных классов исключений следует принимать во внимание следующие аспекты:
- Все исключения должны быть дочерними элементами `Throwable`.
- Если вы планируете произвести запись контролируемого исключения с автоматическим использованием за счёт правила обработки или объявления, вам следует расширить класс `Exception`.
- Если вы хотите произвести запись исключения на этапе выполнения, вам следует расширить класс `RuntimeException`.

Вы можете определить собственный класс исключений, как показано ниже:
```java
class MyException extends Exception {
}
```

Вам лишь необходимо расширить предопределённый класс `Exception` с целью создания собственного исключения. Данная категория относится к контролируемым исключениям. Следующий класс `InsufficientFundsException` исключительных ситуаций, определяемых пользователем, расширяет класс `Exception`, делая его контролируемым исключением. Класс исключений, подобно всем остальным классам, содержит используемые области и методы.
```java
// Название файла InsufficientFundsException.java
import java.io.*;

public class InsufficientFundsException extends Exception {
	
	private double amount;
	
	public InsufficientFundsException(double amount) {
		this.amount = amount;
	}
	
	public double getAmount() {
		return amount;
	}
}
```

С целью демонстрации наших исключений, определяемых пользователем, следующий класс `Checking` содержит метод `withdraw()`, генерирующий `InsufficientFundsException`.
```java
// Название файла Checking.java
import java.io.*;

public class Checking {

	private int number;
	private double balance;
	
	public Checking(int number) {
		this.number = number;
	}
	
	public void deposit(double amount) {
		balance += amount;
	}
	
	public void withdraw(double amount) throws InsufficientFundsException {
		if (amount <= balance) {
			balance -= amount;
		} else {
			double needs = amount - balance;
			throw new InsufficientFundsException(needs);
		}
	}
	
	public double getBalance() {
		return balance;
	}
	
	public int getNumber() {
		return number;
	}
}
```

Следующая программа `Bank` демонстрирует вызов методов `deposit()` и `withdraw()` класса `Checking`.
```java
// Название файла Bank.java
public class Bank {

	public static void main(String [] args) {
		Checking c = new Checking(101);
		System.out.println("Депозит $300...");
		c.deposit(300.00);
		
		try {
			System.out.println("\nСнятие $100...");
			c.withdraw(100.00);
			System.out.println("\nСнятие $400...");
			c.withdraw(400.00);
		} catch(InsufficientFundsException e) {
			System.out.println("Извините, но у Вас $" + e.getAmount());
			e.printStackTrace();
		}
	}
}
```

Скомпилируйте все три выше обозначенные файла и произведите запуск `Bank`. Вследствие этого будет получен следующий результат:
```bash
Депозит $300...

Снятие $100...

Снятие $400...
Извините, но у Вас $200.0
InsufficientFundsException
         at Checking.withdraw(Checking.java:25)
         at Bank.main(Bank.java:13)
```
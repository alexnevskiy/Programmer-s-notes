Взято с [TopJava](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java).
# Класс `String`
Класс `String` отвечает за создание строк, состоящих из символов. А если быть точнее, заглянув в реализацию и посмотрев способ их хранения, то строки представляют собой **массив символов** (так было до Java 9):  
```java
private final char value[];
```

Начиная с **Java 9** строки хранятся как **массив байт**:  
```java
private final byte[] value;
```

**Строки в Java являются immutable, т. е. неизменяемыми**.  

Создать объект класса `String` можно двумя способами: при помощи строкового литерала и конструктора.  

Первый способ, а он является рекомендуемым, удобен и прост. **Под строковым литералом понимается последовательность символов, заключённых в двойные кавычки**:  
```java
String stringLiteral = "TopJava";
```

Класс `String` имеет в своём распоряжении множество конструкторов, которые могут принимать на вход данные разного типа. Например, строковый литерал:  
```java
String stringViaConstructor = new String("TopJava");
```

или массив символов:
```java
char[] chars = { 'T', 'o', 'p', 'J', 'a', 'v', 'a' };
String str = new String(chars);
```
# Интернирование строк
**Экземпляр класса `String` хранится в памяти, именуемой кучей (heap)**, но есть некоторые нюансы. Если строка, созданная при помощи конструктора хранится непосредственно в куче, то **строка, созданная как строковый литерал, уже хранится в специальном месте кучи** — в так называемом **пуле строк (string pool)**. **В нём сохраняются исключительно уникальные значения строковых литералов, а не все строки подряд**. Процесс помещения строк в пул называется **интернирование (от англ. interning)**.  

Когда мы объявляем переменную типа `String` и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там такое же значение. Если пул содержит необходимое значение, то компилятор просто возвращает ссылку на соответствующий адрес строки без выделения дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а ссылка на неё возвращена и присвоена переменной.  

Пример:
```java
public class StringExampleOne {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
    }
}
```

Результат выполнения программы:
```
Строка 1 равна строке 2? true
```

Напомним, что знак `==` сравнивает ссылки на объекты, а не их значения. Результат выполнения программы подтверждает, что строки `str1` и `str2` ссылаются на одно и то же место в памяти в пуле строк.  

Иллюстративно это выглядит так:
![string_pool1](/pictures/string_pool1.webp)

В следующем примере попробуем «склеить» строковые литералы и посмотрим, влияет ли конкатенация на результат:
```java
public class StringExampleTwo {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "Top" + "Java";

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
    }
}
```

Результат выполнения программы:
```
Строка 1 равна строке 2? true
```

В строке `"Top" + "Java"` создаются два строковых объекта со значениями `"Top"` и `"Java"`, которые помещаются в пул. «Склеенные» строки образуют еще одну строку со значением `"TopJava"`, ссылка на которую берётся из пула строк (а не создаётся заново), т.к. она была интернирована в него ранее.  

Значения всех строковых литералов из данного примера известны на этапе компиляции.  

Иллюстративно итоговый результат выглядит так:
![string_pool1](/pictures/string_pool2.webp)

А теперь давайте рассмотрим ещё один пример, который выдаст неожиданный результат:  
```java
public class StringExampleThree {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "Java";
        String str3 = "Top" + str2;

        System.out.println("Строка 1 равна строке 3? " + (str1 == str3));
    }
}
```

Результат выполнения программы:
```
Строка 1 равна строке 2? false
```

Схематично это выглядит примерно так:
![string_pool1](/pictures/string_pool3.webp)

Причиной получения `false` является то, что интернирование происходит не во время работы приложения (runtime), а во время компиляции. А т.к. значение строки `str3` вычисляется во время выполнения приложения, то на этапе компиляции оно не известно и потому, не добавляется в пул строк.
# Создание строк с помощью конструктора
**Когда мы создаём экземпляр класса `String` с помощью оператора `new`, компилятор размещает строки в куче**. При этом **каждая строка, созданная таким способом, помещается в кучу (и имеет свою ссылку), даже если такое же значение уже есть в куче или в пуле строк**.

Создадим строки через интернирование и с помощью конструктора, а затем сравним их ссылки:
```java
public class StringExampleFour {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";
        String str3 = new String("TopJava");
        String str4 = new String("TopJava");

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
        System.out.println("Строка 2 равна строке 3? " + (str2 == str3));
        System.out.println("Строка 3 равна строке 4? " + (str3 == str4));
    }
}
```

Результат выполнения программы:
```
Строка 1 равна строке 2? true
Строка 2 равна строке 3? false
Строка 3 равна строке 4? false
```

Иллюстративно это выглядит так:
![string_pool1](/pictures/string_pool4.webp)

Таким образом, создав четыре одинаковых строки, в памяти зафиксируются только три объекта.
# Ручное интернирование
В Java существует возможность вручную выполнить интернирование строки в пул путём вызова метода `intern()` у объекта типа `String`. Видоизменим приведённый ранее пример, добавив метод `intern()` к созданным при помощи конструктора строк:  
```java
public class StringExampleFive {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";
        String str3 = (new String("TopJava")).intern();
        String str4 = (new String("TopJava")).intern();

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
        System.out.println("Строка 2 равна строке 3? " + (str2 == str3));
        System.out.println("Строка 3 равна строке 4? " + (str3 == str4));
    }
}
```

Результат выполнения программы:
```
Строка 1 равна строке 2? true
Строка 2 равна строке 3? true
Строка 3 равна строке 4? true
```

Иллюстративно это выглядит так:
![string_pool1](/pictures/string_pool5.webp)

Рассмотрим ещё один интересный пример:  
```java
public class StringExampleSix {

    public static void main(String[] args) {
        String str1 = "interned TopJava";
        String str2 = "TopJava";
        String str3 = ("interned " + str2).intern();

        System.out.println("Строка 1 равна строке 3? " + (str1 == str3));
    }
}
```

Результат выполнения программы:
```
Строка 1 равна строке 3? true
```

Соответственно, иллюстративно это выглядит так:
![string_pool1](/pictures/string_pool6.webp)

Строки `str1` и `str2` добавлены в пул строк на этапе компиляции. Во время выполнения программы происходит конкатенация строки `"interned"` со значением строки `str2`, с последующим интернированием получившейся строки в пул строк (благодаря методу `intern()`). Но, так как пул строк уже содержит строку `"interned TopJava"`, объекту `String str3` будет присвоена ссылка на строку в пуле строк и, соответственно, выражение равенства ссылок `==` будет истинным.  

Принимая во внимание всё вышесказанное, вы можете спросить: «Почему бы все строки сразу после их создания не добавлять в пул строк? Ведь это приведет к экономии памяти…». Да, среди достаточно большого количества программистов такое заблуждение присутствует. Именно заблуждение, поскольку не все учитывают **дополнительные затраты виртуальной машины на процесс интернирования, а также падение производительности, в целом**. **Интернирование (в виде применения метода `intern()`) рекомендуется вообще не использовать**. Вместо интернирования необходимо использовать дедупликацию (рассматривается далее).
# Собственный пул строк
Что же тогда делать, если мы создаём много объектов класса `String`? Нам ничего не мешает написать свой собственный пул строк, доступ к которому может быть быстрее, чем к пулу виртуальной машины. После того, как он справится со своей работой, его можно легко уничтожить.
```java
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CHMInterner <T> {

    private final Map<T, T> map;

    public CHMInterner() {
        map = new ConcurrentHashMap<>();
    }

    public T intern(T t) {
        T exist = map.putIfAbsent(t, t);
        return (exist == null) ? t : exist;
    }

    public int internSize() {
        return map.size();
    }
}
```
```java
public class Main {

    public static void main(String[] args) {
        CHMInterner chmInterner = new CHMInterner();

        chmInterner.intern("TopJava_1");
        chmInterner.intern("TopJava_2");
        chmInterner.intern("TopJava_2");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");

        System.out.println("Размер пула строк равен: " + chmInterner.internSize());
    }
}
```

Результат выполнения программы:
```
Размер пула строк равен: 4
```

Таким образом, на основе `ConcurrentHashMap` был создан пул строк, в который мы пытались добавить 10 повторяющихся строк. В итоге были добавлены только 4 уникальных строки.
# Сборщик мусора
**До Java версии 7 виртуальная машина размещала пул строк в области памяти под названием [PermGen](https://topjava.ru/blog/permgen-and-metaspace)**, которая имеет фиксированный размер и не может быть расширена во время выполнения приложения. Также следует отметить, что на эту область памяти не распространяется действие сборщика мусора.  

Риск интернирования строк в область PermGen (вместо кучи) заключается в том, что мы можем получить от JVM ошибку `OutOfMemoryError`, если будем интернировать слишком много строк (PermGen имеет фиксированный размер).  

Учтите, что однажды интернированную строку в версии Java ниже 7й нельзя деинтернировать: она будет занимать память программы даже тогда, когда перестанет быть нужна. Из этого следует, что **чрезмерное интернирование строк может оказать негативный эффект, связанный с утечками памяти**!  

**Начиная с Java 7, пул строк размещается в куче, на которую распространяется процесс сборки мусора**. Преимуществом данного подхода является снижение вероятности появления ошибки `OutOfMemoryError`, так как строки, на которые не будет ссылаться ни одна переменная в выполняемой программе, будут удалены сборщиком мусора из пула, что приведёт к освобождению памяти.
# Производительность и оптимизация
В Java 6 единственной оптимизацией, которую мы могли сделать — это увеличить размер PermGen во время запуска программы, используя опцию JVM — `MaxPermSize`:  
```
-XX:MaxPermSize=1G
```

В Java 7 разработчикам предоставили более гибкую возможность настройки (увеличение/уменьшение) размера пула строк. Существуют две возможности посмотреть размер пула:  
```
-XX:+PrintStringTableStatistics
и
-XX:+PrintFlagsFinal
```

В Java 6 и Java 7 (до Java7u40) значение по умолчанию для параметра `-XX:StringTableSize` равняется 1009. С Java7u40 размер увеличен до 60 013 (такое же значение используется и в Java 8). В Java 11, 13 и 15 это значение уже составляет 65 536.  

Рассмотрим при помощи команды `-XX:+PrintStringTableStatistics` размер пула строк и другие данные:
```
SymbolTable statistics:
Number of buckets   	   : 	32768 = 262144 bytes, each 8
Number of entries   	   :    517 =   8272 bytes, each 16
Number of literals  	   :    517 =  19712 bytes, avg  38,000
Total footprint     	   :        = 290128 bytes
Average bucket size 	   :	0,016
Variance of bucket size    :  0,016
Std. dev. of bucket size   :  0,125
Maximum bucket size        :      2
StringTable statistics:
Number of buckets   	   : 	65536 = 524288 bytes, each 8
Number of entries   	   :     68 =   1088 bytes, each 16
Number of literals  	   :     68 =   4648 bytes, avg  68,000
Total footprint     	   :        = 530024 bytes
Average bucket size 	   :  0,001
Variance of bucket size    :  0,001
Std. dev. of bucket size   :  0,032
Maximum bucket size        :      1
```

Если мы хотим увеличить размер пула, то для этого необходимо воспользоваться опцией `StringTableSize`:  
```
-XX:StringTableSize=4901
```

Следует обратить внимание на то, что увеличение размера пула приведёт к тому, что будет задействован больший объём памяти, но при этом сократится время, необходимое для добавления строки непосредственно в пул.
# О `String` в Java 9
До Java 8 строка внутренне представлялась, как массив символов `char[]` в кодировке UTF-16, каждый из которых занимал по два байта в памяти.  

В Java 9 было внедрено новое представление для типа `String`, получившее название **[компактные строки](https://topjava.ru/blog/compact-strings-java-9) (Compact Strings)**. Благодаря новому формату **хранения строк (в зависимости от контента) делает выбор между массивом символов `char[]` и массивом байт `byte[]`**.  

Поскольку новый способ хранения объектов типа `String` **использует кодировку UTF-16 лишь в том случае, когда в этом есть необходимость, объём памяти, занимаемый пулом строк в куче, будет значительно ниже**, что в, свою очередь, уменьшит издержки работы сборщика мусора.  

Ключевые моменты:  
- Строки в Java представляют собой константы, которые не могут быть изменены  
- Создать объект класса `String` можно двумя способами: при помощи строкового литерала и конструктора  
- Строковый литерал сохраняется в пул строк, если до этого он там отсутствовал  
- Строка, созданная при помощи конструктора, сохраняется в heap, а не в пул строк  
- Java 6: Пул строк хранится в памяти фиксированного размера, именуемого PermGen.  
- Java 7, 8: Пул строк хранится в heap и, соответственно, для пула строк можно использовать всю память приложения  
- При помощи параметра `-XX:StringTableSize=N`, где N — размер `HashMap`, можно изменить размер пула строк. Его размер является фиксированным, поскольку он реализован, как `HashMap` со списками в корзинах  
- **Инженеры по оптимизации Java компании Oracle настоятельно не рекомендуют самостоятельно интернировать строки, поскольку это приводит к замедлению работы приложения. Их рекомендация — дедупликация**.
# Дедупликация
Класс `String` представляет собой массив байт:  
```java
private final byte[] value;
```

А т.к. созданный экземпляр класса `String` нельзя модифицировать, т. е. содержимое массива `value[]` нельзя изменить, то **его значение может быть безопасно использовано одновременно несколькими объектами `String`**.  

[Дедупликация](https://openjdk.java.net/jeps/192) представляет собой не что иное, как **переприсваивание виртуальной машиной адресов поля `value`**. Т.е. мы выполняем дедупликацию не объектов `String`, а массивов их байт. **Поля `value` нескольких объектов типа `String` с одинаковым значением текста изначально ссылаются на разные участки памяти (разные массивы байт), а после дедупликации будут ссылаться на один и тот же участок памяти, содержащий массив байт**.  

Кроме того, у нас всё ещё остаются накладные расходы в виде заголовка объекта, полей и др. Такие накладные расходы зависят от платформы/конфигурации и варьируются в пределах от 24 до 32 байт. Однако, для средней длины объекта `String` в 45 символов (90 байт + заголовок массива), это всё ещё значительные цифры. Принимая во внимание вышеперечисленное, **актуальный выигрыш в экономии памяти может быть около 10%**.
## Как работает дедупликация
Во время сборки мусора GC проверяет живые (имеющие рабочие ссылки) объекты в куче на возможность провести их дедупликацию. Ссылки на подходящие объекты вставляются в очередь для последующей обработки. Далее происходит попытка дедупликации каждого объекта `String` из очереди, а затем удаление из неё ссылок на объекты, на которые они ссылаются. Также для отслеживания всех уникальных массивов байт, используемых объектами `String`, используется хеш-таблица. При дедупликации в этой хеш-таблице выполняется поиск идентичных массивов байт (символов).  

При положительном результате значение поля `value` объекта `String` переприсваивается так, чтобы указывать на этот существующий массив байт. Соответственно, предыдущий массив байт `value` становится ненужным — на него ничего не ссылается и впоследствии он попадает под сборку мусора.  

При отрицательном результате, массив байт, соответствующий `value`, вставляется в хеш-таблицу, чтобы впоследствии быть использованным совместно с новым объектом `String` в какой-то другой момент в будущем.  

Давайте поэкспериментируем, запустив следующую программу:  
```java
import java.lang.reflect.Field;

public class DeduplicationDemo {

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        char[] chars = {'T', 'o', 'p', 'J', 'a', 'v', 'a'};
        String[] strings = {new String(chars), new String(chars)};
        Field value = String.class.getDeclaredField("value");
        value.setAccessible(true);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));

        System.gc();
        System.out.println("Запустили сборщик мусора");
        Thread.sleep(100);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
    }
}
```

Результат выполнения программы:
```
Хеш первого объекта: [B@5b480cf9
Хеш второго объекта: [B@6f496d9f
Запустили сборщик мусора
Хеш первого объекта: [B@5b480cf9
Хеш второго объекта: [B@6f496d9f
```

Как видим, дедупликация не сработала. Для её активации необходимо в параметрах виртуальной машины указать `-XX:+UseStringDeduplication`, а также активировать сборщик мусора G1 (если он не используется по умолчанию), указав также `-XX:+UseG1GC`.  

В этом случае имеем правильный результат выполнения программы:
```
Хеш первого объекта: [B@5b480cf9
Хеш второго объекта: [B@6f496d9f
Запустили сборщик мусора
Хеш первого объекта: [B@6f496d9f
Хеш второго объекта: [B@6f496d9f
```

Результат говорит о следующем: создав два объекта с помощью `new`, мы получили два разных объекта с разными идентификационными хешами для массивов байт. Запустив сборщик мусора и подождав некоторое время (дедупликация не происходит мгновенно), мы видим, что хеши для двух объектов стали одинаковы (ссылаются на один и тот же массив).  

Иллюстративно это выглядит так:
![string_pool1](/pictures/string_pool7.webp)

Видоизменим немного код, добавив в массив строковый литерал:  
```java
import java.lang.reflect.Field;

public class DeduplicationDemo {

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        char[] chars = {'T', 'o', 'p', 'J', 'a', 'v', 'a'};
        String[] strings = {new String(chars), new String(chars), "TopJava"};
        Field value = String.class.getDeclaredField("value");
        value.setAccessible(true);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
        System.out.println("Хеш третьего объекта: " + value.get(strings[2]));

        System.gc();
        System.out.println("Запустили сборщик мусора");
        Thread.sleep(100);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
        System.out.println("Хеш третьего объекта: " + value.get(strings[2]));
    }
}
```

Результат выполнения программы:
```
Хеш первого объекта: [B@5b480cf9
Хеш второго объекта: [B@6f496d9f
Хеш третьего объекта: [B@723279cf
Запустили сборщик мусора
Хеш первого объекта: [B@723279cf
Хеш второго объекта: [B@723279cf
Хеш третьего объекта: [B@723279cf
```

Иллюстративно это выглядит так:
![string_pool1](/pictures/string_pool8.webp)

Создав строковый литерал `str3`, мы, тем самым, строку `"TopJava"` добавили в пул строк. Во время дедупликации виртуальная машина увидев, что в пуле строк уже содержится такой массив байт, изменила адрес массива `byte[]` для созданных через конструктор строковых объектов на адрес массива `byte[]` строкового литерала, находящегося в пуле строк.  

Чтобы убедиться, что этот результат был получен благодаря дедупликации, попробуйте отключить функционал дедупликации строк в виртуальной машине.  

Ключевые моменты:  
- Дедупликация строк доступна с Java 8 Update 20
- Она активируется параметром для виртуальной машины: `-XX:+UseStringDeduplication`
- Дедупликация строк работает только со сборщиком мусора G1. Для его активации в Java 8 необходимо указать параметр для виртуальной машины `-XX:+UseG1GC`. Начиная с Java 9, G1 является сборщиком мусора по умолчанию
- Опыты показывают, что применение дедупликации строк сокращает расходы кучи на примерно 10%, что, в принципе, неплохо, учитывая, что нам не нужно вносить изменение в код
- Дедупликация строк работает в фоновом режиме без приостановления работы приложения
- В отличие от пула строк, который применим только для строк, интернированных командой `intern()`, или строковых литералов, но не применим для строк, созданных динамически во время жизни приложения, дедупликация строк применима для строк, созданных всеми этими способами
Взято с [struchkov.dev](https://struchkov.dev/blog/ru/java-collection-framework/#%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9) и [SkillBox](https://skillbox.ru/media/code/gotovimsya_k_sobesedovaniyu_chto_nuzhno_znat_o_kollektsiyakh_v_java/).
# ArrayList
`ArrayList` в Java — это динамический массив, который **хранит свои элементы внутри обычного массива объектов** `Object[]`.

Каждый экземпляр `ArrayList` имеет ёмкость (`CAPACITY`). Ёмкость – это размер массива, который используется для хранения элементов. **По мере добавления элементов в `ArrayList` его ёмкость автоматически увеличивается.**
![array_list](/pictures/array_list.webp)

Когда массив заполняется, его ёмкость увеличивается. Новая ёмкость вычисляется по формуле: `старая ёмкость * 1.5 + 1`. Например, если начальная ёмкость была 10, то после расширения она станет 16.

Начальный размер `capacity` равен 10. Можно передать своё значение `capacity`, используя конструктор `public ArrayList(int initialCapacity)`.

**При увеличении ёмкости создаётся новый массив, и все элементы из старого копируются в новый**, что является затратной операцией. Поэтому, если заранее известно, что список будет большим, лучше сразу задать достаточную начальную ёмкость.

**Удаление элементов из середины списка может быть затратной операцией**, так как все последующие элементы смещаются влево, что требует копирования данных. Также стоит отметить, что **размер внутреннего массива автоматически не уменьшается после удаления элементов**.

Метод `trimToSize()` позволяет уменьшить ёмкость `ArrayList` до фактического количества элементов. Он полезен, если список часто изменяется и его размер значительно сократился. Этот метод отсутствует в интерфейсе `List`, он доступен только в `ArrayList`.
# LinkedList
`LinkedList` реализует интерфейсы `List` и `Deque`, предоставляя двусвязный список. **Каждый элемент списка (узел) содержит ссылки как на следующий, так и на предыдущий элементы**, что делает эту структуру данных двусторонне связанной.
![array_list](/pictures/linked_list.webp)

Класс `LinkedList` содержит три основных поля:
- `Node<E> first` – Ссылка на первый элемент списка.
- `Node<E> last` – Ссылка на последний элемент списка.
- `int size` – Количество элементов в списке

Каждый узел (`Node`) хранит два элемента: данные и ссылки на следующий и предыдущий узлы.
```java
private static class Node<E> {

	E item;
	Node<E> next;
	Node<E> prev;

	Node(Node<E> prev, E element, Node<E> next) {
		this.item = item;
		this.next = next;
		this.prev = prev;
	}
}
```

**Добавление элемента в конец списка:**
- Создаётся новый узел (`Node`).
- Устанавливается значение (`item`) для нового узла.
- Ссылки узла добавляются в конец списка.
- Устанавливаются ссылки на предыдущий и следующий узлы (для нового и соседних узлов).
- Увеличивается размер списка.

**Добавление элемента в середину списка:**
- Проверяется индекс. Если он отрицательный или превышает размер списка, выбрасывается исключение `IndexOutOfBoundsException`.
- Если индекс равен размеру списка, элемент добавляется в конец.
- Вставка в середину происходит перед элементом с указанным индексом:
    - Метод `node(index)` находит узел по индексу.
    - Определяется место вставки (поиск узла идёт с начала или конца списка в зависимости от индекса).
    - Создаётся новый узел, и его ссылки устанавливаются между соседними узлами.
- Обновляются ссылки на предыдущие и следующие узлы для нового элемента и его соседей.
- Увеличивается размер списка.

**Удаление элемента по значению:**
1. Последовательно сравниваются элементы списка с заданным значением, начиная с первого узла.
2. Когда найден узел с соответствующим значением, элемент сохраняется в отдельную переменную.
3. Ссылки соседних узлов перенаправляются так, чтобы исключить удаляемый элемент.
4. Очищаются ссылки и данные узла, который содержал удалённый элемент, и уменьшается размер списка.
# Сравнение реализаций
`ArrayList`:
- **Добавление и удаление**: Вставка или удаление элементов в середине списка занимает **_O(n)_**, так как элементы сдвигаются для поддержания порядка, а в конце списка - **_O(1)_**.
- **Доступ по индексу**: Доступ к произвольному элементу по индексу происходит за **_O(1)_**, так как `ArrayList` использует массив.

`LinkedList`:
- **Добавление и удаление**: Вставка или удаление элементов на краю списка занимает **_O(1)_**. Однако, для вставки или удаления элемента в середине списка требуется найти его позицию, что занимает **_O(n)_**.
- **Доступ по индексу**: Доступ к произвольному элементу выполняется за **_O(n)_**, так как для этого нужно пройти по элементам списка от начала до нужного индекса.

Несмотря на то, что вставка и удаление элементов в середине списка для `ArrayList` требует **_O(n)_**, **производительность `ArrayList` всё же остаётся приемлемой для большинства случаев благодаря нативному методу `System.arraycopy()`, который используется для копирования массивов**. Этот метод оптимизирован на уровне системы, что делает его работу быстрой даже для больших массивов.
![array_list](/pictures/array_vs_linked.png)

**Вывод**: Используйте `ArrayList`, если вам важен быстрый доступ по индексу, и `LinkedList`, если важна эффективность вставки и удаления элементов в начале или конце списка.
Взято с [JavaRush](https://javarush.com/groups/posts/591-vot-tak-final).

**Суть модификатора `final`** - сделать дальнейшее изменение объекта невозможным.
# `final` для полей
Переменная `final` может быть **инициализирована только один раз**, либо через инициализатор, либо оператор присваивания.

Для **переменных примитивного типа** это означает, что **однажды присвоенное значение не может быть изменено**. 

Для **ссылочных переменных** это означает, что **после присвоения объекта, нельзя изменить ссылку на данный объект. Ссылку изменить нельзя, но состояние объекта изменять можно**.

С java 8 появилось понятие — **effectively final**. Применяется оно только к переменным (в том числе аргументам методов). Суть в том, что не смотря на явное отсутствие ключевого слова `final`, значение переменной не изменяется после инициализации. Другими словами, к такой переменной можно подставить слово `final` без ошибки компиляции. effectively final переменные могут быть использованы внутри локальных классов (Local Inner Classes), анонимных классов (Anonymous Inner Classes), стримах (Stream API).
```java
public void someMethod() {
    // В примере ниже и a и b - effectively final, тк значения устанавливаютcя однажды:
    int a = 1;
    int b;
    if (a == 2) b = 3;
    else b = 4;
    // с НЕ является effectively final, т.к. значение изменяется
    int c = 10;
    c++;

    Stream.of(1, 2).forEach(s -> System.out.println(s + a)); // Ок
    Stream.of(1, 2).forEach(s -> System.out.println(s + c)); // Ошибка компиляции
}
```
# `final` для методов
Для метода `final` означает, что он **не может быть переопределён в подклассах**. Это полезно, когда мы хотим, чтобы исходную реализацию нельзя было переопределить.
```java
public class SuperClass {

    public final void printReport() {
        System.out.println("Report");
    }
}

class SubClass extends SuperClass {

    public void printReport() { // Ошибка компиляции
        System.out.println("MyReport");
    }
}
```
# `final` для классов
Для класса это означает, что **класс не сможет иметь подклассов, т.е. запрещено наследование**. Это делается по соображениям безопасности и эффективности. Из-за того, что класс объявляется `final`, можно сказать, что все его методы тоже становятся `final` - их нельзя переопределить. Это полезно при создании immutable (неизменяемых) объектов, например, класс `String` объявлен, как `final`.
```java
public final class String {
}

class SubString extends String { // Ошибка компиляции
}
```

Следует также отметить, что к абстрактным классам (с ключевым словом `abstract`), нельзя применить модификатор `final`, т.к. это взаимоисключающие понятия.
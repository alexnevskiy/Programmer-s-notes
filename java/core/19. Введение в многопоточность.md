Взято с [struchkov.dev](https://struchkov.dev/blog/ru/introduction-to-multithreading/).
# Ключевые концепции многопоточности
[**Процессор**](https://garden.struchkov.dev/ru/dev/fundamental/%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80) — это аппаратное устройство, которое выполняет инструкции программы. Современные процессоры могут содержать несколько [ядер](https://garden.struchkov.dev/ru/dev/fundamental/%D0%AF%D0%B4%D1%80%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0), **где каждое ядро представляет собой отдельную вычислительную единицу**.

[**Процесс**](https://garden.struchkov.dev/ru/dev/fundamental/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%9E%D0%A1) — это логическая единица работы в операционной системе, которая выполняется на процессоре. **Каждый процесс обладает собственным пространством памяти и набором ресурсов**, таких как файлы, оперативная память и сетевые соединения.

**Когда программа запускается, операционная система создаёт для неё процесс**. Процесс может содержать один или несколько **потоков выполнения**. Важно отметить, что **каждый процесс изолирован от других и управляет только своими ресурсами**.

[**Потоки**](https://garden.struchkov.dev/ru/dev/fundamental/%D0%9F%D0%BE%D1%82%D0%BE%D0%BA-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%9E%D0%A1) — это подпроцессы, выполняющиеся внутри одного процесса. **Они могут работать параллельно с другими потоками в том же процессе, используя общие ресурсы процесса**, такие как память и файловые дескрипторы. **Но каждый поток имеет собственный стек и контекст выполнения**, что позволяет им работать независимо.
## Взаимосвязь между программой, процессом и потоком
![multithreading_intro](/pictures/multithreading_intro.webp)

1. **Программа** содержит набор инструкций.
2. **Загрузка программы в память** превращает её в один или несколько выполняющихся процессов.
3. **Запуск процесса** приводит к выделению памяти и ресурсов. **Процесс может содержать один или несколько потоков**. Например, в Microsoft Word один поток может отвечать за проверку орфографии, а другой — за ввод текста в документ.

**Основные различия между процессом и потоком**
- Процессы обычно независимы друг от друга, тогда как потоки являются подмножествами процесса.
- Каждый процесс имеет своё собственное пространство памяти, тогда как **потоки одного процесса разделяют одну и ту же память**.
- Создание и завершение процесса — это тяжеловесная операция, требующая времени.
- Обмен данными между потоками происходит быстрее, чем между процессами.
## Параллелизм и конкурентность
[**Конкурентность**](https://garden.struchkov.dev/ru/dev/fundamental/Concurrency) — это общий термин, описывающий способность программы обрабатывать несколько задач. **Это не обязательно означает одновременное выполнение**. Конкурентные программы могут [переключаться между задачами](https://garden.struchkov.dev/ru/dev/fundamental/%D0%9F%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0), создавая иллюзию параллельного выполнения, даже если задачи фактически выполняются последовательно.

[**Параллелизм**](https://garden.struchkov.dev/ru/dev/fundamental/Parallelism) — один из методов реализации конкурентности. Он предполагает **выполнение нескольких задач одновременно, каждая из которых выполняется независимо от других**.
![multithreading_intro_concurrency](/pictures/multithreading_intro_concurrency.webp)

Важно понимать, что **параллелизм** — это частный случай конкурентности, но **не все конкурентные программы являются многопоточными**. Конкурентность также может быть реализована через другие стратегии, такие как: [асинхронное программирование](https://garden.struchkov.dev/ru/dev/fundamental/%D0%90%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)**,** [реактивное программирование](https://struchkov.dev/blog/ru/overview-of-reactive-programming/).
## Одноядерные системы и переключение контекста
**В одноядерных системах программы могут выполнять только одну задачу в любой момент времени**. Если несколько задач работают одновременно, процессор вынужден быстро переключаться между ними, что называется [переключением контекста](https://garden.struchkov.dev/ru/dev/fundamental/%D0%9F%D0%B5%D1%80%D0%B5%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0).

Частое **переключение контекста создает накладные расходы, что снижает производительность системы и увеличивает задержки при выполнении задач**. Переключение контекста между процессами обходится дороже, чем между потоками.
![multithreading_intro_context](/pictures/multithreading_intro_context.webp)
## Определение многопоточности
**Многопоточность** — это метод реализации конкурентности, при котором несколько задач выполняются в виде отдельных потоков внутри одного процесса. Этот подход позволяет программам выполнять параллельно несколько операций, что особенно важно для оптимизации ресурсов современных многоядерных систем.

Представьте, что у вас есть трёхкомнатная квартира, которую нужно убрать. В данный момент вы единственный, кто может этим заняться. Уборка займёт у вас 3-4 часа. Однако через 20 минут возвращается ваш ребенок, и вы распределяете часть работы на него. Далее приходит ваш супруг, и теперь все три человека работают вместе. Вместе уборка завершается уже за час. **Этот процесс является аналогией многопоточности — вы разделили задачу между несколькими участниками, тем самым ускорив выполнение**.

Современные компьютеры и серверы оснащены многоядерными процессорами. В вашем примере роли "домочадцев" выполняют процессорные ядра. **Эти ядра могут работать параллельно, решая различные задачи одновременно**. Однако, как и в примере с уборкой, **ядра не смогут сами взять работу — разработчику нужно явно распределить задачи между потоками**.

Многопоточность позволяет решить две основные задачи:
1. **Одновременное выполнение разных задач**. Например, один поток может обрабатывать данные, в то время как другой выводит информацию на экран. Эти действия независимы друг от друга и могут выполняться параллельно.
2. **Ускорение вычислений**. Особенно эффективно на многоядерных системах, где каждая задача может быть распределена на отдельное ядро. Если у вас есть четыре задачи и четыре ядра, каждое ядро может одновременно решать свою задачу, что ускоряет общий процесс.

Многопоточность также помогает лучше использовать системные ресурсы. Если один поток приостанавливается из-за ожидания завершения [блокирующей операции](https://garden.struchkov.dev/ru/dev/architecture/%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B9-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2) (например, ввода-вывода), другие потоки могут продолжать работу, не простаивая, что повышает общую производительность приложения.
![multithreading_intro_definition](/pictures/multithreading_intro_definition.webp)
# Основные проблемы многопоточности
Несмотря на значительные преимущества, многопоточность имеет свои ограничения. При увеличении количества потоков возникает ряд факторов, препятствующих линейному росту производительности.

Два ключевых теоретических закона — **Закон Амдала** и **Закон универсальной масштабируемости** — объясняют, почему увеличение числа потоков не всегда приводит к пропорциональному ускорению выполнения программы.

[**Закон Амдала**](https://garden.struchkov.dev/ru/dev/fundamental/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD-%D0%90%D0%BC%D0%B4%D0%B0%D0%BB%D0%B0) описывает пределы ускорения программы при увеличении числа потоков. Даже **если большая часть программы может быть распараллелена, всегда останется часть, которая выполняется последовательно. Эта последовательная часть становится “узким горлышком” и ограничивает прирост производительности**. В результате, по мере увеличения числа потоков, прирост производительности начинает уменьшаться.

[Закон универсальной масштабируемости](https://garden.struchkov.dev/ru/dev/fundamental/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD-%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D0%B8) (Закон Буттлера) идёт дальше, объясняя, почему **производительность может даже снижаться при увеличении числа потоков**. Он учитывает два ключевых фактора:
- **Координационные затраты**: С ростом числа потоков возрастает необходимость их синхронизации и координации. Это требует дополнительных ресурсов и времени.
- **Конкуренция за ресурсы**: Потоки начинают конкурировать за ограниченные ресурсы системы, такие как процессорное время, память или доступ к файлам.

Закон Буттлера показывает, что при чрезмерном увеличении числа потоков производительность не только перестаёт расти, но может начать снижаться. Это связано с тем, что затраты на управление потоками начинают превышать выгоды от их параллельного выполнения.
## Общие ресурсы и синхронизация потоков
В многопоточных приложениях потоки могут одновременно обращаться к **общим ресурсам**, таким как переменные, объекты или файлы, что **создаёт риск ошибок, если несколько потоков пытаются одновременно изменить или прочитать один и тот же ресурс**. Основная сложность заключается в непредсказуемости порядка выполнения операций. Потоки могут “пересекаться” в своих действиях, что приводит к состояниям гонки и некорректным результатам. Поэтому **важно правильно синхронизировать доступ к общим ресурсам**.
## Состояние гонки
[**Состояние гонки**](https://garden.struchkov.dev/ru/dev/other/Race-condition) возникает, когда **несколько потоков одновременно обращаются к одному и тому же ресурсу, при этом хотя бы один поток изменяет его значение**. Если доступ к ресурсу не синхронизирован, порядок выполнения потоков становится непредсказуемым, что может привести к некорректным результатам.

Например, два потока могут одновременно пытаться обновить одну переменную, что вызовет хаотичное поведение программы.
![multithreading_intro_race](/pictures/multithreading_intro_race.webp)

Для предотвращения состояния гонки применяются механизмы синхронизации, такие как мьютексы, блокировки или ключевое слово `synchronized` в Java. Эти инструменты гарантируют, что только один поток может изменять общий ресурс в определённый момент времени.
## Проблемы согласованности данных
Даже если состояние гонки исключено, может возникнуть проблема нарушения согласованности данных. Это происходит, **когда изменения, сделанные одним потоком, не видны другим потокам сразу**. Например, поток может завершить обновление данных, но другой поток может прочитать их до того, как обновлённые значения станут доступны. **Проблема возникает из-за особенностей работы с кэшами процессора** и основным хранилищем памяти.

Для решения этой проблемы в Java используются инструменты для обеспечения согласованности памяти, такие как ключевое слово `volatile` и классы Atomic. Эти средства гарантируют, что изменения данных будут корректно и своевременно видны всем потокам.
## Дедлоки и взаимные блокировки (Deadlocks)
[**Дедлок**](https://garden.struchkov.dev/ru/dev/fundamental/Deadlock) — это ситуация, при которой два или более потока блокируют друг друга, ожидая освобождения ресурсов, которые удерживаются другим потоком. Чтобы понять это, нужно рассмотреть, что такое «блокировки» и «ресурсы».

**Блокировка** — это способ «захвата» ресурса, чтобы предотвратить доступ других потоков к этому ресурсу до завершения текущей операции.

**Ресурс** может быть любой частью программы, к которой требуется эксклюзивный доступ: файл, переменная, раздел памяти или даже объект базы данных.

Простой пример дедлока:
- Поток A захватывает ресурс 1 (например, файл) и пытается получить доступ к ресурсу 2 (например, переменной), но этот ресурс уже захвачен потоком B.
- Поток B захватывает ресурс 2 и пытается получить доступ к ресурсу 1, который удерживается потоком A.

**В результате оба потока зависают — каждый ждёт освобождения ресурса, который удерживает другой поток**. Это называется дедлоком, и программа перестаёт выполнять свои задачи, так как ни один из потоков не может продолжить работу.
## Тестирование и отладка многопоточных приложений
Тестирование многопоточных программ сложнее, чем однопоточных, из-за непредсказуемости взаимодействий между потоками. **Ошибки, такие как гонки данных и дедлоки, могут проявляться редко, что затрудняет их выявление**. Кроме того, такие **ошибки часто зависят от специфики среды, в которой выполняется программа, и могут возникать только при определённых условиях**, что делает тестирование ещё более сложным.

Отладка многопоточных программ также представляет собой серьёзную задачу. Даже при наличии отладчиков и логов отслеживание состояний и взаимодействий между потоками требует большого внимания. Такие проблемы, как нарушение синхронизации или состояние гонки, могут быть незаметными при стандартной отладке и проявляться лишь в стрессовых ситуациях, что делает их поиск особенно трудным.
# Синхронизация потоков
Синхронизация необходима для предотвращения гонок данных и обеспечения согласованности состояния программы при одновременном доступе нескольких потоков к общим ресурсам. **Синхронизация гарантирует, что один поток завершит работу с ресурсом до того, как другой поток получит к нему доступ**.

Основные механизмы синхронизации включают:
- **Мьютексы** — блокировки, которые гарантируют, что только один поток может работать с ресурсом в любой момент времени.
- **Семафоры** — ограничивают количество потоков, которые могут одновременно работать с ресурсом.
- **Мониторы (`synchronized`)** — в Java оператор `synchronized` привязывает блок к определённому потоку, исключая доступ других потоков в этот момент.

Дополнительно:
- **Рекурсивные блокировки (`ReentrantLock`)** позволяют одному потоку несколько раз входить в один и тот же критический участок кода.
- **Барьеры и счётчики (`CyclicBarrier`, `CountDownLatch`)** координируют выполнение потоков, синхронизируя их на определённой точке выполнения.

Избыточная синхронизация или неэффективное распределение потоков могут снизить производительность, вызывая дополнительные накладные расходы, связанные с переключением контекста и ожиданием блокировок.
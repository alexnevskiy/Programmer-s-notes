Взято с [Metanit](https://metanit.com/java/tutorial/5.10.php), [JavaRush](https://javarush.com/quests/lectures/questcollections.level07.lecture03) и [DevMark](https://devmark.ru/article/java-iterator), [ExamClouds](https://www.examclouds.com/ru/java/java-core-russian/iterator).
# Интерфейс `Iterator`
Интерфейс `Iterator` **позволяет осуществлять обход коллекции**, предоставляя при этом доступ к элементам коллекции и позволяя параллельно удалять избранные элементы.

Интерфейс имеет следующие методы:
- `boolean hasNext()` - возвращает `true`, если есть ещё элементы. В противном случае возвращает `false`.
- `E next()` - возвращает следующий элемент. Если следующий элемент коллекции отсутствует, то метод `next()` генерирует исключение `NoSuchElementException`.
- `void remove()` - удаляет текущий элемент. Выбрасывает исключение `IllegalStateException`, если предпринимается попытка вызвать `remove()`, которой не предшествовал вызов `next()`.
- `default void forEachRemaining(Consumer<? super E> action)` - выполняет заданное действие для всех оставшихся элементов коллекции.

Пример использования интерфейса **Iterator**:
```java
List<String> list = new ArrayList<String>();  
list.add("Hello");  
list.add("World");  
Iterator<String> iterator = list.iterator();  
  
while (iterator.hasNext()) {  
	String element = iterator.next();  
	System.out.println(element);  
}
```

В этом примере мы создаём список строк `ArrayList` и добавляем в него два элемента. Затем с помощью метода `iterator()` создаём объект `Iterator`, который позволяет перебирать элементы списка.

Мы используем цикл `while`, в котором сначала проверяем наличие следующего элемента методом `hasNext()`. Если метод возвращает `true` – идём на итерацию цикла, внутри которого вызываем метод `next()`.

В случае, если мы прошлись по всем элементам, метод `hasNext()` будет возвращать `false` и внутрь цикла мы уже не зайдём. При попытке вызвать метод `next()` после достижения конца списка, мы получим исключение `NoSuchElementException`.

Каждый **итератор обеспечивает перебор только в одну сторону и повторно пройтись этим же итератором по списку не получится**.
# Интерфейс `Iterable`
Интерфейс `Iterable` предоставляет более удобный способ работы с коллекциями, позволяя использовать цикл `for-each` для итерации по элементам коллекции. Именно он содержит метод `iterator()`, который возвращает уже знакомый нам объект `Iterator`.

Также интерфейс содержит методы `forEach()` и `spliterator()`. Они уже имеют реализацию по умолчанию, поэтому каждый раз их реализовывать не нужно.

Пример использования интерфейса `Iterable`:
```java
List<String> list = new ArrayList<String>();  
list.add("Hello");  
list.add("World");  

for (String element : list) {  
	System.out.println(element);  
}
```

В этом примере мы используем цикл `for-each` для итерации по элементам списка. Внутри цикла неявно вызывается `Iterator` благодаря тому, что список поддерживает интерфейс `Iterable`. При этом на каждой итерации будет создаваться новая переменная `element`, в которую будет помещаться очередной элемент из списка `list`.
# Изменение коллекции в цикле `for-each`
Иногда возникает необходимость при обходе коллекции тут же её модифицировать. Чаще всего требуется удаление элементов, если они удовлетворяют определённым условиям. Первое, что приходит в голову, это сделать удаление прямо внутри цикла `for-each`:
```java
List<String> list = new ArrayList<>();  
list.add("abc");  
list.add("def");  
list.add("ghi");  
  
for (String s : list) {  
	if (s.contains("a")) { // какое-то условие  
		list.remove(s); // ConcurrentModificationException  
	}  
}
```

Если мы попробуем выполнить такой код, то получим исключение `ConcurrentModificationException` при попытке удаления элемента. Дело в том, что внутри итератора стоит проверка, не изменилось ли количество элементов во время обхода коллекции. И если изменилось, то возникает такое исключение.

Решить эту задачу можно при помощи Stream API:
```java
list = list.stream()  
	.filter(e -> !e.contains("a"))
	.toList();
```

Или при помощи использования метода `removeIf()`, который принимает лямбду на вход:
```java
list.removeIf(e -> e.contains("a"));
```
# Интерфейс `ListIterator`
Интерфейс `Iterator` предоставляет ограниченный функционал. Гораздо больший набор методов предоставляет другой итератор - интерфейс `ListIterator`. Данный итератор используется классами, реализующими интерфейс `List`, то есть классами `LinkedList`, `ArrayList` и др.

Интерфейс `ListIterator` расширяет интерфейс `Iterator` и определяет ряд дополнительных методов:
- `void add(E obj)` - вставляет объект `obj` перед элементом, который должен быть возвращен следующим вызовом `next()`
- `boolean hasNext()` - возвращает `true`, если в коллекции имеется следующий элемент, иначе возвращает `false`
- `boolean hasPrevious()` - возвращает `true`, если в коллекции имеется предыдущий элемент, иначе возвращает `false`
- `E next()` - возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение `NoSuchElementException`
- `E previous()` - возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение `NoSuchElementException`
- `int nextIndex()` - возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка
- `int previousIndex()` - возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1
- `void remove()` - удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов `next()` или `previous()`, иначе будет сгенерировано исключение `IlligalStateException`
- `void set(E obj)` - присваивает текущему элементу, выбранному вызовом методов `next()` или `previous()`, ссылку на объект `obj`
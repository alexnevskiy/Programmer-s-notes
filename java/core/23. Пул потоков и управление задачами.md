Взято с [Dzen](https://dzen.ru/a/ZOm0epnK0TJeaw3_), [JavaOnline](https://java-online.ru/concurrent-executor.xhtml) и [JavaRush](https://javarush.com/quests/lectures/jru.module2.lecture20).
# Пул потоков (Thread Pool)
**ThreadPool (пул потоков)** в Java представляет собой механизм, который позволяет эффективно управлять и переиспользовать потоки выполнения. Он представлен классом `ThreadPoolExecutor` из пакета `java.util.concurrent`.

Потоки выполнения используются для асинхронного выполнения кода и обработки задач. Однако создание нового потока для каждой задачи может быть ресурсоёмким и приводить к излишней нагрузке на систему. **ThreadPool позволяет создать ограниченное количество заранее созданных потоков, которые могут выполнять задачи из пула**.

Если задач больше, чем потоков, то задачи ждут в очереди (Task Queue). Из очереди задача попадает на исполнение к N-ному потоку из пула, а после выполнения задачи поток забирает новую задачу из очереди. После выполнения всех задач из очереди потоки остаются активными и ждут новых задач. Когда задачи появляются, потоки начинают выполнять и их.

Основные преимущества использования ThreadPool включают:
- **Повышение производительности**: При использовании пула потоков можно избежать накладных расходов на создание нового потока для каждой задачи. Задачи могут быть поставлены в очередь и выполняться параллельно в доступных потоках, что позволяет более эффективно использовать ресурсы системы.
- **Управление ресурсами**: Пул потоков позволяет определить оптимальное количество потоков для конкретной системы. Можно задать максимальное количество потоков, которое пул будет поддерживать одновременно, чтобы избежать перегрузки системы.
- **Контроль нагрузки**: Пул потоков может использоваться для ограничения количества задач, которые в данный момент могут выполняться параллельно. Это особенно полезно при работе с внешними ресурсами или ограниченными системными ресурсами, чтобы избежать их перегрузки.
- **Упрощение программирования**: Использование ThreadPool позволяет абстрагироваться от прямого управления потоками выполнения. Разработчику не нужно беспокоиться о создании и уничтожении потоков, поскольку пул самостоятельно управляет ими.

За счёт этих преимуществ ThreadPool является полезным инструментом для многопоточного программирования в Java, который помогает оптимизировать использование ресурсов и повышает производительность при обработке задач.
# `ExecutorService`
В многопоточный пакет concurrent для управления потоками включено средство, называемое сервисом исполнения `ExecutorService`. Данное **средство служит альтернативой классу `Thread`, предназначенному для управления потоками**. **В основу сервиса исполнения положен интерфейс `Executor`, в котором определён один метод**:
```java
void execute(Runnable thread);
```

При вызове метода `execute` исполняется поток `thread`. То есть, метод `execute` запускает указанный поток на исполнение. Следующий код показывает, как вместо обычного старта потока `Thread.start()` можно запустить поток с использованием сервиса исполнения:
```java
// Вместо следующего кода
new Thread(new RunnableTask()).start();

// можно использовать ExecutorService executor;
. . .
executor.execute(new CallableSample1());
Future<String> f1 = executor.submit(new CallableSample2());
```

При запуске задач с помощью `Executor` пакета `java.util.concurrent` не требуется прибегать к низкоуровневой поточной функциональности класса `Thread`, **достаточно создать объект типа `ExecutorService` с нужными свойствами и передать ему на исполнение задачу типа `Callable`**. Впоследствии можно **легко просмотреть результат выполнения этой задачи с помощью объекта `Future`**.

**Интерфейс `ExecutorService` расширяет свойства `Executor`, дополняя его методами управления исполнением и контроля**. Так в интерфейс `ExecutorService` включён метод `shutdown()`, позволяющий останавливать все потоки исполнения, находящиеся под управлением экземпляра `ExecutorService`. Также в интерфейсе `ExecutorService` определяются методы, которые запускают потоки исполнения [FutureTask](https://java-online.ru/concurrent-future.xhtml), возвращающие результаты и позволяющие определять статус остановки.
## Методы интерфейса `ExecutorService`
| Метод                                                                                              | Описание                                                                                                                                                                                                          |
| -------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `boolean awaitTermination(long timeout, TimeUnit unit)`                                            | Блокировка до тех пор, пока все задачи не завершат выполнение после запроса на завершение работы, или пока не наступит тайм-аут, или не будет прерван текущий поток, в зависимости от того, что произойдёт раньше |
| `List<Future<T>> invokeAll (Collection<? extends Callable<T>> tasks)`                              | Выполнение задач с возвращением списка задач с их статусом и результатами завершения                                                                                                                              |
| `List<Future<T>> invokeAll (Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)` | Выполнение задач с возвращением списка задач с их статусом и результатами завершения в течение заданного времени                                                                                                  |
| `T invokeAny(Collection<? extends Callable<T>> tasks)`                                             | Выполнение задач с возвращением результата успешно выполненной задачи (т. е. без создания исключения), если таковые имеются                                                                                       |
| `T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)`                | Выполнение задач в течение заданного времени с возвращением результата успешно выполненной задачи (т. е. без создания исключения), если таковые имеются                                                           |
| `boolean isShutdown()`                                                                             | Возвращает `true`, если исполнитель сервиса остановлен (`shutdown`)                                                                                                                                               |
| `boolean isTerminated()`                                                                           | Возвращает `true`, если все задачи исполнителя сервиса завершены по команде остановки (`shutdown`)                                                                                                                |
| `void shutdown()`                                                                                  | Упорядоченное завершение работы, при котором ранее отправленные задачи выполняются, а новые задачи не принимаются                                                                                                 |
| `List<Runnable> shutdownNow()`                                                                     | Остановка всех активно выполняемых задач, остановка обработки ожидающих задач, возвращение списка задач, ожидающих выполнения                                                                                     |
| `Future<T> submit(Callable<T> task)`                                                               | Завершение выполнения задачи, возвращающей результат в виде объекта `Future`                                                                                                                                      |
| `Future<?> submit(Runnable task)`                                                                  | Завершение выполнения задачи, возвращающей объект `Future`, представляющий данную задачу                                                                                                                          |
| `Future<T> submit(Runnable task, T result)`                                                        | Завершение выполнения задачи, возвращающей объект `Future`, представляющий данную задачу                                                                                                                          |
Наибольший интерес в интерфейсе `ExecutorService` представляет метод **`submit()`, который ставит задачу в очередь на выполнение**. В качестве входного параметра данный метод принимает объект типа `Callable` или `Runnable`, а возвращает параметризованный объект типа `Future`, который можно использовать для доступа к результату выполнения задачи. Метод `call` соответствующего `Callable`-объекта возвращает объект `Future`. **С использованием объекта `Future` можно определить завершение выполнения задачи** (метод` isDone()`) и **получить доступ к результату** (метод `get`) **или исключительной ситуации**, если в процессе выполнения задачи произошла ошибка.

Стоит обратить внимание на метод `shutdown()`, который выполняет остановку объекта `ExecutorService`. Поскольку потоки в объекте `ExecutorService` не останавливаются сами, как обычно, поэтому их необходимо явно остановить с помощью данного метода; при этом, **если в `ExecutorService` находятся невыполненные задачи, то потоки будут остановлены только, когда завершится последняя задача**.

Пакет concurrent включает интерфейс `ScheduledExecutorService`, расширяющий интерфейс `ExecutorService` для поддержки планирования потоков исполнения. Кроме этого, в пакет включены три предопределенных класса исполнителей: `ThreadPoolExecutor`, `ScheduledThreadPoolExecutor` и `ForkJoinPool`.

**`ThreadPoolExecutor`** реализует интерфейс `ExecutorService` и **обеспечивает поддержку управляемого пула потоков исполнения**. Класс **`ScheduledThreadPoolExecutor`** реализует интерфейс `ScheduledExecutorService` для **поддержки планирования пула потоков исполнения**. А класс **`ForkJoinPool`** реализует интерфейс `ExecutorService` и **применяется в каркасе Fork/Join Framework**.
## Пример использования `ExecutorService`
В примере создадим фиксированный пул из двух потоков исполнения `executor` и четыре потока. Имплементации потоков в качестве параметра принимают объект синхронизации потоков `CountDownLatch`, так называемую «защёлку», и текстовую строку. Сервис `executor` стартует все 4 потока на исполнение. Таким образом, четыре потока должны совместно использовать пул из двух потоков. **Первые попавшие в пул потоки приступают к исполнению. Оставшиеся переходят в режим ожидания и вступают в работу по мере освобождения пула**.

«Защёлки» `CountDownLatch` используются для того, чтобы раньше времени «не выскочить» на команду завершения выполнения `shutdown`. Методы защёлок `await` тормозят этот выход, переводя программу в ожидание завершения работы потока. После того, как все задачи будут выполнены, пул закрывается и программа завершает свою работу.

Вызов метода `shutdown` очень важен. Если его не использовать, то программа не смогла бы завершиться, поскольку исполнитель оставался бы активным. В этом можно убедиться, закомментировав вызов метода `shutdown`.
```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.*;

public class ExecutorServiceExample {
    SimpleDateFormat sdf = null;
    private final int COUNT = 5;

    ExecutorServiceExample() {
        sdf = new SimpleDateFormat("HH:mm:ss.S");

        CountDownLatch cdl1 = new CountDownLatch(COUNT);
        CountDownLatch cdl2 = new CountDownLatch(COUNT);
        CountDownLatch cdl3 = new CountDownLatch(COUNT);
        CountDownLatch cdl4 = new CountDownLatch(COUNT);

        ExecutorService executor;
        executor = Executors.newFixedThreadPool(2);

        System.out.println("Запуск потоков");
        executor.execute(new MyThread(cdl1, "Thread.1"));
        executor.execute(new MyThread(cdl2, "Thread.2"));
        executor.execute(new MyThread(cdl3, "Thread.3"));
        executor.execute(new MyThread(cdl4, "Thread.4"));

        try {
            cdl1.await();
            cdl2.await();
            cdl3.await();
            cdl4.await();
        } catch(InterruptedException exc) { }

        executor.shutdown();
        System.out.println("Завершение потоков");
    }
    //-------------------------------------------------
    void printMessage(final String templ) {
        String text = sdf.format(new Date()) + " : " + templ;
        System.out.println(text);
    }
    //-------------------------------------------------
    class MyThread implements Runnable {
        String         name;
        CountDownLatch latch;
        MyThread(CountDownLatch c, String n) {
            latch = c;
            name = n;
            new Thread(this);
        }

        public void run() {
            try {
                for(int i = 0; i < COUNT; i++) {
                    printMessage(name + " - " + i);
                    latch.countDown();
                    Thread.sleep((long) (Math.random() * 1500));
                }
                printMessage(name + " completed");
            } catch (InterruptedException e) {}
        }
    }
    //-------------------------------------------------
	public static void main(String args[]) {
		new ExecutorServiceExample(); 
	}
}
```

В методе `run` в цикле в консоль выводится текст строки, номер цикла и увеличивается счетчик «защёлки». Между циклами – небольшая задержка. После завершения всех циклов в консоль выводится соответствующее сообщение.

Метод «защёлки» `countDown` увеличивает счётчик. При достижении счетчиком порогового значения (`COUNT`) метод `await` «снимает защёлку». После того, как «защёлки» всех потоков сняты, пул закрывается.

Обратите внимание, что, как только открылась последняя защёлка, сначала сервис исполнения успел завершить работу, а после этого поток.
```
Запуск потоков
14:46:54.048 : Thread.2 - 0
14:46:54.048 : Thread.1 - 0
14:46:55.070 : Thread.2 - 1
14:46:55.118 : Thread.1 - 1
14:46:55.286 : Thread.2 - 2
14:46:56.078 : Thread.1 - 2
14:46:56.112 : Thread.1 - 3
14:46:56.152 : Thread.2 - 3
14:46:56.261 : Thread.2 - 4
14:46:56.356 : Thread.2 completed
14:46:56.357 : Thread.3 - 0
14:46:56.850 : Thread.3 - 1
14:46:57.632 : Thread.1 - 4
14:46:58.071 : Thread.3 - 2
14:46:58.468 : Thread.3 - 3
14:46:58.595 : Thread.3 - 4
14:46:59.039 : Thread.1 completed
14:46:59.039 : Thread.4 - 0
14:47:00.023 : Thread.3 completed
14:47:00.488 : Thread.4 - 1
14:47:01.982 : Thread.4 - 2
14:47:03.044 : Thread.4 - 3
14:47:03.975 : Thread.4 - 4
Завершение потоков
14:47:04.679 : Thread.4 completed
```
# `ThreadPoolExecutor`
`ThreadPoolExecutor` реализует интерфейсы `Executor` и `ExecutorService` и разделяет создание задачи и её выполнение. Нам **необходимо реализовать объекты `Runnable` и отправить их исполнителю, а `ThreadPoolExecutor` отвечает за их исполнение, создание экземпляров и работу с потоками**.

После того, как задача отправляется на исполнение, используется уже созданный поток из пула. Тем самым решается вопрос траты ресурсов на создание и инициализацию нового потока, а после использования – на его очистку GC-ом – и повышается производительность.

`ThreadPoolExecutor` имеет 4 конструктора:
```java
ThreadPoolExecutor(
	int corePoolSize,
	int maximumPoolSize,
	long keepAliveTime,
	TimeUnit unit,
	BlockingQueue<Runnable> workQueue
)

ThreadPoolExecutor(
	int corePoolSize,
	int maximumPoolSize,
	long keepAliveTime,
	TimeUnit unit,
	BlockingQueue<Runnable> workQueue,
	RejectedExecutionHandler handler
)

ThreadPoolExecutor(
	int corePoolSize,
	int maximumPoolSize,
	long keepAliveTime,
	TimeUnit unit,
	BlockingQueue<Runnable> workQueue,
	ThreadFactory threadFactory
)

ThreadPoolExecutor(
	int corePoolSize,
	int maximumPoolSize,
	long keepAliveTime,
	TimeUnit unit,
	BlockingQueue<Runnable> workQueue,
	ThreadFactory threadFactory,
	RejectedExecutionHandler handler
)
```

В конструктор передаются параметры `ThreadPoolExecutor`:

| Параметр          | Описание                                                                                                                                                                                                                    |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `corePoolSize`    | Параметр, который показывает, какое количество потоков будет готово (запущено) при старте `executor` сервиса.                                                                                                               |
| `maximumPoolSize` | Максимальное количество потоков, которое может создать `executor` сервис.                                                                                                                                                   |
| `keepAliveTime`   | Время, в течение которого освободившийся поток будет жить и впоследствии будет уничтожен, если количество потоков больше `corePoolSize`. Временные единицы указываются в следующем параметре.                               |
| `unit`            | Времненные единицы (часы, минуты, секунды, милисекунды и так далее).                                                                                                                                                        |
| `workQueue`       | Реализация очереди для задач.                                                                                                                                                                                               |
| `handler`         | Обработчик задач, которые не могут быть выполнены.                                                                                                                                                                          |
| `threadFactory`   | Объект, который создает новые потоки по требованию. Использование фабрик потоков устраняет аппаратную привязку вызовов к новому потоку, позволяя приложениям использовать специальные подклассы потоков, приоритеты и т. д. |
Создание `ThreadPoolExecutor` может нам упростить утилитарный класс `Executors`. В этом утилитарном классе есть методы, которые нам помогут подготовить объект `ThreadPoolExecutor`.

| Метод                                                                                                                                                                                                                                                                                                                                           | Пример                                                                      |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| `newFixedThreadPool` — создаёт пул потоков, который повторно использует фиксированное количество потоков для выполнения любого количества задач.                                                                                                                                                                                                | `ExecutorService executor = Executors.newFixedThreadPool(10);`              |
| `newWorkStealingPool` – создаёт пул потоков, где количество потоков = количество ядер процессора, которые доступны для JVM. Дефолтный уровень параллелизма – один. Это значит, что в пуле будет создано столько потоков, сколько ядер ЦП доступно JVM. Если параллелизм равен 4, тогда вместо количества ядер используется переданное значение. | `ExecutorService executor = Executors.newWorkStealingPool(4);`              |
| `newSingleThreadExecutor` – создаёт пул с единственным потоком для выполнения всех задач.                                                                                                                                                                                                                                                       | `ExecutorService executor = Executors.newSingleThreadExecutor();`           |
| `newCachedThreadPool` – создаёт пул потоков, который создаёт новые потоки по мере необходимости, но будет повторно использовать ранее созданные потоки, когда они будут доступны.                                                                                                                                                               | `ExecutorService executor = Executors.newCachedThreadPool();`               |
| `newScheduledThreadPool` – создаёт пул потоков, который может планировать выполнение команд после заданной задержки или для периодического выполнения.                                                                                                                                                                                          | `ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);` |

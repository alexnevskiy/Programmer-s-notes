Взято с [JavaOnline](https://java-online.ru/concurrent-locks.xhtml#econdition), [Habr](https://habr.com/ru/articles/277669/).
# Locks
Обычная синхронизация обеспечивает надёжное обновление множественных общих переменных в многопоточном приложении предупреждая гонку или повреждение данных и гарантирует, что параллельные потоки, синхронизируемые должным образом, увидят последние значения этих переменных. Но такая синхронизация не совершена и имеет некоторые функциональные ограничения:
- невозможно прервать поток, который ожидает блокировки;
- невозможно опрашивать или пытаться получить блокировку, не будучи готовым к долгому ожиданию;
- блокировка должна быть снята в том же стековом фрейме, в котором была начата.

Пакет `java.util.concurrent.locks` включает классы, которые можно использовать для блокировки ресурсов с определёнными условиями, и которые существенно отличаются от встроенной синхронизации и мониторов. Этот пакет разрешает намного большую гибкость в использовании блокировок без условий и с условием. Классы пакета реализуют следующие интерфейсы:
- `Lock` - интерфейс поддерживает порядок блокировки и позволяет использовать многократно связанный условный объект `Condition`;
- `Condition` - интерфейс описывает связанные с блокировками переменные, которые могут выполнять функции монитора объекта;
- `ReadWriteLock` - интерфейс поддерживает пару связанных блокировок: одну для чтения и одну для записи.
## Интерфейс `Lock`
**Интерфейс `Lock`** — это абстракция, допускающая выполнение блокировок, которые реализуются как классы Java, а не как возможность языка (объекта). Это расширяет возможности применения `Lock`, которые могут иметь различные алгоритмы планирования. Блокировка `Lock` является инструментом для того, чтобы управлять доступом к совместно используемому ресурсу параллельными потоками.

Реализации интерфейса `Lock` существенно расширяют возможности блокировок по сравнению c `synchronized`. **Интерфейс `Lock` позволяет осуществлять более гибкое структурирование и поддерживает многократно связанный условный объект `Condition`.**
### Методы
| Метод                               | Описание                                                      |
| ----------------------------------- | ------------------------------------------------------------- |
| `lock()`                            | Получение блокировки                                          |
| `lockInterruptibly()`               | Получение блокировки, если текущий поток не прерывается       |
| `newCondition()`                    | Получение нового `Condition`, связанного с блокировкой `Lock` |
| `tryLock()`                         | Получение блокировки, если она свободна во время вызова       |
| `tryLock(long time, TimeUnit unit)` | Получение блокировки в течение заданного времени              |
| `unlock()`                          | Освобождение блокировки                                       |
Дополнительные возможности, предоставляемые блокировкой `Lock` накладывают определённые обязанности при её использовании. Так, **отсутствие блочно-структурированной блокировки исключает автоматическое её освобождение, как это происходит с `synchronized`**. Поэтому следует использовать следующую структуру кода, включающую блокировку `Lock`:
```java
Lock lk = ...;
lk.lock();
try {
	// доступ к защищенному блокировкой ресурсу
} finally {
	// освобождение блокировки
    lk.unlock();
}
```
### Класс `ReentrantLock`
Класс `ReentrantLock`, реализующий интерфейс `Lock`, также, как и `synchronized`, обеспечивает многопоточность, но **имеет дополнительные возможности, связанные с опросом о блокировании (lock polling), ожиданием блокирования в течение определённого времени и прерыванием ожидания блокировки**. Кроме того, **`ReentrantLock` предлагает гораздо более высокую эффективность функционирования в условиях жёсткой состязательности**. Другими словами, когда несколько потоков пытаются получить доступ к совместно используемому ресурсу, виртуальной машине JVM потребуется меньше времени на установление очередности потоков и больше времени на её выполнение.

В переводе _reentrant_ может означать _повторно используемый_ (повторный вход). Что может означать блокировка _с повторным входом_? Это учёт количества получения определенных блокировок. Т.е. один и тот же поток повторно получает одну и ту же блокировку. Но для того, чтобы реально разблокировать необходимо уже будет два раза снять блокировку. Это аналогично использованию `synchronized`; если поток повторно входит в синхронный блок, защищенный монитором, то блокировка не будет снята при выходе потока из второго (или последующего) блока `synchronized`, блокировка будет снята только когда поток выйдет из первого блока `synchronized`, в который он вошёл под защитой монитора.

Одним из интересных методов интерфейса `Lock` и его реализации `ReentrantLock` является запрос блокировки с возможностью прерывания процесса ожидания. Т.е. если поток запрашивает блокировку методом `lockInterruptibly()` и не получает её сразу же, то переходит в процесс ожидания. Методом `interrupt` работу потока можно прервать. Тогда ожидающий блокировки поток просыпается, и генерируется исключительная ситуация `InterruptedException`. После этого попыток доступа к защищённому ресурсу (получения блокировок) не делается и освобождать блокировку не требуется. Ниже представлен пример использования блокировки `lockInterruptibly`. Структура кода использования блокировки `lockInterruptibly` имеет следующий вид :
```java
Lock l = new ReentrantLock();
try {
    l.lockInterruptibly();
    try {
		// работа с защищенным ресурсом
    } finally {
        l.unlock();
    }
} catch (InterruptedException e) {
    System.err.println("Interrupted wait");
}
```

Внутренний блок try-finally получает блокировку и доступ к защищённым ресурсам; после завершения работы блокировка освобождается. Внешний блок try-catch обрабатывает исключительные ситуации запроса блокировки. Если поток прерван в результате исключительной ситуации, то выполняется перехват `catch (InterruptedException)` и метод снятия блокировки `unlock` не вызывается.

Практика показывает, что **реализация `ReentrantLock` гораздо более масштабируемая в условиях состязательности, чем `synchronized`**. Это значит, что если несколько потоков соперничают за право получения блокировки, общая пропускная способность обычно лучше у `ReentrantLock`, чем у `synchronized`. И наоборот, если особого столкновения за право получения блокировки не наблюдается, то можно использовать и `synchronized`.
### Пример использования `ReentrantLock`
В примере `ReentrantLockExample` используется внутренний класс `LockClass` для организации двух потоков. Константы `TIME_WAIT` и `TIME_SLEEP` используются потоками для организации определённых задержек при выполнении. Текстовая переменная `resource` используется в качестве общего ресурса, значение которого будет изменяться внутри потоков. Метод `printMessage` выводит в консоль сообщения потоков с указанием времени.

В конструкторе примера создается блокировка `lock` типа `ReentrantLock` и два потока, которые будут использовать `lock` для блокирования доступа к текстовому ресурсу. Сначала каждый поток пытается в течение определённого времени (`TIME_WAIT`, мс) блокировать доступ к ресурсу `resource` с использованием метода `tryLock`. Если блокировка получена, то текст строки `resource` изменяется. После этого в потоке выполняется некоторая задержка по времени (`TIME_SLEEP`, мс) и поток завершает свою работу с освобождением блокировки методом `unlock`. Если поток в течение времени `TIME_WAIT` не смог блокировать ресурс, то он переходит к стадии задержки и завершению работы.

Оперируя временем ожидания блокировки `TIME_WAIT` и временем задержки `TIME_SLEEP` можно дать возможность либо каждому из потоку изменить значение `resource`, либо только одному.
```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
public class ReentrantLockExample {

    String resource = "Hello, World!";
    SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss  ");

    Lock lock;

    final int TIME_WAIT = 7000;
    final int TIME_SLEEP = 5000;
    
    ReentrantLockExample() {
        lock = new ReentrantLock();
        Thread thread1;
        Thread thread2;
        thread1 = new Thread(new LockClass("first",
                                           "Первый поток"));
        thread2 = new Thread(new LockClass("second",
                                           "Второй поток"));
        thread1.start();
        thread2.start();

        printMessage(null);

        while (thread1.isAlive() || thread2.isAlive()) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("\nЗавершение работы примера");
        System.exit(0);
    }
    //-----------------------------------------------------
    void printMessage(final String msg) {
        String text = sdf.format(new Date());
        if (msg == null) {
	        text += resource;
        } else {
	        text += msg;
        }
        System.out.println(text);
    }
    //-----------------------------------------------------
    class LockClass implements Runnable {
    
        String name;
        String text;
        
        public LockClass(String name, String text) {
            this.name = name;
            this.text = text;
        }

        @Override
        public void run() {
            boolean locked = false;
            try {
                // Получение блокировки в течение TIME_WAIT
                locked = lock.tryLock(TIME_WAIT, TimeUnit.MILLISECONDS);
                if (locked) {
                    resource = text;
                    printMessage(null);
                }
                Thread.sleep(TIME_SLEEP);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // Убираем блокировку
                String text = name + " : завершил работу";
                printMessage(text);
                if (locked) lock.unlock();
            }
        }
    }
    //-----------------------------------------------------
    public static void main(String[] args) {
        new ReentrantLockExample();
    }
}
```

Пример исполнен для двух вариантов значений констант `TIME_WAIT` и `TIME_SLEEP`. В первом варианте значение `TIME_WAIT`, равное 7 c, больше значения `TIME_SLEEP` (5 c). Поэтому оба потока получают доступ к ресурсу и изменяют значение ресурса.
```
14:26:09  Hello, World!
14:26:09  Первый поток
14:26:14  first : завершил работу
14:26:14  Второй поток
14:26:19  second : завершил работу

Завершение работы примера
```
 
Во втором варианте время ожидания `TIME_WAIT` (5 c), меньше времени задержки `TIME_SLEEP` (7 c). Поэтому только один поток получает доступ к ресурсу для изменения значения ресурса; второй поток разрешение на блокировку не получил по времени.
```
14:28:10  Hello, World!
14:28:10  Второй поток
14:28:17  second : завершил работу
14:28:22  first : завершил работу

Завершение работы примера
```
### Пример блокировки `lockInterruptibly`
Основу примера использования `lockInterruptibly` составляет предыдущий пример `ReentrantLockExample`. Поэтому ниже в листингах будут представлены только изменения в коде.

Основная идея примера `LockInterruptiblyExample` связана с тем, чтобы в очередь (в ожидание) на получение блокировки поставить два потока, а в первом потоке, получившем блокировку, прервать работу одного из потоков. Все потоки используют изменённый, по сравнению с исходным примером, класс `LockClass`, реализующий интерфейс `Runnable`.

Следующий код демонстрирует старт трёх потоков; второй и третий потоки стартуют с небольшой задержкой, чтобы надежно первый поток захватил блокировку `lock`, в противном случае первым захватить блокировку может и второй поток, работу которого необходимо прерывать.
```java
Lock lock;

Thread thread1;
Thread thread2;
Thread thread3;

LockInterruptiblyExample() {

    lock = new ReentrantLock();
    thread1 = new Thread(new LockClass("first" , 
                                       "Первый поток"));
    thread2 = new Thread(new LockClass("second", 
                                       "Второй поток"));
    thread3 = new Thread(new LockClass("third" , 
                                       "Третий поток"));

    thread1.start();
    try {
        Thread.sleep(400);
        thread2.start();
        thread3.start();
    } catch (InterruptedException e) {}
    . . .
    System.out.println("\nЗавершение работы примера");
    System.exit(0);
}
```

Метод `run` класса `LockClass` претерпевает значительные изменения. В первую очередь это касается вызов метода `lockInterruptibly` для получения блокировки. После этого следует небольшая задержка в 2 сек, и далее выполняется проверка, если это первый поток, то он прерывает работу второго потока. После чего первый поток даёт возможность второму потоку завершить работу, а сам изменяет и печатает строку общего ресурса, снимает блокировку и завершает работу. Второй же поток не попадает в секцию `try...finally`, а завершается с исключением, которое перехватывает `catch (InterruptedException)`.
```java
@Override
public void run() {
    try {
        printMessage("Wait (" + name + ") ...");
        lock.lockInterruptibly();
        try {
            Thread.sleep(2000);
            if (name.equalsIgnoreCase("first")) {
                printMessage("Прерывание второго потока");
                thread2.interrupt();
                thread2.join();
            }
            // доступ к ресурсу
            resource = text;
            printMessage(null);
            Thread.sleep(TIME_SLEEP);
        } finally {
            // Убираем блокировку
            lock.unlock();
            String text = name + " : завершил работу";
            printMessage(text);
        }
    } catch (InterruptedException e) {
        printMessage(name + " : interrupted wait");
    }
}
```

Ниже представлены сообщения потоков. Сначала потоки запрашивают блокировку, первый поток, пришедший первым, получает её, а два потока остаются в ожидании освобождения/получения блокировки. После небольшой задержки первый поток прерывает работу второго потока и ждёт его завершения. Далее первый поток освобождает блокировку и завершает работу. Сразу же после этого третий поток получает блокировку и далее по сценарию.
```
11:17:20  Wait (first) ...
11:17:21  Wait (second) ...
11:17:21  Wait (third) ...
11:17:22  Прерывание второго потока
11:17:22  second : interrupted wait
11:17:22  Первый поток
11:17:29  first : завершил работу
11:17:31  Третий поток
11:17:38  third : завершил работу

Завершение работы примера
```
## Интерфейс Condition
**Интерфейсное условие `Condition` в сочетании с блокировкой `Lock` позволяет заменить методы монитора (`wait`, `notify` и `notifyAll`) объектом, управляющим ожиданием событий.** Блокировка `Lock` заменяет использование `synchronized`, а `Condition` — объектные методы монитора.
### Методы
| Метод                             | Описание                                                                                                                                                                         |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `await()`                         | Переводит поток в состояние ожидания до тех пор, пока не будет выполнено некоторое условие или пока другой поток не вызовет методы `signal`/`signalAll`                          |
| `await(long time, TimeUnit unit)` | Переводит поток в состояние ожидания на определённое время, пока не будет выполнено некоторое условие или пока другой поток не вызовет методы `signal`/`signalAll`               |
| `signal()`                        | Сигнализирует потоку, у которого ранее был вызван метод `await()`, о возможности продолжения работы. Применение аналогично использованию методу `notify` класса `Object`         |
| `signalAll()`                     | Сигнализирует всем потокам, у которых ранее был вызван метод `await()`, о возможности продолжения работы. Применение аналогично использованию методу `notifyAll` класса `Object` |
**Условие `Condition`, иначе именуемое как очередь условия, предоставляет средство управления для одного потока, чтобы приостановить его выполнение до тех пор, пока он не будет уведомлён другим потоком.** Объект `Condition` связывают с блокировкой. Чтобы получить `Condition` для блокировки `Lock` используют метод `newCondition()`.
```java
ReentrantLock locker = new ReentrantLock();
Condition condition = locker.newCondition();
```

Чтобы перевести поток в ожидание, если определённое условие не выполняется, то используется метод `await`:
```java
while (условие) {
	condition.await();
}
```

После завершения всех действий в потоке (при выходе) подаётся сигнал об изменении условия другим потокам :
```java
condition.signalAll();
```
### Пример использования `Condition`
Пример `ReentrantCondExample` демонстрирует использование объекта условия `Condition` с блокировкой `ReentrantLock`. В примере описывается торговый склад, в который производитель завозит товар из списка `GOODS`. Товар регистрируется в коллекции `goods`. Потребитель забирает товар со склада.

В конструкторе примера создаются торговый склад `store` и два потока: `producer` и `consumer`. Метод `printMessage` выводит сообщения потоков в консоль.
```java
import java.text.SimpleDateFormat;

import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantCondExample {

    Store store = null;
    SimpleDateFormat sdf = null;
    final String[] GOODS = {"Молоко", "Кефир", "Ряженка", "Кофе", "Чай"};
    List<String> goods = new ArrayList<String>();

    ReentrantCondExample() {
        store = new Store();
        sdf = new SimpleDateFormat("HH:mm:ss  ");

        Thread producer = new Thread(new Producer()); 
        Thread consumer = new Thread(new Consumer());
        producer.start();
        consumer.start();

        while (producer.isAlive() || consumer.isAlive()) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("\nЗавершение работы примера");
        System.exit(0);
    }
    //-----------------------------------------------------
    void printMessage(final String msg) {
        if (msg != null) {
            String text = sdf.format(new Date()) + msg;
            System.out.println(text);
        } else
            System.out.println("\tТоваров на складе:"
                                + goods.size());
    }
    //-----------------------------------------------------
    public static void main(String[] args) {
        new ReentrantCondExample();
    }
}
```

Производитель представлен внутренним классом `Producer`. Время задержки в методе `run` класса определяет возможный интервал доставки товара. Потребитель представлен классом `Consumer`. Время задержки в методе `run` класса определяет возможный интервал реализации товара. Производитель завозит товар чаще (время задержки меньше), чем потребитель забирает товар (время задержки больше). На складе всего 3 места для товара. Таким образом, работу производителя необходимо притормаживать. Эту функцию выполняет блокировка `lock` с условием `cond` в классе `Store`.
```java
// Производитель
class Producer implements Runnable {

    public void run() {
        for (int i = 0; i < GOODS.length; i++) {
            store.put(GOODS[i]);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) { }
        }
    }
}
//-----------------------------------------------------
// Потребитель
class Consumer implements Runnable {

    public void run(){
        for (int i = 0; i > GOODS.length; i++) {
            try {
                Thread.sleep(8000);
            } catch (InterruptedException e) { }
            store.get();
        }
    }
}
```

Класс `Store` включает метод получения товара `put` и метод выдачи товара `get`. Шаблон выполнения операций обоих методов идентичен: сначала метод получает блокировку, чтобы другой поток не вошёл в данный метод; после этого выполняется проверка условий. Если условия не соблюдаются, то поток переводится в стадию ожидания методом `cond.await()`. Для второго потока условия должны быть соблюдены (такая бизнес-логика работы склада), и он должен выполнить свою операцию. После этого второй поток «будит» первый, а сам завершает операцию и разблокирует метод. «Разбуженный» первый поток вновь выполняет проверку условия, и далее действует согласно предписанному сценарию (либо продолжение выполнения, либо переход в ожидание).
```java
// Склад с товаром
class Store {

    ReentrantLock lock;  // блокировка
    Condition cond;  // условие блокировки

    Store() {
        lock = new ReentrantLock();
        cond = lock.newCondition(); 
    }

    public void get() {
        lock.lock();
        try {
            // ожидание на пустом складе
            while (goods.size() < 1) {
	            cond.await();
            }

            printMessage("Реализация : " + goods.get(0));
            goods.remove(0);
            printMessage(null);
            // Сигнализация
            cond.signalAll();
        } catch (InterruptedException e) {
        
        } finally {
            lock.unlock();
        }
    }
    
    public void put(final String good) {
        lock.lock();
        try {
            // ожидание освобождения места
            while (goods.size() >= 3) {
	            cond.await();
            } 
            goods.add(good);

            printMessage("Доставка : " + good);
            printMessage(null);
            // Сигнализация
            cond.signalAll();
        } catch (InterruptedException e) { 
        
        } finally {
            lock.unlock();
        }
    }
}
```

Сообщения в консоли показывают, что сначала идёт наполнение склада до 3-х единиц товара поскольку время задержки `Producer` (2000 мс) значительно меньше времени задержки `Consumer` (8000 мс). При полном наполнении склада `Producer` останавливается в ожидании освобождения склада. Как только со склада забирается товар, т.е. освобождается место, сразу же производитель завозит новый товар и снова переходит в режим ожидания. Таким образом, видим, что блокировка с условием работает точно так, как ей предписано документацией.
```
13:01:17  Доставка : Молоко
    Товаров на складе: 1
13:01:19  Доставка : Кефир
    Товаров на складе: 2
13:01:21  Доставка : Ряженка
    Товаров на складе: 3
13:01:25  Реализация : Молоко
    Товаров на складе: 2
13:01:25  Доставка : Кофе
    Товаров на складе: 3
13:01:33  Реализация : Кефир
    Товаров на складе: 2
13:01:33  Доставка : Чай
    Товаров на складе: 3
13:01:41  Реализация : Ряженка
    Товаров на складе: 2
13:01:49  Реализация : Кофе
    Товаров на складе: 1
13:01:57  Реализация : Чай
    Товаров на складе: 0

Завершение работы примера
```
# Синхронизаторы
**Синхронизаторы** – вспомогательные утилиты для синхронизации потоков, которые **дают возможность разработчику регулировать и/или ограничивать работу потоков и предоставляют более высокий уровень абстракции**, чем основные примитивы языка (мониторы).
![multithreading_locks_synchronizers](/pictures/multithreading_locks_synchronizers.png)
## `Semaphore`
Синхронизатор `Semaphore` реализует шаблон синхронизации [Семафор](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)). Чаще всего, **семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу**. В конструктор этого класса (`Semaphore(int permits)` или `Semaphore(int permits, boolean fair)`) обязательно передаётся количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.
![multithreading_locks_semaphore](/pictures/multithreading_locks_semaphore.gif)

**Доступ управляется с помощью счётчика**: изначально значение счётчика равно `int permits`, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока (в качестве примера из жизни с `permits = 1`, можно привести очередь в кабинет в поликлинике: когда пациент покидает кабинет, мигает лампа, и заходит следующий пациент).
### Пример
Существует парковка, которая одновременно может вмещать не более 5 автомобилей. Если парковка заполнена полностью, то вновь прибывший автомобиль должен подождать пока не освободится хотя бы одно место. После этого он сможет припарковаться.  
```java
import java.util.concurrent.Semaphore; 

public class Parking { 

	//Парковочное место занято - true, свободно - false 
	private static final boolean[] PARKING_PLACES = new boolean[5];
	//Устанавливаем флаг "справедливый", в таком случае метод 
	//aсquire() будет раздавать разрешения в порядке очереди 
	private static final Semaphore SEMAPHORE = new Semaphore(5, true); 
	public static void main(String[] args) throws InterruptedException { 
		for (int i = 1; i <= 7; i++) { 
			new Thread(new Car(i)).start(); 
			Thread.sleep(400); 
		} 
	} 
	
	public static class Car implements Runnable { 
		private int carNumber; 
		
		public Car(int carNumber) { 
			this.carNumber = carNumber; 
		} 
		
		@Override 
		public void run() { 
			System.out.printf("Автомобиль №%d подъехал к парковке.\n", carNumber); 
			try { 
				//acquire() запрашивает доступ к следующему за вызовом этого метода блоку кода, 
				//если доступ не разрешен, поток вызвавший этот метод блокируется до тех пор, 
				//пока семафор не разрешит доступ 
				SEMAPHORE.acquire(); 
				
				int parkingNumber = -1; 
				//Ищем свободное место и паркуемся 
				synchronized (PARKING_PLACES) {
					for (int i = 0; i < 5; i++) {
						if (!PARKING_PLACES[i]) { //Если место свободно 
							PARKING_PLACES[i] = true; //занимаем его 
							parkingNumber = i; //Наличие свободного места, гарантирует семафор 
							System.out.printf("Автомобиль №%d припарковался на месте %d.\n", carNumber, i); 
							break; 
						} 
					}
				} 
				
				Thread.sleep(5000); //Уходим за покупками, к примеру 
				synchronized (PARKING_PLACES) { 
				PARKING_PLACES[parkingNumber] = false; //Освобождаем место 
				} 
				
				//release(), напротив, освобождает ресурс 
				SEMAPHORE.release(); 
				System.out.printf("Автомобиль №%d покинул парковку.\n", carNumber); 
			} catch (InterruptedException e) { 
			} 
		} 
	} 
}
```

Результат работы программы:
```
Автомобиль №1 подъехал к парковке.  
Автомобиль №1 припарковался на месте 0.  
Автомобиль №2 подъехал к парковке.  
Автомобиль №2 припарковался на месте 1.  
Автомобиль №3 подъехал к парковке.  
Автомобиль №3 припарковался на месте 2.  
Автомобиль №4 подъехал к парковке.  
Автомобиль №4 припарковался на месте 3.  
Автомобиль №5 подъехал к парковке.  
Автомобиль №5 припарковался на месте 4.  
Автомобиль №6 подъехал к парковке.  
Автомобиль №7 подъехал к парковке.  
Автомобиль №1 покинул парковку.  
Автомобиль №6 припарковался на месте 0.  
Автомобиль №2 покинул парковку.  
Автомобиль №7 припарковался на месте 1.  
Автомобиль №3 покинул парковку.  
Автомобиль №4 покинул парковку.  
Автомобиль №5 покинул парковку.  
Автомобиль №6 покинул парковку.  
Автомобиль №7 покинул парковку.
```

Семафор отлично подходит для решения такой задачи: он не даёт автомобилю (потоку) припарковаться (зайти в заданный блок кода и воспользоваться общим ресурсом), если мест на парковке нет (счётчик равен 0). Стоит отметить, что класс `Semaphore` поддерживает захват и освобождение более чем одного разрешения за раз, но в данной задаче это не нужно.
## `CountDownLatch`
`CountDownLatch` (замок с обратным отсчётом) предоставляет **возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определённое количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность**. В конструктор `CountDownLatch` (`CountDownLatch(int count)`) обязательно передаётся количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.
![multithreading_locks_countdownlatch](/pictures/multithreading_locks_countdownlatch.gif)

Блокировка потоков снимается с помощью счётчика: любой действующий поток, при выполнении определённой операции уменьшает значение счётчика. Когда счётчик достигает 0, все ожидающие потоки разблокируются и продолжают выполняться (примером `CountDownLatch` из жизни может служить сбор экскурсионной группы: пока не наберется определённое количество человек, экскурсия не начнётся).
### Пример
Мы хотим провести автомобильную гонку. В гонке принимают участие пять автомобилей. Для начала гонки нужно, чтобы выполнились следующие условия:  
1. Каждый из пяти автомобилей подъехал к стартовой прямой;
2. Была дана команда «На старт!»;
3. Была дана команда «Внимание!»;
4. Была дана команда «Марш!».

Важно, чтобы все автомобили стартовали одновременно.  
```java
import java.util.concurrent.CountDownLatch;

public class Race {    
	//Создаем CountDownLatch на 8 "условий"    
	private static final CountDownLatch START = new CountDownLatch(8);    
	//Условная длина гоночной трассы    
	private static final int trackLength = 500000;    
	
	public static void main(String[] args) throws InterruptedException {        
		for (int i = 1; i <= 5; i++) {            
			new Thread(new Car(i, (int) (Math.random() * 100 + 50))).start();            
			Thread.sleep(1000);        
		}        
		
		while (START.getCount() > 3) {//Проверяем, собрались ли все автомобили        
			Thread.sleep(100); //у стартовой прямой. Если нет, ждем 100ms  
		}      
			
		Thread.sleep(1000);        
		System.out.println("На старт!");        
		START.countDown(); //Команда дана, уменьшаем счетчик на 1        
		Thread.sleep(1000);        
		System.out.println("Внимание!");        
		START.countDown(); //Команда дана, уменьшаем счетчик на 1        
		Thread.sleep(1000);        
		System.out.println("Марш!");       
		START.countDown(); //Команда дана, уменьшаем счетчик на 1        
		//счетчик становится равным нулю, и все ожидающие потоки        
		//одновременно разблокируются    
	}    
	
	public static class Car implements Runnable {        
		private int carNumber;       
		private int carSpeed; //считаем, что скорость автомобиля постоянная        
		public Car(int carNumber, int carSpeed) {            
			this.carNumber = carNumber;            
			this.carSpeed = carSpeed;        
		}        
		
		@Override        
		public void run() {            
			try {                
				System.out.printf("Автомобиль №%d подъехал к стартовой прямой.\n", carNumber);                
				//Автомобиль подъехал к стартовой прямой - условие выполнено                
				//уменьшаем счетчик на 1               
				START.countDown();                
				//метод await() блокирует поток, вызвавший его, до тех пор, пока     
				//счетчик CountDownLatch не станет равен 0                
				START.await();                
				Thread.sleep(trackLength / carSpeed); //ждем пока проедет трассу         
				System.out.printf("Автомобиль №%d финишировал!\n", carNumber);            
			} catch (InterruptedException e) {            
			}        
		}    
	}
}
```

Результат работы программы:
```
Автомобиль №1 подъехал к стартовой прямой.  
Автомобиль №2 подъехал к стартовой прямой.  
Автомобиль №3 подъехал к стартовой прямой.  
Автомобиль №4 подъехал к стартовой прямой.  
Автомобиль №5 подъехал к стартовой прямой.  
На старт!  
Внимание!  
Марш!  
Автомобиль №4 финишировал!  
Автомобиль №1 финишировал!  
Автомобиль №3 финишировал!  
Автомобиль №5 финишировал!  
Автомобиль №2 финишировал!
```

`CountDownLatch` может быть использован в самых разных схемах синхронизации: к примеру, чтобы пока один поток выполняет работу, заставить другие потоки ждать или, наоборот, чтобы заставить поток ждать других, чтобы выполнить работу.
## `CyclicBarrier`
`CyclicBarrier` реализует шаблон синхронизации [Барьер](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F). Циклический барьер является **точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется**. **Как только все потоки прибыли, выполняется опционное действие** (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (`CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)`) обязательно передаётся количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».
![multithreading_locks_barrier](/pictures/multithreading_locks_barrier.gif)

Барьер похож на `CountDownLatch`, но главное различие между ними в том, что **вы не можете заново использовать «замок» после того, как его счётчик достигнет нуля, а барьер вы можете использовать снова, даже после того, как он сломается**. `CyclicBarrier` является альтернативой метода `join()`, который «собирает» потоки только после того, как они выполнились.
### Пример
Существует паромная переправа. Паром может переправлять одновременно по три автомобиля. Чтобы не гонять паром лишний раз, нужно отправлять его, когда у переправы соберется минимум три автомобиля.
```java
import java.util.concurrent.CyclicBarrier;

public class Ferry {

    private static final CyclicBarrier BARRIER = new CyclicBarrier(3, new FerryBoat());
    //Инициализируем барьер на три потока и таском, который будет выполняться, когда
    //у барьера соберется три потока. После этого, они будут освобождены.

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 9; i++) {
            new Thread(new Car(i)).start();
            Thread.sleep(400);
        }
    }

    //Таск, который будет выполняться при достижении сторонами барьера
    public static class FerryBoat implements Runnable {
        @Override
        public void run() {
            try {
                Thread.sleep(500);
                System.out.println("Паром переправил автомобили!");
            } catch (InterruptedException e) {
            }
        }
    }

    //Стороны, которые будут достигать барьера
    public static class Car implements Runnable {
        private int carNumber;

        public Car(int carNumber) {
            this.carNumber = carNumber;
        }

        @Override
        public void run() {
            try {
                System.out.printf("Автомобиль №%d подъехал к паромной переправе.\n", carNumber);
                //Для указания потоку о том что он достиг барьера, нужно вызвать метод await()
                //После этого данный поток блокируется, и ждет пока остальные стороны достигнут барьера
                BARRIER.await();
                System.out.printf("Автомобиль №%d продолжил движение.\n", carNumber);
            } catch (Exception e) {
            }
        }
    }
}
```

Результат работы программы:
```
Автомобиль №0 подъехал к паромной переправе.  
Автомобиль №1 подъехал к паромной переправе.  
Автомобиль №2 подъехал к паромной переправе.  
Автомобиль №3 подъехал к паромной переправе.  
Паром переправил автомобили!  
Автомобиль №2 продолжил движение.  
Автомобиль №1 продолжил движение.  
Автомобиль №0 продолжил движение.  
Автомобиль №4 подъехал к паромной переправе.  
Автомобиль №5 подъехал к паромной переправе.  
Автомобиль №6 подъехал к паромной переправе.  
Паром переправил автомобили!  
Автомобиль №5 продолжил движение.  
Автомобиль №4 продолжил движение.  
Автомобиль №3 продолжил движение.  
Автомобиль №7 подъехал к паромной переправе.  
Автомобиль №8 подъехал к паромной переправе.  
Паром переправил автомобили!  
Автомобиль №8 продолжил движение.  
Автомобиль №6 продолжил движение.  
Автомобиль №7 продолжил движение.
```

Когда три потока достигают метода `await()`, барьерное действие запускается, и паром переправляет три автомобиля из скопившихся. После этого начинается новый цикл.
## `Exchanger<V>`
`Exchanger` (обменник) может понадобиться, для того, чтобы **обменяться данными между двумя потоками в определённой точки работы обоих потоков**. Обменник — обобщённый класс, он параметризируется типом объекта для передачи.
![multithreading_locks_exchanger](/pictures/multithreading_locks_exchanger.gif)

Обменник является точкой синхронизации пары потоков: поток, вызывающий у обменника метод `exchange()` блокируется и ждёт другой поток. **Когда другой поток вызовет тот же метод, произойдет обмен объектами: каждый из них получит аргумент другого в методе `exchange()`**. Стоит отметить, что обменник поддерживает передачу `null` значения. Это даёт возможность использовать его для передачи объекта в одну сторону, или, просто как точку синхронизации двух потоков.
### Пример
Есть два грузовика: один едет из пункта A в пункт D, другой из пункта B в пункт С. Дороги AD и BC пересекаются в пункте E. Из пунктов A и B нужно доставить посылки в пункты C и D. Для этого грузовики в пункте E должны встретиться и обменяться соответствующими посылками.
```java
import java.util.concurrent.Exchanger;

public class Delivery {
    //Создаем обменник, который будет обмениваться типом String
    private static final Exchanger<String> EXCHANGER = new Exchanger<>();

    public static void main(String[] args) throws InterruptedException {
        String[] p1 = new String[]{"{посылка A->D}", "{посылка A->C}"};//Формируем груз для 1-го грузовика
        String[] p2 = new String[]{"{посылка B->C}", "{посылка B->D}"};//Формируем груз для 2-го грузовика
        new Thread(new Truck(1, "A", "D", p1)).start();//Отправляем 1-й грузовик из А в D
        Thread.sleep(100);
        new Thread(new Truck(2, "B", "C", p2)).start();//Отправляем 2-й грузовик из В в С
    }

    public static class Truck implements Runnable {
        private int number;
        private String dep;
        private String dest;
        private String[] parcels;

        public Truck(int number, String departure, String destination, String[] parcels) {
            this.number = number;
            this.dep = departure;
            this.dest = destination;
            this.parcels = parcels;
        }

        @Override
        public void run() {
            try {
                System.out.printf("В грузовик №%d погрузили: %s и %s.\n", number, parcels[0], parcels[1]);
                System.out.printf("Грузовик №%d выехал из пункта %s в пункт %s.\n", number, dep, dest);
                Thread.sleep(1000 + (long) Math.random() * 5000);
                System.out.printf("Грузовик №%d приехал в пункт Е.\n", number);
                parcels[1] = EXCHANGER.exchange(parcels[1]);//При вызове exchange() поток блокируется и ждет
                //пока другой поток вызовет exchange(), после этого произойдет обмен посылками
                System.out.printf("В грузовик №%d переместили посылку для пункта %s.\n", number, dest);
                Thread.sleep(1000 + (long) Math.random() * 5000);
                System.out.printf("Грузовик №%d приехал в %s и доставил: %s и %s.\n", number, dest, parcels[0], parcels[1]);
            } catch (InterruptedException e) {
            }
        }
    }
}
```

Результат работы программы:
```
В грузовик №1 погрузили: {посылка A->D} и {посылка A->C}.  
Грузовик №1 выехал из пункта A в пункт D.  
В грузовик №2 погрузили: {посылка B->C} и {посылка B->D}.  
Грузовик №2 выехал из пункта B в пункт C.  
Грузовик №1 приехал в пункт Е.  
Грузовик №2 приехал в пункт Е.  
В грузовик №2 переместили посылку для пункта C.  
В грузовик №1 переместили посылку для пункта D.  
Грузовик №2 приехал в C и доставил: {посылка B->C} и {посылка A->C}.  
Грузовик №1 приехал в D и доставил: {посылка A->D} и {посылка B->D}.
```

Как мы видим, когда один грузовик (один поток) приезжает в пункт Е (достигает точки синхронизации), он ждёт пока другой грузовик (другой поток) приедет в пункт Е (достигнет точки синхронизации). После этого происходит обмен посылками (String) и оба грузовика (потока) продолжают свой путь (работу).
## `Phaser`
`Phaser` (фазер), как и `CyclicBarrier`, является реализацией шаблона синхронизации [Барьер](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F), но, в отличии от `CyclicBarrier`, предоставляет больше гибкости. Этот класс **позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия**. Как и `CyclicBarrier`, `Phaser` является точкой синхронизации, в которой встречаются потоки-участники. Когда все стороны прибыли, `Phaser` переходит к следующей фазе и снова ожидает её завершения.  
  
Если сравнить `Phaser` и `CyclicBarrier`, то можно выделить следующие важные особенности Phaser:`  `
- Каждая фаза (цикл синхронизации) имеет номер;
- Количество сторон-участников жёстко не задано и может меняться: поток может регистрироваться в качестве участника и отменять своё участие;
- Участник не обязан ожидать, пока все остальные участники соберутся на барьере. Чтобы продолжить свою работу достаточно сообщить о своем прибытии;
- Случайные свидетели могут следить за активностью в барьере;
- Поток может и не быть стороной-участником барьера, чтобы ожидать его преодоления;
- У фазера нет опционального действия.
  
Объект `Phaser` создается с помощью одного из конструкторов:  
```java
Phaser()
Phaser(int parties)
```

Параметр `parties` указывает на количество сторон-участников, которые будут выполнять фазы действия. Первый конструктор создаёт объект `Phaser` без каких-либо сторон, при этом барьер в этом случае тоже «закрыт». Второй конструктор регистрирует передаваемое в конструктор количество сторон. Барьер открывается когда все стороны прибыли, или, если снимается последний участник. (У класса `Phaser` ещё есть конструкторы, в которые передается родительский объект `Phaser`, но мы их рассматривать не будем.)  
  
Основные методы:  
- `int register()` — регистрирует нового участника, который выполняет фазы. Возвращает номер текущей фазы;
- `int getPhase()` — возвращает номер текущей фазы;
- `int arriveAndAwaitAdvance()` — указывает, что поток завершил выполнение фазы. Поток приостанавливается до момента, пока все остальные стороны не закончат выполнять данную фазу. Точный аналог `CyclicBarrier.await()`. Возвращает номер текущей фазы;
- `int arrive()` — сообщает, что сторона завершила фазу, и возвращает номер фазы. При вызове данного метода поток не приостанавливается, а продолжает выполнятся;
- `int arriveAndDeregister()` — сообщает о завершении всех фаз стороной и снимает её с регистрации. Возвращает номер текущей фазы;
- `int awaitAdvance(int phase)` — если `phase` равно номеру текущей фазы, приостанавливает вызвавший его поток до её окончания. В противном случае сразу возвращает аргумент.
![multithreading_locks_phaser](/pictures/multithreading_locks_phaser.gif)
### Пример
Есть пять остановок. На первых четырёх из них могут стоять пассажиры и ждать автобуса. Автобус выезжает из парка и останавливается на каждой остановке на некоторое время. После конечной остановки автобус едет в парк. Нам нужно забрать пассажиров и высадить их на нужных остановках.
```java
import java.util.ArrayList;
import java.util.concurrent.Phaser;

public class Bus {

    private static final Phaser PHASER = new Phaser(1);//Сразу регистрируем главный поток
    //Фазы 0 и 6 - это автобусный парк, 1 - 5 остановки

    public static void main(String[] args) throws InterruptedException {
        ArrayList<Passenger> passengers = new ArrayList<>();

        for (int i = 1; i < 5; i++) {           //Сгенерируем пассажиров на остановках
            if ((int) (Math.random() * 2) > 0)
                passengers.add(new Passenger(i, i + 1));//Этот пассажир выходит на следующей

            if ((int) (Math.random() * 2) > 0)
                passengers.add(new Passenger(i, 5));    //Этот пассажир выходит на конечной
        }

        for (int i = 0; i < 7; i++) {
            switch (i) {
                case 0:
                    System.out.println("Автобус выехал из парка.");
                    PHASER.arrive();//В фазе 0 всего 1 участник - автобус
                    break;
                case 6:
                    System.out.println("Автобус уехал в парк.");
                    PHASER.arriveAndDeregister();//Снимаем главный поток, ломаем барьер
                    break;
                default:
                    int currentBusStop = PHASER.getPhase();
                    System.out.println("Остановка № " + currentBusStop);

                    for (Passenger p : passengers)          //Проверяем, есть ли пассажиры на остановке
                        if (p.departure == currentBusStop) {
                            PHASER.register();//Регистрируем поток, который будет участвовать в фазах
                            p.start();        // и запускаем
                        }

                    PHASER.arriveAndAwaitAdvance();//Сообщаем о своей готовности
            }
        }
    }

    public static class Passenger extends Thread {
        private int departure;
        private int destination;

        public Passenger(int departure, int destination) {
            this.departure = departure;
            this.destination = destination;
            System.out.println(this + " ждёт на остановке № " + this.departure);
        }

        @Override
        public void run() {
            try {
                System.out.println(this + " сел в автобус.");

                while (PHASER.getPhase() < destination) //Пока автобус не приедет на нужную остановку(фазу)
                    PHASER.arriveAndAwaitAdvance();     //заявляем в каждой фазе о готовности и ждем

                Thread.sleep(1);
                System.out.println(this + " покинул автобус.");
                PHASER.arriveAndDeregister();   //Отменяем регистрацию на нужной фазе
            } catch (InterruptedException e) {
            }
        }

        @Override
        public String toString() {
            return "Пассажир{" + departure + " -> " + destination + '}';
        }
    }
}
```

Результат работы программы:
```
Пассажир{1 -> 2} ждёт на остановке № 1  
Пассажир{1 -> 5} ждёт на остановке № 1  
Пассажир{2 -> 3} ждёт на остановке № 2  
Пассажир{2 -> 5} ждёт на остановке № 2  
Пассажир{3 -> 4} ждёт на остановке № 3  
Пассажир{4 -> 5} ждёт на остановке № 4  
Пассажир{4 -> 5} ждёт на остановке № 4  
Автобус выехал из парка.  
Остановка № 1  
Пассажир{1 -> 5} сел в автобус.  
Пассажир{1 -> 2} сел в автобус.  
Остановка № 2  
Пассажир{2 -> 3} сел в автобус.  
Пассажир{1 -> 2} покинул автобус.  
Пассажир{2 -> 5} сел в автобус.  
Остановка № 3  
Пассажир{2 -> 3} покинул автобус.  
Пассажир{3 -> 4} сел в автобус.  
Остановка № 4  
Пассажир{4 -> 5} сел в автобус.  
Пассажир{3 -> 4} покинул автобус.  
Пассажир{4 -> 5} сел в автобус.  
Остановка № 5  
Пассажир{1 -> 5} покинул автобус.  
Пассажир{2 -> 5} покинул автобус.  
Пассажир{4 -> 5} покинул автобус.  
Пассажир{4 -> 5} покинул автобус.  
Автобус уехал в парк.
```
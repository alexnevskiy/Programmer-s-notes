Взято с [struchkov.dev](https://struchkov.dev/blog/ru/java-collection-framework/#%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9).
# HashSet
`HashSet` — это реализация интерфейса `Set`, которая использует [хэш-таблицу](https://garden.struchkov.dev/ru/dev/fundamental/structure/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0) для хранения элементов. Благодаря этому, **операции добавления, удаления и поиска выполняются за константное время — *O(1)* в среднем**.

**В основе `HashSet` лежит `HashMap`**.

**Когда добавляется элемент в `HashSet`, он фактически добавляется как ключ в `HashMap`**, где значением для этого ключа является константа. Таким образом, `HashSet` использует мощность хэширования `HashMap` для обеспечения уникальности элементов и быстрого доступа.
```java
public boolean add(E e) {
	return map.put(e, PRESENT) == null;
}

// Dummy value to associate with an Object in the backing Map
private static final Object PRESENT = new Object();
```

Класс `LinkedHashSet` расширяет класс `HashSet`, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись.

**Вывод:**
- **Константное время**: Операции добавления, удаления и поиска выполняются за ***O(1)***.
- **Отсутствие порядка**: Порядок элементов в `HashSet` не гарантируется.
- **Уникальность элементов**: Элементы считаются одинаковыми, если метод `equals()` возвращает `true`, а их хэш-коды совпадают.
# TreeSet
`TreeSet` — это реализация интерфейса `Set`, которая использует красно-чёрное дерево для хранения элементов. **Под капотом `TreeSet` работает с использованием `TreeMap`**, аналогично тому, как `HashSet` использует `HashMap`.

В отличие от `HashSet`, `TreeSet` гарантирует упорядоченность элементов по возрастанию (или в соответствии с указанным компаратором). Операции добавления, удаления и поиска выполняются за логарифмическое время — ***O(log(n))***, благодаря сбалансированности красно-чёрного дерева.

**Выводы:**
- **Логарифмическое время**: Операции добавления, удаления и поиска выполняются за ***O(log(n))***.
- **Упорядоченность**: Элементы хранятся в отсортированном порядке.
- **Гарантия уникальности**: Элементы считаются одинаковыми, если метод `compareTo()` или компаратор определяет их как равные.
# Сравнение реализаций
`HashSet`:
- **Добавление, удаление и поиск**: Основные операции выполняются за ***O(1)*** благодаря использованию хэш-таблицы.
- **Порядок элементов**: Не поддерживает порядок элементов.

`TreeSet:`
- **Добавление, удаление и поиск**: Эти операции занимают ***O(log(n))***, так как элементы хранятся в виде красно-чёрного дерева.
- **Порядок элементов**: Поддерживает естественный порядок элементов или порядок, заданный компаратором.

**Вывод**: Если порядок элементов важен, стоит использовать `TreeSet`, несмотря на более медленные операции. В противном случае `HashSet` является более производительным вариантом.
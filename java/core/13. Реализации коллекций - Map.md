Взято с [struchkov.dev](https://struchkov.dev/blog/ru/java-collection-framework/#%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9).
# HashMap
`HashMap` — одна из наиболее часто используемых реализаций интерфейса `Map` в Java, которая хранит данные в виде пар "ключ-значение".

Внутри `HashMap` используется **массив, где каждый элемент представляет собой связанный список (или "bucket"), состоящий из узлов (`Node`)**.

Каждый `Node` представляет собой связный список, который содержит четыре поля:
- `int hash` – хэш-код ключа.
- `K key` – ключ.
- `V value` – значение.
- `Node<K,V> next` – ссылка на следующий узел в списке (если есть коллизии).

`HashMap` имеет два ключевых параметра, которые влияют на производительность:
- **Начальная ёмкость (capacity)** — это количество сегментов (ячейка в массиве) в хеш-таблице. **По умолчанию ёмкость равна 16 и должна быть степенью двойки**.
- **Коэффициент загрузки (load factor)** — это отношение, определяющее, насколько заполненной может быть хеш-таблица, прежде чем произойдёт её расширение. **По умолчанию коэффициент загрузки равен 0.75**. **Когда количество элементов превышает произведение коэффициента загрузки и текущей ёмкости, происходит перестройка таблицы (рехеширование)**.
![hash_map](/pictures/hash_map.webp)

**Добавление элемента**:
- **Проверка на** `null`: Если ключ равен `null`, элемент добавляется в нулевую ячейку массива с помощью метода `putForNullKey()`.
- **Определение индекса бакета**: Для всех остальных ключей происходит вычисление индекса, куда элемент будет помещён в хеш-таблицу.
    - **Генерация хэш-кода**: Сначала генерируется хэш-код с использованием метода `hashCode()`.
    - **Перемешанный хэш-код**: Затем вызывается код для вычисления "перемешанного" хэш-кода, который выглядит следующим образом: `hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);` (`>>>` - беззнаковый оператор сдвига вправо, сдвигает бит в крайнюю левую позицию). Перемешанный хэш-код помогает уменьшить количество коллизий.
    - После этого переменная `hash` используется для вычисления индекса в массиве, где будет храниться элемент: `int index = (length - 1) & hash;`
- **Размещение элемента**:
    - **Если ячейка пуста**: Создаётся новый узел (`Node`), и элемент записывается в массив по вычисленному индексу.
    - **Если в ячейке уже есть элемент**: Происходит сравнение ключей с помощью метода `equals()`.
        - Если ключ не найден, создаётся новый узел и добавляется в список, что может произойти из-за коллизии (когда разные объекты имеют одинаковый хэш-код).
        - Если ключ совпадает, старое значение затирается новым.

Идеальный случай для `HashMap` — когда каждый "bucket" содержит только один элемент, обеспечивая доступ к данным за время ***O(1)***. Однако коллизии (когда несколько ключей имеют одинаковый хэш-код) неизбежны. В таких случаях элементы хранятся в виде связного списка, что может ухудшить производительность до ***O(n)***.

Когда количество элементов в одном "bucket" достигает 8, связный список преобразуется в [сбалансированное дерево](https://garden.struchkov.dev/ru/dev/fundamental/structure/%D0%A1%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) (красно-чёрное дерево). Это улучшает производительность до ***O(log(n))*** при доступе к элементам, значительно снижая время поиска и вставки.
# TreeMap
`TreeMap` — это реализация интерфейса `SortedMap`, которая расширяет возможности интерфейса `Map` и предоставляет возможность хранить пары "ключ-значение" в отсортированном порядке по ключам. В основе `TreeMap` лежит структура данных под названием **красно-чёрное дерево**.

Ключи в `TreeMap` всегда отсортированы, что делает его идеальным выбором, если требуется доступ к элементам в упорядоченном виде. А все операции — вставка, удаление и поиск — выполняются за логарифмическое время ***O(log(n))***, где ***n*** — количество элементов в дереве.

Красно-чёрное дерево — это [самобалансирующееся бинарное дерево](https://garden.struchkov.dev/ru/dev/fundamental/structure/%D0%A1%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) поиска с добавлением атрибута "цвет" для каждого узла, который может быть либо **красным**, либо **чёрным**.
![tree_map](/pictures/tree_map.png)

Требования красно-чёрного дерева:
- **Цвет узлов**: Каждый узел либо красный, либо чёрный.
- **Корень**: Корневой узел всегда чёрный.
- **Листья**: Листья дерева (так называемые null-узлы) всегда чёрные и не содержат данных.
- **Красные узлы**: У каждого красного узла оба потомка чёрные.
- **Чёрный путь**: Все пути от любого узла до его листьев содержат одинаковое количество чёрных узлов.

Эти правила обеспечивают сбалансированность дерева, что гарантирует, что высота дерева всегда остаётся близкой к логарифму от количества элементов. Благодаря этому достигается эффективность операций.
# Сравнение реализаций
`HashMap`:
- **Добавление, удаление и поиск**: Основные операции выполняются за ***O(1)*** благодаря хэш-таблице.
- **Порядок ключей**: Не поддерживает упорядоченность ключей.

`TreeMap`:
- **Добавление, удаление и поиск**: Эти операции выполняются за ***O(log(n))***, поскольку `TreeMap` использует красно-чёрное дерево.
- **Порядок ключей**: Поддерживает естественный порядок ключей или порядок, заданный компаратором.

**Вывод:** Если нужно быстрое выполнение операций без учёта порядка ключей, нужно использовать `HashMap`. Если требуется хранение ключей в отсортированном порядке, следует выбрать `TreeMap`.
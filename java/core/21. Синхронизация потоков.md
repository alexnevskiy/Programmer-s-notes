Взято с JavaRush ([1](https://javarush.com/groups/posts/1994-sinkhronizacija-potokov-operator-synchronized)), ([2](https://javarush.com/groups/posts/1998-upravlenie-potokami-metodih-volatile-i-yield)), ([3](https://javarush.com/groups/posts/4151-kofe-breyk-240-chto-takoe-atomarnihe-peremennihe-v-java-intellij-idea-poleznihe-priemih-i-plagi)), [ExamClouds](https://www.examclouds.com/ru/java/java-core-russian/thread-syncronization).
# Оператор `synchronized`
Если блок кода помечен ключевым словом `synchronized`, это значит, что **блок может выполняться только одним потоком одновременно**. **Только методы и блоки могут быть синхронизированы, но не переменные и классы**. Синхронизацию можно реализовать по-разному. Например, создать целый синхронизированный метод:
```java
public synchronized void doSomething() {

}
```

Или же написать блок кода, где синхронизация осуществляется по какому-то объекту:
```java
public class Main {

   private Object obj = new Object();

   public void doSomething() {
       synchronized (obj) {
       
       }
   }
}
```

Если один поток зашёл внутрь блока кода, который помечен оператором `synchronized`, он моментально захватывает монитор объекта, и все другие потоки, которые попытаются зайти в этот же блок или метод, вынуждены ждать, пока предыдущий поток не завершит свою работу и не освободит монитор.
## Монитор
Каждый объект в Java имеет ассоциированный с ним монитор. **Монитор** - это объект, используемый в качестве взаимоисключающей блокировки. **Когда поток исполнения запрашивает блокировку, то говорят, что он входит в монитор**.

**Только один поток исполнения может в одно, и то же время владеть монитором**. Все другие потоки исполнения, пытающиеся войти в заблокированный монитор, будут приостановлены до тех пор, пока первый поток не выйдет из монитора. Говорят, что **они ожидают монитор**.

Поток, владеющий монитором, может, если пожелает, повторно войти в него.

Если поток засыпает, то он удерживает монитор.

Поток может захватить сразу несколько мониторов.

Рассмотрим разницу между доступом к объекту без синхронизации и из синхронизированного кода. Доступ к банковскому счету без синхронизации:
![multithreading_sync_no_sync](/pictures/multithreading_sync_no_sync.png)

И с синхронизацией:
![multithreading_sync_cync](/pictures/multithreading_sync_cync.png)

Когда выполнение кода доходит до оператора `synchronized`, монитор объекта счёт блокируется, и на время его блокировки монопольный доступ к блоку кода имеет только один поток, который и произвел блокировку (Люси).

После окончания работы блока кода, монитор объекта счёт освобождается и становится доступным для других потоков.

После освобождения монитора его захватывает другой поток, а все остальные потоки продолжают ожидать его освобождения.

Синхронизируем методы из предыдущего примера для корректного совместного доступа потоков:
```java
public class AccountDanger implements Runnable {
    private Account account = new Account();

    public static void main(String[] args) {
        AccountDanger accountDanger = new AccountDanger();
        Thread one = new Thread(accountDanger);
        Thread two = new Thread(accountDanger);
        one.setName("Fred");
        two.setName("Lucy");
        one.start();
        two.start();
    }

    public void run() {
        for (int x = 0; x < 5; x++) {
            makeWithdrawal(10);
            if (account.getBalance() < 0) {
                System.out.println("account is overdrawn!");
            }
        }
    }

    private synchronized void makeWithdrawal(int amt) {
        if (account.getBalance() >= amt) {
            System.out.println(Thread.currentThread().getName()
                    + " is going to withdraw");
            try {
                Thread.sleep(500);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            account.withdraw(amt);
            System.out.println(Thread.currentThread().getName()
                    + " completes the withdrawal. The balance is "
                    + account.getBalance());
        } else {
            System.out.println("Not enough in account for "
                    + Thread.currentThread().getName()
                    + " to withdraw " + account.getBalance());
        }
    }
}
```
## Синхронизация статических методов
Статические методы тоже могут быть синхронизированы с помощью **ключевого слова `synchronized`**.

Для синхронизации статических методов используется один монитор для одного класса. Каждый загруженный в Java класс имеет соответствующий объект [класса Class](https://www.examclouds.com/ru/java/java-core-russian/class "класса Class"), представляющий этот класс. **Монитор** именно этого объекта используется для синхронизации статических методов (если они синхронизированы).
```java
public static synchronized int getCount() {
    return count;
}
```

И эквивалентный код:
```java
public static int getCount() {
    synchronized(MyClass.class) {
        return count;
    }
}
```
## Блокировка
Если поток пытается зайти в синхронизированный метод, а монитор уже захвачен, то поток блокируется по монитору объекта.

Поток попадает в специальный пул для этого конкретного объекта и должен находиться там пока монитор не будет освобожден. После этого поток возвращается в состояние `RUNNABLE`.
### Варианты блокировки
1. Потоки, вызывающие нестатические синхронизированные методы одного и того же класса, будут блокировать друг друга только если они вызваны для одного объекта.
2. Потоки, вызывающие статические синхронизированные методы одного класса, будут всегда блокировать друг друга. Они блокируются по монитору `Class` объекта. Статические синхронизированные и нестатические синхронизированные методы не будут блокировать друг друга никогда.
3. Для синхронизированных блоков нужно смотреть какой объект используется для синхронизации.
4. Блоки, синхронизированные по одному объекту, будут блокировать друг друга.
# Модификатор `volatile`
При создании многопоточных приложений мы можем столкнуться с двумя серьезными проблемами:
1. **В процессе работы многопоточного приложения разные потоки могут кэшировать значения переменных**. Возможна ситуация, когда один поток изменил значение переменной, а второй не увидел этого изменения, потому что работал со своей, кэшированной копией переменной.
2. **В Java операции чтения и записи полей всех типов, кроме `long` и `double`, являются атомарными.** `long` и `double` — самые «тяжеловесные» примитивы в Java: они весят по 64 бита. И в некоторых 32-битных платформах просто не реализована атомарность чтения и записи 64-битных переменных. Такие переменные читаются и записываются в две операции. Сначала в переменную записываются первые 32 бита, потом ещё 32.

Если мы объявляем в нашей программе какую-то переменную, со словом `volatile` это означает, что:
1. **Она всегда будет атомарно читаться и записываться**. Даже если это 64-битные `double` или `long`. **Неатомарные операции в `valotile` переменной не синхронизированы**.
2. **Java-машина не будет помещать её в кэш**. Так что ситуация, когда 10 потоков работают со своими локальными копиями исключена.
```java
public class Main {

   public volatile long x = 2222222222222222222L;

   public static void main(String[] args) {

   }
}
```
# Атомарные переменные
В Java атомарные переменные находятся в пакете` java.util.concurrent.atomic`. Учитывая, что **они предлагают потокобезопасное программирование без блокировок, это повышает эффективность и предотвращает тупиковые ситуации, которые могут возникнуть при использовании традиционных методов синхронизации**. Атомарная операция неделима. Это означает, что как только операция начинает выполняться, она выполняется до завершения, не прерываясь другим потоком. Эта атомарность жизненно важна для параллельного программирования, поскольку помогает предотвратить состояние гонки. В качестве примера рассмотрим операцию приращения (increment operation):
```java
count++;
```

Эта операция состоит из трех отдельных этапов:
1. Чтение текущего значения `count`.
2. Увеличение значения на единицу.
3. Запись обновленного значения обратно в `count`.

В многопоточной среде поток может быть вытеснен после операции чтения и до операции записи. Затем другой поток может прочитать то же самое (старое) значение `count`, увеличить его и записать обратно. Когда первый поток возобновляет выполнение и записывает свое значение обратно в `count`, он перезаписывает значение из второго потока. В результате, несмотря на то, что `count++` был вызван дважды, `count` увеличился только один раз. Атомарные переменные помогают решить эту проблему, гарантируя, что вся операция является атомарной и, следовательно, не может быть прервана.
## Атомарные классы
Java предоставляет несколько атомарных классов.
![multithreading_sync_atomic](/pictures/multithreading_sync_atomic.jpeg)

Давайте рассмотрим пример с использованием `AtomicInteger`:
```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();
```

В этом примере `incrementAndGet()` является атомарной операцией. Она увеличивает значение `count` на единицу и возвращает обновленное значение. Независимо от того, сколько потоков одновременно вызывает этот метод, он всегда будет правильно увеличивать `count`.
## Преимущества атомарных переменных
Атомарные переменные имеют несколько преимуществ:
1. **Производительность**. Атомарные переменные более эффективны, чем блоки `synchronized` или методы. Это связано с тем, что они полагаются на поддержку атомарности на аппаратном уровне (например, инструкции сравнения и замены (CAS, compare-and-swap), а не на дорогостоящие методы, основанные на блокировках.
2. **Безопасность взаимных блокировок**. Поскольку атомарные переменные не используют блокировки, они невосприимчивы к взаимоблокировкам (deadlocks)— серьезной проблеме в многопоточном программировании.
3. **Видимость**. Атомарные переменные имеют встроенные функции видимости. Когда переменная совместно используется несколькими потоками, изменения, сделанные одним потоком, немедленно видны другим потокам.
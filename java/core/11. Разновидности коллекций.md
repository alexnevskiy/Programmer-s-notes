Взято с [struchkov.dev](https://struchkov.dev/blog/ru/java-collection-framework/), [Skillbox](https://skillbox.ru/media/code/gotovimsya_k_sobesedovaniyu_chto_nuzhno_znat_o_kollektsiyakh_v_java/), [Skillfactory](https://blog.skillfactory.ru/glossary/kollekczii-java/).

**Java Collection Framework (JCF)** представляет собой набор классов и интерфейсов, предназначенных для хранения и обработки данных в оперативной памяти. JCF предоставляет удобные абстракции для работы с коллекциями объектов, что позволяет эффективно решать различные задачи в программировании.

JCF включает несколько ключевых интерфейсов, таких как `Collection`, `List`, `Set`, `Queue`, `Deque` и `Map`. Каждый из этих интерфейсов имеет свои особенности и способы работы с данными.
# Иерархия интерфейсов и классов JCF
Для эффективного использования JCF важно понимать его иерархию интерфейсов и классов.
![jcf-hierarchy](/pictures/jcf-hierarchy.webp)

**Корневым интерфейсом в JCF является `Iterable`**, который позволяет перебирать элементы коллекции.

От `Iterable` наследуется интерфейс `Collection`, который служит **основой для большинства других коллекций**. Он предоставляет базовые методы, такие как `add()`, `remove()`, `contains()`, `size()` и другие.

Интерфейс `Collection` делится на три основных подинтерфейса: `List`, `Set` и `Queue`:
- `List` представляет **упорядоченную коллекцию, которая может содержать дубликаты**. Реализациями этого интерфейса являются классы `ArrayList` и `LinkedList`.
- `Set` – коллекция, которая **не содержит дубликатов**. Примеры реализации: `HashSet`, `LinkedHashSet`, `TreeSet`.
- `Queue` используется для **хранения элементов в порядке их обработки**. Примеры реализации: `PriorityQueue`, `LinkedList`.

Интерфейс `Deque` расширяет возможности `Queue`, позволяя **добавлять и удалять элементы с обоих концов очереди**.

Ещё один важный интерфейс – `Map`. Хотя он не является наследником `Collection`, он является неотъемлемой частью JCF. `Map` **хранит данные в виде пар ключ-значение, причём ключи должны быть уникальными**. Примеры реализации: `HashMap`, `TreeMap`, `LinkedHashMap`.
# Интерфейс `Collection`
Интерфейс `Collection` расширяет `Iterable` и является основой для всех типов коллекций в Java. Он предоставляет универсальные методы для добавления, удаления, поиска элементов и получения размера коллекции, которые могут использоваться для работы с любыми типами коллекций.

Хотя **в JDK нет прямых реализаций интерфейса `Collection`**, его наследуют более специализированные интерфейсы, такие как `List`, `Set`, и другие. В рамках этих интерфейсов доступны следующие основные методы:
- `boolean add(E item);` – Добавляет элемент в коллекцию. Возвращает `true`, если коллекция изменилась в результате вызова.
- `void clear()` – Удаляет все элементы из коллекции.
- `boolean contains(Object item)` – Проверяет, содержит ли коллекция указанный элемент.
- `boolean isEmpty()` – Возвращает `true`, если коллекция пуста.
- `boolean remove(Object item)` – Удаляет один экземпляр указанного элемента из коллекции, если он присутствует.
- `int size()` – Возвращает количество элементов в коллекции.

Эти методы составляют основу работы с коллекциями в Java.
# Интерфейс `List`
Интерфейс `List` расширяет `Collection` и представляет упорядоченную коллекцию, которая **может содержать дубликаты элементов**. В дополнение к методам из интерфейса `Collection`, `List` предоставляет дополнительные методы для работы с индексированными элементами.

Рассмотрим основные методы, предоставляемые интерфейсом `List`:
- `void add(int index, object obj)` **–** Вставляет элемент `obj` на позицию `index`. Элементы, начиная с этой позиции, сдвигаются вправо.
- `boolean addAll(int index, Collection coll)` **–** Вставляет все элементы коллекции `coll` в список, начиная с позиции `index`.
- `object get(int index)` **–** Возвращает элемент, находящийся на указанной позиции.
- `int indexOf(Object obj)` **–**  Возвращает индекс первого вхождения указанного элемента или -1, если элемент не найден.
- `int lastindexOf(object obj)` **–** Возвращает индекс последнего вхождения указанного элемента или -1, если элемент не найден.
- `Object set(int index, object obj)` **–** Заменяет элемент на указанной позиции на указанный элемент.
- `List subList(int from, int to)` **–** Возвращает часть списка от позиции `from` включительно до позиции `to` исключительно.

Кроме стандартного итератора, списки могут возвращать `ListIterator`, который позволяет выполнять такие операции, как вставка, замена элементов и двунаправленная навигация по коллекции.
# Интерфейс `Set`
Интерфейс `Set` расширяет интерфейс `Collection` и предоставляет набор методов для **работы с неупорядоченными коллекциями**. Каждый элемент в множестве уникален. Уникальность элементов проверяется с использованием метода `equals().`

Основные методы интерфейса `Set`:
- `add(Object o)` **–** Добавляет элемент в множество, если его там ещё нет. Если элемент уже присутствует, множество остаётся неизменным, и метод возвращает `false`.
- `addAll(Collection c)` **–** Добавляет все элементы коллекции в множество, если они отсутствуют.
- `clear()` **–** Удаляет все элементы из множества.
- `contains(Object o)` **–** Проверяет наличие элемента в множестве. Возвращает `true`, если элемент найден.
- `containsAll(Collection c)` **–** Проверяет, содержатся ли все элементы переданной коллекции в множестве. Возвращает `true`, если все элементы присутствуют.
- `isEmpty()` **–** Возвращает `true`, если множество не содержит элементов.
- `remove(Object o)` **–** Удаляет указанный элемент из множества, если он присутствует.
- `size()` **–** Возвращает количество элементов в множестве.

В отличие от интерфейса `List`, интерфейс **`Set` не предоставляет методов для доступа к элементам по индексу, так как наборы не упорядочены**.

Следует быть особенно осторожными при добавлении изменяемых объектов в `Set`. **Если объект изменяется после добавления в множество так, что это влияет на результат метода `equals()`, поведение множества может стать непредсказуемым.** Рассмотрим пример, где это может вызвать проблемы:
```java
Person mark = new Person("Mark", 12);
Person mike = new Person("Mike", 13);

Set<Person> people = new HashSet<>(Set.of(mike, mark));
System.out.println(people);

mike.setAge(12);
mike.setName("Mark");

System.out.println(people);

Person mark2 = new Person("Mark", 12);
people.add(mark2);

System.out.println(people);
```

Результат:
```
[Person{name='Mike', age=13}, Person{name='Mark', age=12}]
[Person{name='Mark', age=12}, Person{name='Mark', age=12}]
[Person{name='Mark', age=12}, Person{name='Mark', age=12}]
```

В этом примере мы создаем два объекта с разными именами, добавляем их в множество, а затем изменяем один объект так, что он становится равен другому. В результате может возникнуть ситуация, когда множество содержит дубликаты с точки зрения логики, хотя по правилам `Set` этого быть не должно.
# Интерфейс `Queue`
Интерфейс `Queue` в Java Collection Framework предоставляет **функциональность очереди — структуры данных, работающей по принципу “первый пришел, первый обслужен” (FIFO)**. Интерфейс `Queue` расширяет интерфейс `Collection` и предоставляет методы для управления элементами в порядке их поступления.

Основные методы интерфейса `Queue`:
- `boolean offer(E obj)` **—** Вставляет указанный элемент в очередь, если это возможно сделать немедленно, не нарушая ограничений. Если элемент не может быть добавлен, возвращает `false`, в отличие от метода `add()`, который в такой ситуации генерирует исключение.
- `E peek()` — Возвращает, но не удаляет головной элемент очереди, или возвращает `null`, если очередь пуста.
- `E poll()` — Удаляет и возвращает головной элемент очереди, или возвращает `null`, если очередь пуста.
- `E remove()` — Удаляет и возвращает головной элемент очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
# Интерфейс `Deque`
Интерфейс `Deque` (Double Ended Queue) расширяет `Queue` и представляет **двустороннюю очередь, где элементы могут быть добавлены и удалены как с начала, так и с конца**.

Основные методы интерфейса `Deque`:
- Добавление элементов:
    - `void addFirst(E obj)` **—** Вставляет элемент в начало очереди.
    - `void addLast(E obj)` **—** Вставляет элемент в конец очереди.
    - `boolean offerFirst(E obj)` **—** Добавляет элемент в начало, возвращая `true`, если элемент успешно добавлен, или `false`, если добавление не удалось.
    - `boolean offerLast(E obj)` **—** Добавляет элемент в конец, возвращая `true`, если элемент добавлен, или `false`, если добавление не удалось.
- Получение элементов
    - `E getFirst()` **—** Возвращает первый элемент, не удаляя его. Если очередь пуста, генерирует исключение `NoSuchElementException`.
    - `E getLast()` **—** Возвращает последний элемент, не удаляя его. Если очередь пуста, генерирует исключение `NoSuchElementException`.
    - `E peekFirst()` **—** Возвращает первый элемент, не удаляя его. Если очередь пуста, возвращает `null`.
    - `E peekLast()` **—** Возвращает последний элемент, не удаляя его. Если очередь пуста, возвращает `null`.
- Удаление элементов
    - `E pollFirst()` **—** Удаляет и возвращает первый элемент. Если очередь пуста, возвращает `null`.
    - `E pollLast()` **—** Удаляет и возвращает последний элемент. Если очередь пуста, возвращает `null`.
    - `E pop()` **—** Удаляет и возвращает первый элемент. Если очередь пуста, генерирует исключение `NoSuchElementException`.
    - `E removeFirst()` **—** Удаляет и возвращает первый элемент. Если очередь пуста, генерирует исключение `NoSuchElementException`.
    - `E removeLast()` **—** Удаляет и возвращает последний элемент. Если очередь пуста, генерирует исключение `NoSuchElementException`.
    - `boolean removeFirstOccurrence(Object obj)` **—** Удаляет первый встреченный элемент, равный `obj`. Возвращает `true`, если элемент был удалён.
    - `boolean removeLastOccurrence(Object obj)` **—** Удаляет последний встреченный элемент, равный `obj`. Возвращает `true`, если элемент был удалён.
# Интерфейс `Map`
Интерфейс `Map` в Java представляет **коллекцию пар “ключ-значение”, где каждому ключу сопоставлено одно значение**. `Map` отличается от других интерфейсов коллекций тем, что **не является потомком интерфейса `Collection`**. Однако, он остается частью Java Collection Framework и предоставляет мощные инструменты для работы с ассоциативными массивами.

Основные методы интерфейса `Map`:
- `boolean containsKey(Object k)` – Возвращает `true`, если коллекция содержит указанный ключ `k`.
- `boolean containsValue(Object v)` – Возвращает `true`, если коллекция содержит указанное значение `v`.
- `Set<Map.Entry<K, V>> entrySet()` – Возвращает набор элементов коллекции. Каждый элемент представляет собой объект `Map.Entry`, содержащий пару “ключ-значение”.
- `V get(Object k)` – Возвращает значение, связанное с ключом `k`. Если такого ключа нет, возвращает `null`.
- `V put(K k, V v)` – Добавляет в коллекцию новую пару “ключ-значение” или заменяет значение для уже существующего ключа. Возвращает предыдущее значение для ключа, если оно было, иначе возвращает `null`.
- `V putIfAbsent(K k, V v)` – Добавляет пару “ключ-значение” только если такого ключа ещё нет в карте.
- `Set<K> keySet()` – Возвращает набор всех ключей коллекции.
- `Collection<V> values()` – Возвращает список всех значений коллекции.
- `void putAll(Map<? extends K, ? extends V> map)` – Добавляет в коллекцию все элементы из коллекции `map`.
- `V remove(Object k)` – Удаляет пару с указанным ключом `k`.
- `int size()` – Возвращает количество пар в коллекции.
## Интерфейс `Map.Entry`
Интерфейс `Map.Entry` представляет **пару “ключ-значение” внутри коллекции**. Он предоставляет методы для получения и изменения ключа и значения.

Методы интерфейса `Map.Entry`:
- `V getValue()` – Возвращает значение.
- `K getKey()` – Возвращает ключ.
- `V setValue(V v)` – Устанавливает новое значение для текущего ключа.

Предположим, что у вас есть коллекция, которая хранит данные о “холопах” и их богатстве. В какой-то момент вам нужно собрать ренту с тех, чьё богатство превышает 100 золотых. Для этого удобно использовать метод `entrySet()`, чтобы обойти коллекцию и изменить значения.
```java
final Map<String, Integer> customers = new HashMap<>(
	Map.of("Холоп 1", 100, "Холоп 2", 20, "Холоп 3", 200)
);

final Set<Map.Entry<String, Integer>> entries = customers.entrySet();
int coffers = 0;

for (Map.Entry<String, Integer> entry : entries) {
	final Integer wealth = entry.getValue();
	if (wealth > 100) {
		entry.setValue(wealth - 10);
		coffers += 10;
	}
}

System.out.println("\nКазна пополнилась на " + coffers + " золотых, Миллорд!");
System.out.println(customers.values());
```

Этот код использует метод `entrySet()`, чтобы получить набор элементов карты, затем с помощью цикла проходит по каждому элементу, проверяя, превышает ли богатство “холопа” 100 золотых. Если условие выполняется, у холопа вычитается 10 золотых, и сумма добавляется в казну. Метод `setValue()` позволяет обновить значение в карте.
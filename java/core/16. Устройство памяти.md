Взято с [struchkov.dev](https://struchkov.dev/blog/ru/memory-in-java/), [TopJava](https://topjava.ru/blog/stack-and-heap-in-java), [JavaRush](https://javarush.com/quests/lectures/questservlets.level18.lecture00), [Habr](https://habr.com/ru/articles/549176/).
# Стек (Stack)
**Стек** — это область памяти, в которой функции хранят свои переменные и информацию, необходимую для выполнения.

Представьте стек как стопку подносов в ресторане: вы можете добавить поднос сверху (push) или взять верхний поднос (pop). Точно так же, **когда вызывается функция, её локальные переменные и информация о вызове помещаются на вершину стека, а при завершении функции эти данные удаляются с вершины**.
![stack](pictures/stack.gif)

**Стек обеспечивает быстрый доступ к данным и автоматическое управление памятью, но его размер ограничен**. Если программа потребляет больше стековой памяти, чем доступно, это может привести к ошибке переполнения стека `java.lang.StackOverFlowError`.

Когда вызывается функция, для неё выделяется блок памяти на вершине стека. Этот блок, известный как "**фрейм стека**", содержит пространство для всех локальных переменных функции, а также информацию, такую как адрес возврата — место в коде, куда программа должна вернуться после завершения функции.

Когда одна функция вызывает другую, **для новой функции выделяется собственный фрейм стека**, и она становится текущей активной функцией. По завершении работы функции её фрейм стека удаляется, и управление передаётся обратно вызывающей функции.

**Все потоки**, работающие в JVM, имеют **свой стек**. Стек в свою очередь держит информацию о том, какие методы вызвал поток.

Стек потока содержит в себе **все локальные переменные**, требующиеся для выполнения методов из стека потока. Поток может получить доступ только к своему стеку. Локальные переменные не видны остальным потокам, только потоку, создавшему их. В ситуации, когда два потока выполняют один и тот же код, они оба создают свои локальные переменные. Таким образом, каждый поток имеет свою версию каждой локальной переменной.

**Все локальные переменные примитивных типов (`boolean`, `byte`, `short`, `char`, `int`, `long`, `float`, `double`) полностью хранятся в стеке потоков и не видны другим потокам**. Один поток может передать копию примитивной переменной другому потоку, но не может совместно использовать примитивную локальную переменную.

Особенности работы:
- **LIFO (Last-In, First-Out)**: Стек работает по принципу "последним пришёл — первым ушёл". Это означает, что последняя вызванная функция будет первой, которая завершит работу и вернёт управление.
- **Автоматическое управление памятью**: Когда функция завершает выполнение, её локальные переменные автоматически удаляются. Это упрощает управление памятью, так как нет необходимости в явном освобождении памяти.
- **Ограниченный размер**: Размер стека обычно ограничен. Если программа попытается использовать больше памяти, чем доступно в стеке, это приведёт к ошибке переполнения стека.
- **Быстрый доступ**: Доступ к данным в стеке обычно быстрее, чем к данным в куче, поскольку стек локализован в памяти, и данные из него могут загружаться в кэш процессора для ускоренного доступа.
- **Потокобезопасность**: Является потокобезопасным, поскольку для каждого потока создаётся свой отдельный стек.
# Куча (Heap)
**Куча** — это область памяти, используемая для динамического распределения во время выполнения программы. В отличие от стека, **данные в куче могут существовать дольше, чем отдельные вызовы функций, а объёмы памяти, выделяемой в куче, обычно гораздо больше, чем в стеке**.

**Динамическое управление памятью подразумевает процесс выделения и освобождения памяти в куче во время работы программы**. Когда программе требуется память для хранения данных, она может запросить у операционной системы блок памяти в куче, достаточно большой для этих данных.

**Однако важно помнить, что, в отличие от стека, память в куче не освобождается автоматически**. Когда данные больше не нужны, программа должна явно указать операционной системе, что эту память можно освободить для использования другими процессами. Этот процесс называется **"освобождение памяти".**

**Если программа продолжает использовать память, не освобождая её, это может привести к "утечке памяти"**, когда значительные объёмы памяти заняты данными, которые уже не нужны. Это может вызвать снижение производительности и, в конечном итоге, привести к ошибкам, когда вся доступная память будет исчерпана.

Для наглядности представим стек и кучу. Серые объекты потеряли свою связь со стеком, и их нужно удалить, чтобы освободить память для новых объектов.
![heap](pictures/heap.webp)

Хранение данных:
- В случае, когда **локальная переменная примитивного типа**, она хранится в стеке потока.
- **Локальная переменная** также может быть **ссылкой на объект**. В этом случае ссылка (локальная переменная) хранится в стеке потоков, но сам объект хранится в куче.
- **Объект содержит методы, эти методы содержат локальные переменные**. Эти локальные переменные также хранятся в стеке потоков, даже если объект, которому принадлежит метод, хранится в куче.
- **Переменные-члены объекта** хранятся в куче вместе с самим объектом. Это верно как в случае, когда переменная-член имеет примитивный тип, так и в том случае, если она является ссылкой на объект.
- **Статические переменные класса** также хранятся в куче вместе с определением класса.

**Область памяти разбита на несколько более мелких частей, называемых поколениями:**
1. **Young Generation** — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора  
2. **Old (Tenured) Generation** — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают определённого порога «возраста», они перемещаются в Old Generation  
3. **Permanent Generation** — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8 данная область памяти была упразднена.

Мы можем управлять размерами кучи в зависимости от наших требований.
![memory_management](/pictures/memory_management.webp)

Особенности работы:
- **Динамическое распределение памяти**: Куча позволяет программе запрашивать необходимый объём памяти динамически и использовать его до тех пор, пока программа не освободит его.
- **Долговечность данных**: Память в куче не освобождается автоматически, поэтому данные могут существовать до тех пор, пока не будут явно удалены, что позволяет им пережить вызовы функций.
- **Управление памятью**: Работа с кучей требует тщательного управления памятью. Утечки памяти могут стать проблемой, если память не освобождается своевременно.
- **Медленный доступ**: Доступ к данным в куче может быть медленнее по сравнению со стеком, из-за более сложного управления и отсутствия локализации данных.
- **Отсутствие потокобезопасности**: В отличие от стека, куча не является потокобезопасной и её необходимо контролировать, правильно синхронизируя код.
## Взаимодействие с объектами
К объектам в куче могут обращаться все потоки, которые имеют ссылку на объект. **Если поток имеет доступ к объекту, то он может получить доступ к переменным этого объекта**. **Если два потока вызывают метод для одного и того же объекта одновременно, они оба будут иметь доступ к переменным-членам объекта**, но **каждый поток будет иметь свою собственную копию локальных переменных**.
![jvm_memory_scheme](/pictures/jvm_memory_scheme.jpeg)

Два потока имеют набор локальных переменных. `Local Variable 2` указывает на общий объект в куче (`Object 3`). Каждый из потоков имеет свою копию локальной переменной со своей ссылкой. Их ссылки являются локальными переменными и поэтому хранятся в стеках потоков. Тем не менее, две разные ссылки указывают на один и тот же объект в куче.

Обрати внимание, что общий `Object 3` имеет ссылки на `Object 2` и `Object 4` как переменные-члены (показано стрелками). Через эти ссылки два потока могут получить доступ к `Object 2` и `Object 4`.

На диаграмме также показана локальная переменная (`Local variable 1` из `methodTwo`). Каждая её копия содержит разные ссылки, которые указывают на два разных объекта (`Object 1` и `Object 5`), а не на один и тот же. Теоретически оба потока могут обращаться как к `Object 1`, так и к `Object 5`, если они имеют ссылки на оба этих объекта. Но на диаграмме выше каждый поток имеет ссылку только на один из двух объектов.
## Типы ссылок
В языке программирования Java используются разные типы ссылок: **сильные, слабые, мягкие** и **фантомные** ссылки. Разница между типами ссылок заключается в том, что объекты в куче, на которые они ссылаются, имеют право на сборку мусора по различным критериям.
### Сильная ссылка
Это самые популярные ссылочные типы, к которым мы все привыкли. **Объект в куче не удаляется сборщиком мусора, пока на него указывает сильная ссылка или если он явно доступен через цепочку сильных ссылок**.
### Слабая ссылка
Попросту говоря, **слабая ссылка на объект из кучи, скорее всего, не сохранится после следующего процесса сборки мусора**. Слабая ссылка создаётся следующим образом:
```java
WeakReference<StringBuilder> reference = new WeakReference<>(new StringBuilder());
```

Хорошим вариантом использования слабых ссылок являются сценарии кеширования. Представьте, что вы извлекаете некоторые данные и хотите, чтобы они также были сохранены в памяти - те же данные могут быть запрошены снова. С другой стороны, вы не уверены, когда и будут ли эти данные запрашиваться снова. Таким образом, вы можете сохранить слабую ссылку на него, и в случае запуска сборщика мусора, возможно, он уничтожит ваш объект в куче. Следовательно, через некоторое время, если вы захотите получить объект, на который вы ссылаетесь, вы можете внезапно получить `null` значение. **Хорошей** реализацией сценариев кеширования является коллекция `WeakHashMap<K, V>`. Если мы откроем `WeakHashMap` класс в Java API, мы увидим, что его записи фактически расширяют `WeakReference`класс и используют его поле `ref` в качестве ключа отображения (`Map`):
```java
/**    
	* The entries in this hash table extend WeakReference, using its main ref    
	* field as the key.
*/

private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {    
	V value;
```

После сбора мусора ключа из `WeakHashMap` вся запись удаляется из карты.
### Мягкая ссылка
Эти типы ссылок используются для более чувствительных к памяти сценариев, поскольку **они будут собираться сборщиком мусора только тогда, когда вашему приложению не хватает памяти**. Следовательно, пока нет критической необходимости в освобождении некоторого места, сборщик мусора не будет касаться легко доступных объектов. Java гарантирует, что все объекты, на которые имеются мягкие ссылки, будут очищены до того, как будет выдано исключение `OutOfMemoryError`. В документации Javadocs говорится, что **«все мягкие ссылки на мягко достижимые объекты гарантированно очищены до того, как виртуальная машина выдаст `OutOfMemoryError`»**.

Подобно слабым ссылкам, мягкая ссылка создаётся следующим образом:
```java
SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());
```
### Фантомная ссылка
Используется для **планирования посмертных действий по очистке, поскольку мы точно знаем, что объекты больше не живы**. Используется только с очередью ссылок, поскольку `get()`метод таких ссылок всегда будет возвращаться `null`**.** Эти типы ссылок считаются предпочтительными для **финализаторов.**
# Сборщик мусора
**Сборщик мусора (Garbage Collector, GC)** — это процесс в виртуальной машине Java (JVM), который автоматически освобождает память, выделенную для объектов, которые больше не используются. Этот процесс происходит следующим образом:
- **Маркировка**: Сборщик мусора начинает "маркировать" все объекты в куче, которые больше не доступны из корней приложения. "Корни" обычно включают в себя стек вызова и глобальные ссылки. Если на объект в куче не существует активной ссылки из этих "корней", он считается недоступным.
- **Удаление**: После того как недоступные объекты были помечены, сборщик мусора освобождает память, которую они занимали.

Несмотря на автоматизацию управления памятью, неэффективное использование ресурсов может по-прежнему привести к проблемам. Например, **если приложение постоянно создаёт новые объекты и сохраняет на них ссылки, это может привести к утечке памяти**, когда куча постепенно заполняется, и система больше не может выделить память для новых объектов. В таких случаях приложение может завершиться с ошибкой `OutOfMemoryError`.
## Процесс сборки мусора
Как обсуждалось ранее, в зависимости от типа ссылки, которую переменная из стека содержит на объект из кучи, в определённый момент времени этот объект становится подходящим для сборщика мусора.
![gc_objects](/pictures/gc_objects.jpeg)
Например, все объекты, отмеченные красным цветом, могут быть собраны сборщиком мусора. Вы можете заметить, что в куче есть объект, который имеет строгие ссылки на другие объекты, которые также находятся в куче (например, это может быть список, который имеет ссылки на его элементы, или объект, имеющий два поля типа, на которые есть ссылки). Однако, поскольку ссылка из стека потеряна, к ней больше нельзя получить доступ, так что это тоже мусор.

Чтобы углубиться в детали, давайте сначала упомянем несколько вещей:
- **Этот процесс запускается автоматически Java**, и Java решает, запускать или нет этот процесс.
- Это **дорогостоящий процесс**. При запуске сборщика мусора все потоки в вашем приложении приостанавливаются (в зависимости от типа GC, который будет обсуждаться позже).
- Это **более сложный процесс, чем просто сбор мусора и освобождение памяти**.

Несмотря на то, что Java решает, когда запускать сборщик мусора, вы можете явно вызвать `System.gc()`и ожидать, что сборщик мусора будет запускаться при выполнении этой строки кода, верно?

Это ошибочное предположение.

Вы только как бы просите Java запустить сборщик мусора, но, опять же, Java решать, делать это или нет. В любом случае **явно вызывать `System.gc()`не рекомендуется**.

Поскольку это довольно сложный процесс и может повлиять на вашу производительность, он реализован разумно. Для этого используется так называемый процесс «Mark and Sweep». Java анализирует переменные из стека и «отмечает» все объекты, которые необходимо поддерживать в рабочем состоянии. Затем все неиспользуемые объекты очищаются.

Так что на самом деле Java не собирает мусор. Фактически, чем больше мусора и чем меньше объектов помечены как живые, тем быстрее идёт процесс. Чтобы сделать это ещё более оптимизированным, память кучи на самом деле состоит из нескольких частей. Мы можем визуализировать использование памяти и другие полезные вещи с помощью **JVisualVM**, инструмента, поставляемого с Java JDK. Единственное, что вам нужно сделать, это установить плагин с именем **Visual GC**, который позволяет увидеть, как на самом деле структурирована память. Давайте немного увеличим масштаб и разберём общую картину:
![visual_gc](/pictures/visual_gc.jpeg)

Когда объект создаётся, он размещается в пространстве **Eden (1)**. Поскольку пространство Eden не такое уж большое, оно заполняется довольно быстро. Сборщик мусора работает в пространстве Eden и помечает объекты как живые.

Если объект выживает в процессе сборки мусора, он перемещается в так называемое пространство выжившего **Survivor 0(2)**. Во второй раз, когда сборщик мусора запускается в пространстве Eden, он перемещает все уцелевшие объекты в пространство **Survivor 1(3)**. Кроме того, всё, что в настоящее время находится на **Survivor 0(2)**, перемещается в пространство **Survivor 1(3)**.

Если объект выживает в течение X раундов сборки мусора (X зависит от реализации JVM, в моём случае это 8), скорее всего, он выживет вечно и перемещается в пространство **Old(4)**.

Принимая всё сказанное выше, если вы посмотрите на **график сборщика мусора (6)**, каждый раз, когда он запускается, вы можете увидеть, что объекты переключаются на пространство выживших и что пространство Eden увеличивалось. И так далее. Старое поколение также может быть обработано сборщиком мусора, но, поскольку это большая часть памяти по сравнению с пространством Eden, это происходит не так часто. **Метапространство (5)** используется для хранения метаданных о ваших загруженных классах в JVM.

Представленное изображение на самом деле является приложением Java 8. До Java 8 структура памяти была немного другой. Метапространство на самом деле называется PermGen область. Например, в Java 6 это пространство также хранит память для пула строк. Поэтому, если в вашем приложении Java 6 слишком много строк, оно может аварийно завершить работу.
## Типы сборщиков мусора
Фактически, JVM имеет три типа сборщиков мусора, и программист может выбрать, какой из них следует использовать. По умолчанию Java выбирает используемый тип сборщика мусора в зависимости от базового оборудования.
 1. **Serial GC** (**Последовательный сборщик** **мусора)** - однониточный коллектор. В основном относится к небольшим приложениям с небольшим использованием данных. Можно включить, указав параметр командной строки: `-XX:+UseSerialGC.`
 2. **Parallel GC** (**Параллельный сборщик** **мусора**) - даже по названию, разница между последовательным и параллельным будет заключаться в том, что параллельный сборщик мусора использует несколько потоков для выполнения процесса сбора мусора. Этот тип GC также известен как сборщик производительности. Его можно включить, явно указав параметр: `-XX:+UseParallelGC.`
 3. **Mostly concurrent GC** (**В основном параллельный сборщик** **мусора)**. Ранее упоминалось, что процесс сбора мусора на самом деле довольно дорогостоящий, и когда он выполняется, все потоки приостанавливаются. Однако у нас есть в основном параллельный тип GC, который утверждает, что он работает одновременно с приложением. Однако есть причина, по которой он «в основном» параллелен. Он не работает на 100% одновременно с приложением. Есть период времени, на который цепочки приостанавливаются. Тем не менее, пауза делается как можно короче для достижения наилучшей производительности сборщика мусора. На самом деле существует 2 типа в основном параллельных сборщиков мусора:
	 1. **Garbage First** - высокая производительность с разумным временем паузы приложения. Включено с опцией: `-XX:+UseG1GC.`
	 2. **Concurrent Mark Sweep** (**Параллельное сканирование отметок)** - время паузы приложения сведено к минимуму. Он может быть использован с помощью опции: `-XX:+UseConcMarkSweepGC`. Начиная с JDK 9, этот тип GC объявлен устаревшим.
## Советы и приёмы
- Чтобы минимизировать объём памяти, максимально ограничьте область видимости переменных. Помните, что каждый раз, когда выскакивает верхняя область видимости из стека, ссылки из этой области теряются, и это может сделать объекты пригодными для сбора мусора.
- Явно устанавливайте в `null` устаревшие ссылки. Это сделает объекты, на которые ссылаются, подходящими для сбора мусора.
- Избегайте финализаторов (finalizer). Они замедляют процесс и ничего не гарантируют. Фантомные ссылки предпочтительны для работы по очистке памяти.
- Не используйте сильные ссылки там, где можно применить слабые или мягкие ссылки. Наиболее распространенные ошибки памяти - это сценарии кэширования, когда данные хранятся в памяти, даже если они могут не понадобиться.
- Настройте JVM в соответствии с требованиями вашего приложения. Явно укажите размер кучи для JVM при запуске приложения. Процесс выделения памяти также является дорогостоящим, поэтому выделите разумный начальный и максимальный объём памяти для кучи. Если вы знаете его, то не имеет смысла начинать с небольшого начального размера кучи с самого начала, JVM расширит это пространство памяти. Указание параметров памяти выполняется с помощью следующих параметров:
    - Начальный размер кучи `-Xms512m`- установите начальный размер кучи на 512 мегабайт.
    - Максимальный размер кучи `-Xmx1024m`- установите максимальный размер кучи 1024 мегабайта.
    - Размер стека потоков `-Xss1m`- установите размер стека потоков равным 1 мегабайту.
    - Размер поколения `-Xmn256m`- установите размер поколения 256 мегабайт.
- Если приложение Java выдаёт ошибку `OutOfMemoryError`и вам нужна дополнительная информация для обнаружения утечки, запустите процесс с `–XX:HeapDumpOnOutOfMemory`параметром, который создаст файл дампа кучи, когда эта ошибка произойдёт в следующий раз.
- Используйте опцию `-verbose:gc`, чтобы получить вывод процесса сборки мусора. Каждый раз, когда происходит сборка мусора, будет генерироваться вывод.
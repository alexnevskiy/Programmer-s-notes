Взято с [Proselyte](https://proselyte.net/hibernate-caching-basics/).

**Hibernate** — одна из самых популярных Java-библиотек для работы с реляционными базами данных. Hibernate предоставляет прозрачное и эффективное управление данными, упрощая процесс разработки приложений. Одним из ключевых аспектов производительности Hibernate является кэширование.
![hibernate_cache](/pictures/hibernate_cache.webp)
# Кэш первого уровня
**Кэш первого уровня активен по умолчанию и автоматически связан с каждой сессией (Session) в Hibernate.** Он предназначен для кэширования объектов сущностей на протяжении одной транзакции или сессии. **Основная цель кэша первого уровня** — уменьшить количество запросов к базе данных и обеспечить повторное использование объектов в рамках одной сессии.

**Когда Hibernate выполняет запрос к базе данных и получает данные, он сохраняет результаты в кэше первого уровня.** Если в рамках одной сессии будет выполнен запрос на те же данные, Hibernate сначала проверит наличие данных в кэше первого уровня. Если данные найдены, Hibernate вернёт их из кэша, минуя запрос к базе данных.  

В качестве **ключа** здесь хранится комбинация идентификатора сущности и её класса (например, `EntityClass`, `EntityId`).  **Значение** – экземпляр сущности, который был загружен из базы данных или создан в рамках текущей сессии.
## Взаимодействие с объектами сущностей
При сохранении нового объекта сущности с помощью метода `save()`, `persist()` или `saveOrUpdate()`, **объект добавляется в кэш первого уровня**. В дальнейшем, любые изменения в этом объекте будут отслеживаться в рамках текущей сессии.

При обновлении объекта сущности с помощью метода `update()` или `merge()`, Hibernate **сначала проверяет наличие объекта в кэше первого уровня**. Если объект найден, его состояние обновляется в кэше. В противном случае объект загружается из базы данных, обновляется и сохраняется в кэше первого уровня.

При удалении объекта сущности с помощью метода `delete()`, объект удаляется из кэша первого уровня. Это гарантирует согласованность состояния объектов в рамках текущей сессии.
## Стратегии использования
- Используйте долгоживущие сессии (Long-Running Sessions) с осторожностью, так как объекты в кэше первого уровня могут продолжать удерживаться в памяти, что может привести к проблемам с производительностью и потреблением ресурсов. Регулярно закрывайте и открывайте сессии для избегания излишнего накопления данных в кэше первого уровня.
- В случае возникновения проблем с производительностью или потреблением памяти из-за кэша первого уровня, можно явно очистить кэш с помощью метода `session.clear()`. Однако стоит быть осторожным, так как при вызове этого метода все несохраненные изменения объектов сущностей будут потеряны.
- Используйте метод `session.evict(Object entity)` для удаления конкретного объекта сущности из кэша первого уровня. Это может быть полезно, если вам известно, что данный объект больше не будет использоваться в текущей сессии, и его можно безопасно удалить из кэша.
- Регулярно используйте метод `session.flush()` для принудительной синхронизации состояния объектов сущностей в кэше первого уровня с базой данных. Это гарантирует, что все изменения, выполненные на объектах сущностей в текущей сессии, будут сохранены в базе данных.
# Кэш второго уровня
**Кэш второго уровня является дополнительным механизмом кэширования в Hibernate, позволяющим разделить кэшированные данные между несколькими сессиями.**

В отличие от кэша первого уровня, который активен по умолчанию и связан с каждой сессией, кэш второго уровня является опциональным и может быть настроен в зависимости от требований приложения. **Кэш второго уровня позволяет кэшировать объекты сущностей на уровне приложения, что может снизить нагрузку на базу данных и улучшить производительность приложения.**

Кэш второго уровня используется для хранения объектов сущностей между разными сессиями. **Когда Hibernate выполняет запрос к базе данных, он сначала проверяет наличие объекта сущности в кэше первого уровня. Если объект не найден, Hibernate проверяет кэш второго уровня. Если объект найден в кэше второго уровня, он будет загружен в кэш первого уровня и возвращён пользователю.** Если объект отсутствует и в кэше второго уровня, Hibernate выполнит запрос к базе данных, а полученные данные будут сохранены в обоих уровнях кэширования.  

В качестве **ключа** здесь хранится комбинация идентификатора сущности и её класса (например, `EntityClass`, `EntityId`).  **Значение** – данные сущности, сериализованные в определённый формат (например, двоичный, JSON или XML). Формат сериализации зависит от конкретной реализации кэша второго уровня.
## Взаимодействие с объектами сущностей
Когда объект сущности сохраняется или обновляется, его **состояние автоматически обновляется в кэше второго уровня**. Это гарантирует, что данные в кэше остаются актуальными и согласованными с базой данных.

При удалении объекта сущности, он также **удаляется из кэша второго уровня**. Это обеспечивает согласованность данных между базой данных и кэшем.
## Настройка кэша второго уровня
Для активации кэша второго уровня в Hibernate необходимо выполнить следующие действия:
1. Включите кэш второго уровня, добавив в файл конфигурации Hibernate (*hibernate.cfg.xml*) следующую строку:
```xml
<property name="hibernate.cache.use_second_level_cache">true</property>
```
2. Выберите провайдера кэша второго уровня, такого как EhCache, Infinispan, или Hazelcast, и добавьте соответствующие настройки в файл конфигурации Hibernate. Например, для EhCache:
```xml
<property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
```
3. Укажите для каких сущностей должен быть включён кэш второго уровня. Это можно сделать с помощью аннотации `@Cache` в коде сущностей или добавлением соответствующих настроек в файл отображения (mapping file). Например, с использованием аннотации:
```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class MyEntity { ... }
```
## Стратегии использования
- Используйте кэш второго уровня для сущностей, которые часто используются и редко изменяются. Это может снизить нагрузку на базу данных и улучшить производительность приложения.
- Определите подходящую стратегию кэширования (`CacheConcurrencyStrategy`) в зависимости от природы сущностей и требований приложения. Например, для сущностей, которые часто используются и изменяются, можно использовать стратегию `READ_WRITE`. Для сущностей, которые часто используются и редко изменяются, можно использовать стратегию `NONSTRICT_READ_WRITE` или `READ_ONLY`.
- Отслеживайте и настраивайте настройки кэша второго уровня в соответствии с потребностями приложения. Внимательно следите за статистикой использования кэша, чтобы определить оптимальный размер кэша и время истечения (TTL) для хранения объектов сущностей.
# Кэш запросов
**Кэш запросов предназначен для хранения результатов выполнения HQL- и SQL-запросов.** Важно отметить, что **кэш запросов хранит только идентификаторы объектов сущностей, а не сами объекты.** Для получения объектов Hibernate использует механизм кэширования сущностей (First-Level и Second-Level Cache).

**Когда запрос выполняется впервые, Hibernate сохраняет его результат (идентификаторы сущностей) в кэше запросов.** При повторном выполнении того же запроса Hibernate проверяет наличие результатов в кэше запросов. Если результаты найдены, Hibernate загружает соответствующие объекты сущностей из кэша сущностей и возвращает их пользователю. **В противном случае запрос выполняется, и полученные данные сохраняются в кэше запросов и кэше сущностей.**

В качестве **ключа** здесь хранится хэш запроса, включая SQL-запрос, параметры запроса и настройки кэширования (например, регион кэширования). **Значение** – список идентификаторов сущностей, участвующих в результате запроса. Эти идентификаторы используются для получения фактических данных сущностей из кэша второго уровня или базы данных, если данные не найдены в кэше.
## Настройка кэша запросов
Для активации кэша запросов в Hibernate необходимо выполнить следующие действия:
1. Включите кэш запросов, добавив в файл конфигурации Hibernate (*hibernate.cfg.xml*) следующую строку:
```xml
<property name="hibernate.cache.use_query_cache">true</property>
```
2. **Убедитесь, что второй уровень кэширования также включён, поскольку кэш запросов зависит от него.**
3. Включите кэширование для конкретных запросов, используя метод `setCacheable(true)`:
```java
List<MyEntity> results = session
	.createQuery("FROM MyEntity WHERE someProperty = :value")
    .setParameter("value", value)
    .setCacheable(true)
    .list();
```
## Рекомендации по использованию
- Используйте кэш запросов для часто выполняемых запросов с небольшим количеством вариантов результатов. Это может снизить нагрузку на базу данных и улучшить производительность приложения.
- Не используйте кэш запросов для запросов с большим количеством возможных результатов, так как это может привести к неэффективному использованию памяти и снижению производительности.
Взято с [TopJava](https://topjava.ru/blog/razlichiya-mezhdu-abstraktnymi-klassami-i-interfeysami-v-java) и [Habr](https://habr.com/ru/companies/otus/articles/707762/).
# Интерфейс
**Интерфейс** - это контракт, который реализуется в некотором классе. То есть интерфейс определяет только поведение, он не сообщает ничего про объект, который будет его реализовывать. У интерфейса не может быть состояния, поэтому в нём нельзя использовать изменяемые поля экземпляра. В интерфейсе могут быть только неизменяемые `final`-поля.
# Абстрактный класс
**Абстрактный класс** похож на обычный класс. В абстрактном классе также можно определить поля и методы, в то же время нельзя создать объект или экземпляр абстрактного класса. Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал.
# Отличия
Фундаментальная разница между интерфейсом и абстрактным классом заключается в том, что **интерфейс определяет только поведение**. Он не сообщает ничего про объект, который будет его реализовывать. 

Например, такое поведение как «движение» может быть применимо к разным типам объектов: машина, кот, котировки курса и т. д. Эти объекты не имеют ничего общего, кроме того, что они могут двигаться.  

Перефразируем немного иначе — если существует «движущийся» объект, то глядя на реализованный им [[#Интерфейс|интерфейс]], мы не сможем понять, какой именно тип объекта имеется ввиду. Это может быть машина, кот, котировка курса валют и много других вариантов.  

Если перенести это поведение в код, написанный на языке Java, то получится следующее:  
```java
interface Movable {
    void move();
}
```

[[#Абстрактный класс]] описывает некий абстрактный объект (автомобиль, человека, кота и т. д.), а не только поведение.  

Если мы рассуждаем про абстрактный «автомобиль», то в нашей голове сразу формируется картинка с объектом. Мы сразу понимаем, что автомобиль содержит двигатель, колеса и может двигаться, поворачивать, ускоряться или тормозить. Он также будет иметь поля для хранения внутренних деталей, таких как мотор, колеса и тормоза.

При этом кот и котировка курса валют не могут быть автомобилем, даже если они также могут двигаться.  

На основе вышесказанного создадим класс `Automobile`:  
```java
abstract class Automobile {

    Engine engine;
    Wheels[] wheels;
    Gears[] gears;

    abstract void move();
    abstract void turn();
    abstract void accelerate();
    abstract void brake();
}
```

Интерфейс и абстрактный класс — понятия не взаимозаменяемые. Даже если абстрактный класс с абстрактными методами выглядит подобно интерфейсу, а интерфейс, с его методами по умолчанию, подобен абстрактному классу с методами, имеющими реализации, то это все равно будут два фундаментально разных понятия. **Если нам нужно поведение — необходимо использовать интерфейс. Если речь про концептуальный объект — мы должны использовать абстрактный класс.**
## Синтаксис создания
При создании **абстрактного класса** указывается ключевое слово `abstract`, а при определении **интерфейса** — `interface`.  

Пример абстрактного класса: 
```java
public abstract class MyAbstractClass {

    // поля и конструкторы
    // абстрактные методы
    // методы с реализацией
}
```

Пример интерфейса: 
```java
public interface MyInterface {

    // объявление констант
    // методы без реализации
    // статические методы
    // методы по умолчанию (default)
    // приватные методы
}
```
## Синтаксис использования
При наследовании от **абстрактного класса** используется ключевое слово `extends` (с англ. «расширяет»), а при реализации **интерфейса** — `implements` (с англ. «реализует»).  

В приведенном ниже коде класс `MyClass` расширяет `MyAbstractClass`:  
```java
public class MyClass extends MyAbstractClass {

    // реализация абстрактных методов
    // иной код
}
```

Ниже класс `MyClass` реализует интерфейс `MyInterface`:  
```java
public class MyClass implements MyInterface {

	// реализация методов интерфейса
	// иной код
}
```
Класс может одновременно и наследоваться от абстрактного класса (только одного) и реализовать один или множество интерфейсов.  

Например, класс `MyClass` реализует интерфейс `MyInterface`, `MyInterface_2` и `MyInterface_3`:  
```java
class MyClass extends MyAbstractClass implements MyInterface,   
        MyInterface_2, MyInterface_3 {
    
    // реализация абстрактных методов абстрактного класса
    // реализация методов из интерфейсов  
    // иной код
}
```
## Наличие конструктора
Невозможно создать экземпляр **абстрактного класса**. Однако объявить и определить в нём конструктор мы можем. В противном случае за нас это сделает компилятор, создав конструктор по умолчанию. Без него код просто не скомпилируется, поскольку при создании конкретного класса первым оператором будет неявный вызов `super()` конструктора суперкласса, в данном случае абстрактного.  

Добавим в абстрактный класс `MyAbstractClass` конструктор:  
```java
public abstract class MyAbstractClass {

    public MyAbstractClass() {
        System.out.println("Конструктор из MyAbstractClass");
    }
}
```

Также добавим конструктор в `MyClass`:  
```java
public class MyClass extends MyAbstractClass {

    public MyClass() {
        System.out.println("Конструктор из MyClass");
    }
}
```

В классе `Main` создадим объект и запустим программу:  
```java
public class Main {

    public static void main(String[] args) {
        MyAbstractClass myObject = new MyClass();
    }
}
```

Результат выполнения программы:
```
Конструктор из MyAbstractClass
Конструктор из MyClass
```

**Для интерфейсов понятия «конструктор» не существует.**
## Типы переменных
Все переменные в **интерфейсах** неявно являются `public` `static` `final` (т.е. константами).

Рассмотрим следующий код:  
```java
public interface MyInterface {

    // эта строка не скомпилируется
    int value_1;   
                 
    int value_2 = 1;
    public final int value_3 = 1;
    static int value_4 = 1;
    public final static int value_5 = 1;
    static final int value_6 = 1;    
}
```

Поскольку полю `value_1` не присвоено конкретное значение, а оно является неявно `final`, код с такой строкой не скомпилируется. Остальные строки не вызовут ошибок, т.к. `public` `static` `final` можно не указывать (если указать, то IDE выделит их серым цветом, подчёркивая «избыточность»).  

В **абстрактных классах** переменные могут быть любыми — абстрактность класса не накладывает ограничений.  

Например, следующий код является корректным:  
```java
public abstract class MyAbstractClass {

    int value_1;
    int value_2 = 1;
    private static int value_3;
    final int value_4 = 1;
    protected static final int value_5 = 1;
}
```
## Модификаторы доступа методов
Модификаторы доступа для **абстрактных классов** могут быть любыми. При этом, все методы, кроме абстрактных, должны иметь реализацию.  

А вот в случае с **интерфейсами** модификаторы доступа могут быть только двух типов, `public` и `private` (последний — начиная с Java 9).  

Причём `private` может быть применим только к методам, имеющим реализацию, которые, в свою очередь, могут использоваться только методами по умолчанию (default-методы), находящимися в интерфейсе. Класс, реализующий интерфейс, не будет иметь к ним доступ. Методы интерфейса без реализации являются неявно `public`, поэтому этот модификатор можно не писать.  

Рассмотрим следующий код:  
```java
public interface MyInterface_2 {

    void publicAbstractMethod_1();

    public void publicAbstractMethod_2();

    void publicAbstractMethod_3();
    
    private void privateMethod() {
        // Реализация метода
    }
}
```

Методы `publicAbstractMethod_1` и `publicAbstractMethod_3` являются неявно `public`.
## Методы с реализацией
Для **абстрактного класса** все методы, кроме абстрактных, должны иметь реализацию.  

Для **интерфейсов**, начиная с Java 8, вводится понятие метода по умолчанию (default-методы). Такие методы, во-первых, должны иметь реализацию в интерфейсе, а во-вторых, помечены ключевым словом `default`. Они также являются неявно `public`. При этом они не должны в обязательном порядке иметь реализацию в реализующем интерфейс классе, но могут быть в нём переопределены.

Также, начиная с Java 8, в интерфейсах допустимы статические методы, которые неявно являются `public`, но могут быть явно `private`. Т.е. если указать модификатор доступа `private`, метод будет приватным, а если ничего не указывать, то публичным.  

Например, код ниже скомпилируется:  
```java
public interface MyInterface_3 {

    default void defaultMethod() {
        // Реализация метода
    }

    public default void defaultMethod_2() {
        // Реализация метода
    }

    private static void privateStaticMethod() {
        // Реализация метода
    }

    public static void publicStaticMethod_1() {
        // Реализация метода
    }

    static void publicStaticMethod_2() {
        // Реализация метода
    }
}
```
## Наследование
**Интерфейс** не может реализовывать интерфейс, не может наследовать абстрактный класс, но может наследовать (используя ключевое слово `extends`) множество других интерфейсов.

**Абстрактный класс** может наследовать как обычный класс, так и абстрактный. В обоих случаях это будет только один класс (в Java нет множественного наследования классов).  

В то же время абстрактный класс также может реализовать до 65 535 интерфейсов (это связано с ограничением константы `interfaces_count` в структуре `ClassFile`).
# Рекомендации к применению
В соответствии с [рекомендациями](https://dev.java/learn/inheritance/abstract-classes/) Oracle **абстрактный класс** нужно использовать в следующих случаях:
- Необходимо выделить общий код между несколькими тесно связанными классами  
    _Пояснение:_ это типовой рефакторинг, целью которого является устранение дублирования кода.

- Мы ожидаем, что классы, расширяющие абстрактный класс, имеют много общих методов, полей или требуют модификаторов доступа, отличных от `public` (`protected` и `private`)  
    _Пояснение:_ ранее мы писали, что в интерфейсах методы, имеющие реализацию (помеченные ключевым словом `default`), являются неявно `public`. Если же метод, имеющий реализацию, помечен явно как `private`, то он не сможет быть использован в классах, реализующих этот интерфейс, а только в других методах интерфейса. Поэтому, если нам нужны методы с модификаторами доступа не `public`, мы должны использовать абстрактный класс.

- Мы хотим объявить не `static` или не `final` поля для изменения состояния объекта.  
    _Пояснение:_ ранее мы писали, что все переменные в интерфейсах неявно являются `public` `static` `final` — из-за чего они не могут быть изменены.

Для использования **интерфейсов** существуют следующие причины:  
- Планируется, что несвязанные между собой классы будут реализовывать интерфейс. Например, интерфейсы `Comparable` и `Cloneable` реализуются многими несвязанными между собой классами.  
	_Пояснение:_ как мы выяснили ранее, концептуальное назначение интерфейса — описание «поведения», а не «состояния» (в отличие от абстрактного класса). Соответственно, реализовать это поведение могут любые классы, несвязанные между собой, которые просто должны что-то «уметь» делать или «как-то» себя вести.

- Требуется детализировать или определить поведение определенного типа данных, но при этом мы не хотим беспокоиться о том, кто реализует его поведение.  
    _Пояснение:_ пояснение к прошлому пункту также актуально и для этого — нам все равно, какие классы будут реализовывать наш интерфейс и в каких пакетах находятся. Мы просто хотим, чтобы они вели себя в соответствии с «нашим контрактом», прописанным в интерфейсе в виде методов без реализации.

- Мы хотим воспользоваться преимуществами множественного наследования типов
Взято с [RefactoringGuru](https://refactoring.guru/ru/design-patterns/behavioral-patterns), [Java Design Patterns](https://java-design-patterns.com/patterns/#read-online).

Решают задачи эффективного и безопасного взаимодействия между объектами программы.
# Цепочка обязанностей
**Также известен как**: CoR, Chain of Command, Chain of Responsibility

**Сложность:** ⭐⭐
**Популярность:** ⭐

**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

Избавляет от жёсткой привязки отправителя запроса к его получателю, позволяя выстраивать цепь из различных обработчиков динамически.

**Применимость:** Паттерн встречается в Java не так уж часто, так как для его применения нужна цепь объектов, например, связанный список.

Область применения цепочки обязанностей — всевозможные обработчики событий, последовательные проверки доступа и прочее.

Примеры Цепочки обязанностей в стандартных библиотеках Java:
- [`java.util.logging.Logger#log()`](http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log-java.util.logging.Level-java.lang.String-)
- [`javax.servlet.Filter#doFilter()`](http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-)

**Признаки применения паттерна:** Цепочку обязанностей можно определить по спискам обработчиков или проверок, через которые пропускаются запросы. Особенно если порядок следования обработчиков важен.
![pattern_chain_of_responsibility](/pictures/pattern_chain_of_responsibility.png)
## Проблема
Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла.
![pattern_chain_of_responsibility_problem1](/pictures/pattern_chain_of_responsibility_problem1.png)

На протяжении следующих нескольких месяцев вам пришлось добавить ещё несколько таких последовательных проверок.
- Кто-то резонно заметил, что неплохо бы проверять данные, передаваемые в запросе перед тем, как вносить их в систему — вдруг запрос содержит данные о покупке несуществующих продуктов.
- Кто-то предложил блокировать массовые отправки формы с одним и тем же логином, чтобы предотвратить подбор паролей ботами.
- Кто-то заметил, что форму заказа неплохо бы доставать из кеша, если она уже была однажды показана.
![pattern_chain_of_responsibility_problem2](/pictures/pattern_chain_of_responsibility_problem2.png)

С каждой новой «фичей» код проверок, выглядящий как большой клубок условных операторов, всё больше и больше раздувался. При изменении одного правила приходилось трогать код всех проверок. А для того, чтобы применить проверки к другим ресурсам, пришлось продублировать их код в других классах.

Поддерживать такой код стало не только очень хлопотно, но и затратно. И вот в один прекрасный день вы получаете задачу рефакторинга...
## Решение
Как и многие другие поведенческие паттерны, **Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты.** В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

А теперь по-настоящему важный этап. **Паттерн предлагает связать объекты обработчиков в одну цепь.** Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, вы можете быть уверены, что все объекты в цепи смогут его обработать. При этом длина цепочки не имеет никакого значения.

И последний штрих. **Обработчик не обязательно должен передавать запрос дальше**, причём эта особенность может быть использована по-разному.

В примере с фильтрацией доступа обработчики прерывают дальнейшие проверки, если текущая проверка не прошла. Ведь нет смысла тратить попусту ресурсы, если и так понятно, что с запросом что-то не так.
![pattern_chain_of_responsibility_solution1](/pictures/pattern_chain_of_responsibility_solution1.png)

Но есть и другой подход, при котором **обработчики прерывают цепь только когда они могут обработать запрос**. В этом случае запрос движется по цепи, пока не найдётся обработчик, который может его обработать. Очень часто такой подход используется для передачи событий, создаваемых классами графического интерфейса в результате взаимодействия с пользователем.

Например, когда пользователь кликает по кнопке, программа выстраивает цепочку из объекта этой кнопки, всех её родительских элементов и общего окна приложения на конце. Событие клика передаётся по этой цепи до тех пор, пока не найдётся объект, способный его обработать. Этот пример примечателен ещё и тем, что цепочку всегда можно выделить из древовидной структуры объектов, в которую обычно и свёрнуты элементы пользовательского интерфейса.
![pattern_chain_of_responsibility_solution2](/pictures/pattern_chain_of_responsibility_solution2.png)

Очень важно, чтобы **все объекты цепочки имели общий интерфейс**. Обычно каждому конкретному обработчику достаточно знать только то, что следующий объект в цепи имеет метод `выполнить`. Благодаря этому связи между объектами цепочки будут более гибкими. Кроме того, вы сможете формировать цепочки на лету из разнообразных объектов, не привязываясь к конкретным классам.
## Структура
![pattern_chain_of_responsibility_structure](/pictures/pattern_chain_of_responsibility_structure.png)

1. **Обработчик** определяет общий для всех конкретных обработчиков интерфейс. Обычно достаточно описать единственный метод обработки запросов, но иногда здесь может быть объявлен и метод выставления следующего обработчика.
2. **Базовый обработчик** — опциональный класс, который позволяет избавиться от дублирования одного и того же кода во всех конкретных обработчиках.
   
   Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля. Также здесь можно реализовать базовый метод обработки, который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.
3. **Конкретные обработчики** содержат код обработки запросов. При получении запроса каждый обработчик решает, может ли он обработать запрос, а также стоит ли передать его следующему объекту.
   
   В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми, получив все нужные детали через параметры конструктора.
4. **Клиент** может либо сформировать цепочку обработчиков единожды, либо перестраивать её динамически, в зависимости от логики программы. Клиент может отправлять запросы любому из объектов цепочки, не обязательно первому из них.
## Пример кода
В этом Java-примере король орков отдаёт приказы, которые обрабатываются цепочкой команд, представляющей шаблон Chain of Responsibility.

Король орков отдаёт громкие приказы своей армии. Ближе всех реагирует командир, затем офицер, а потом солдат. Командир, офицер и солдат образуют цепочку обязанностей.

Во-первых, у нас есть класс `Request`:
```java
@Getter
public class Request {

    private final RequestType requestType;
    private final String requestDescription;
    private boolean handled;

    public Request(final RequestType requestType, final String requestDescription) {
        this.requestType = Objects.requireNonNull(requestType);
        this.requestDescription = Objects.requireNonNull(requestDescription);
    }

    public void markHandled() {
        this.handled = true;
    }

    @Override
    public String toString() {
        return getRequestDescription();
    }
}

public enum RequestType {
    DEFEND_CASTLE, TORTURE_PRISONER, COLLECT_TAX
}
```

Далее мы покажем иерархию `RequestHandler`.
```java
public interface RequestHandler {

    boolean canHandleRequest(Request req);

    int getPriority();

    void handle(Request req);

    String name();
}

@Slf4j
public class OrcCommander implements RequestHandler {
    @Override
    public boolean canHandleRequest(Request req) {
        return req.getRequestType() == RequestType.DEFEND_CASTLE;
    }

    @Override
    public int getPriority() {
        return 2;
    }

    @Override
    public void handle(Request req) {
        req.markHandled();
        LOGGER.info("{} handling request \"{}\"", name(), req);
    }

    @Override
    public String name() {
        return "Orc commander";
    }
}

// OrcOfficer and OrcSoldier are defined similarly as OrcCommander ...
```

`OrcKing` отдаёт приказы и формирует цепь.
```java
public class OrcKing {

    private List<RequestHandler> handlers;

    public OrcKing() {
        buildChain();
    }

    private void buildChain() {
        handlers = Arrays.asList(new OrcCommander(), new OrcOfficer(), new OrcSoldier());
    }

    public void makeRequest(Request req) {
        handlers
			.stream()
			.sorted(Comparator.comparing(RequestHandler::getPriority))
			.filter(handler -> handler.canHandleRequest(req))
			.findFirst()
			.ifPresent(handler -> handler.handle(req));
    }
}
```

Цепочка обязанностей в действии.
```java
public static void main(String[] args) {
    var king = new OrcKing();
    king.makeRequest(new Request(RequestType.DEFEND_CASTLE, "defend castle"));
    king.makeRequest(new Request(RequestType.TORTURE_PRISONER, "torture prisoner"));
    king.makeRequest(new Request(RequestType.COLLECT_TAX, "collect tax"));
}
```

Вывод программы:
```
Orc commander handling request "defend castle"
Orc officer handling request "torture prisoner"
Orc soldier handling request "collect tax"
```
## Применимость
- **Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.**
С помощью Цепочки обязанностей вы можете связать потенциальных обработчиков в одну цепь и при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.

- **Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.**
Цепочка обязанностей позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.

- **Когда набор объектов, способных обработать запрос, должен задаваться динамически.**
В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.
# Команда
**Также известен как**: Действие, Транзакция, Action, Command

**Сложность:** ⭐⭐
**Популярность:** ⭐⭐

**Команда** — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

Это позволяет откладывать выполнение команд, выстраивать их в очереди, а также хранить историю и делать отмену.

**Применимость:** Паттерн можно часто встретить в Java-коде, особенно когда нужно откладывать выполнение команд, выстраивать их в очереди, а также хранить историю и делать отмену.

Примеры Команд в стандартных библиотеках Java:
- Все реализации [`java.lang.Runnable`](http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html)
- Все реализации [`javax.swing.Action`](http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html)

**Признаки применения паттерна:** Классы команд построены вокруг одного действия и имеют очень узкий контекст. Объекты команд часто подаются в обработчики событий элементов GUI. Практически любая реализация отмены использует принципа команд.
![pattern_command](/pictures/pattern_command.png)
## Проблема
Представьте, что вы работаете над программой текстового редактора. Дело как раз подошло к разработке панели управления. Вы создали класс красивых `Кнопок` и хотите использовать его для всех кнопок приложения, начиная от панели управления, заканчивая простыми кнопками в диалогах.
![pattern_command_problem1](/pictures/pattern_command_problem1.png)

Все эти кнопки, хоть и выглядят схоже, но делают разные вещи. Поэтому возникает вопрос: куда поместить код обработчиков кликов по этим кнопкам? Самым простым решением было бы создать подклассы для каждой кнопки и переопределить в них метод действия под разные задачи.
![pattern_command_problem2](/pictures/pattern_command_problem2.png)

Но скоро стало понятно, что такой подход никуда не годится. Во-первых, получается очень много подклассов. Во-вторых, код кнопок, относящийся к графическому интерфейсу, начинает зависеть от классов бизнес-логики, которая довольно часто меняется.
![pattern_command_problem3](/pictures/pattern_command_problem3.png)

Но самое обидное ещё впереди. Ведь некоторые операции, например, «сохранить», можно вызывать из нескольких мест: нажав кнопку на панели управления, вызвав контекстное меню или просто нажав клавиши `Ctrl+S`. Когда в программе были только кнопки, код сохранения имелся только в подклассе `SaveButton`. Но теперь его придётся продублировать ещё в два класса.
## Решение
Хорошие программы обычно структурированы в виде слоёв. Самый распространённый пример — слои пользовательского интерфейса и бизнес-логики. Первый всего лишь рисует красивую картинку для пользователя. Но когда нужно сделать что-то важное, интерфейс «просит» слой бизнес-логики заняться этим.

В реальности это выглядит так: один из объектов интерфейса напрямую вызывает метод одного из объектов бизнес-логики, передавая в него какие-то параметры.
![pattern_command_solution1](/pictures/pattern_command_solution1.png)

Паттерн Команда предлагает больше не отправлять такие вызовы напрямую. Вместо этого **каждый вызов, отличающийся от других, следует завернуть в собственный класс с единственным методом, который и будет осуществлять вызов**. Такие объекты называют **командами**.

К объекту интерфейса можно будет привязать объект команды, который знает, кому и в каком виде следует отправлять запросы. Когда объект интерфейса будет готов передать запрос, он вызовет метод команды, а та — позаботится обо всём остальном.
![pattern_command_solution2](/pictures/pattern_command_solution2.png)

Классы команд можно объединить под общим интерфейсом c единственным методом запуска. После этого одни и те же отправители смогут работать с различными командами, не привязываясь к их классам. Даже больше: команды можно будет взаимозаменять на лету, изменяя итоговое поведение отправителей.

Параметры, с которыми должен быть вызван метод объекта получателя, можно загодя сохранить в полях объекта-команды. Благодаря этому, объекты, отправляющие запросы, могут не беспокоиться о том, чтобы собрать необходимые для получателя данные. Более того, они теперь вообще не знают, кто будет получателем запроса. Вся эта информация скрыта внутри команды.
![pattern_command_solution3](/pictures/pattern_command_solution3.png)

После применения Команды в нашем примере с текстовым редактором вам больше не потребуется создавать уйму подклассов кнопок под разные действия. Будет достаточно единственного класса с полем для хранения объекта команды.

Используя общий интерфейс команд, объекты кнопок будут ссылаться на объекты команд различных типов. При нажатии кнопки будут делегировать работу связанным командам, а команды — перенаправлять вызовы тем или иным объектам бизнес-логики.

Так же можно поступить и с контекстным меню, и с горячими клавишами. Они будут привязаны к тем же объектам команд, что и кнопки, избавляя классы от дублирования.

Таким образом, команды станут гибкой прослойкой между пользовательским интерфейсом и бизнес-логикой. И это лишь малая доля пользы, которую может принести паттерн Команда!
## Структура
![pattern_command_structure](/pictures/pattern_command_structure.png)

1. **Отправитель** хранит ссылку на объект команды и обращается к нему, когда нужно выполнить какое-то действие. Отправитель работает с командами только через их общий интерфейс. Он не знает, какую конкретно команду использует, так как получает готовый объект команды от клиента.
2. **Команда** описывает общий для всех конкретных команд интерфейс. Обычно здесь описан всего один метод для запуска команды.
3. **Конкретные команды** реализуют различные запросы, следуя общему интерфейсу команд. Обычно команда не делает всю работу самостоятельно, а лишь передаёт вызов получателю, которым является один из объектов бизнес-логики.
   
   Параметры, с которыми команда обращается к получателю, следует хранить в виде полей. В большинстве случаев объекты команд можно сделать неизменяемыми, передавая в них все необходимые параметры только через конструктор.
4. **Получатель** содержит бизнес-логику программы. В этой роли может выступать практически любой объект. Обычно команды перенаправляют вызовы получателям. Но иногда, чтобы упростить программу, вы можете избавиться от получателей, «слив» их код в классы команд.
5. **Клиент** создаёт объекты конкретных команд, передавая в них все необходимые параметры, среди которых могут быть и ссылки на объекты получателей. После этого клиент связывает объекты отправителей с созданными командами.
## Пример кода
В паттерне Command объекты используются для инкапсуляции всей информации, необходимой для выполнения действия или запуска события в последующее время. Этот паттерн особенно полезен для реализации функции отмены действий в приложениях.

В нашем примере `Wizard` накладывает заклинания на `Goblin`. Каждое заклинание - это объект команды, который может быть выполнен и отменён, что демонстрирует основные принципы паттерна Command в Java. Заклинания выполняются на гоблине по очереди. Первое заклинание уменьшает гоблина, а второе делает его невидимым. Затем волшебник поочередно меняет заклинания местами. Каждое заклинание здесь - это командный объект, который можно отменить.

Начнем с класса `Wizard`.
```java
@Slf4j
public class Wizard {

    private final Deque<Runnable> undoStack = new LinkedList<>();
    private final Deque<Runnable> redoStack = new LinkedList<>();

    public Wizard() {
    }

    public void castSpell(Runnable runnable) {
        runnable.run();
        undoStack.offerLast(runnable);
    }

    public void undoLastSpell() {
        if (!undoStack.isEmpty()) {
            var previousSpell = undoStack.pollLast();
            redoStack.offerLast(previousSpell);
            previousSpell.run();
        }
    }

    public void redoLastSpell() {
        if (!redoStack.isEmpty()) {
            var previousSpell = redoStack.pollLast();
            undoStack.offerLast(previousSpell);
            previousSpell.run();
        }
    }

    @Override
    public String toString() {
        return "Wizard";
    }
}
```

Далее у нас есть `Goblin`, который является `Target` заклинаний.
```java
@Slf4j
@Getter
@Setter
public abstract class Target {

    private Size size;

    private Visibility visibility;

    public void printStatus() {
        LOGGER.info("{}, [size={}] [visibility={}]", this, getSize(), getVisibility());
    }

    public void changeSize() {
        var oldSize = getSize() == Size.NORMAL ? Size.SMALL : Size.NORMAL;
        setSize(oldSize);
    }

    public void changeVisibility() {
        var visible = getVisibility() == Visibility.INVISIBLE
                ? Visibility.VISIBLE : Visibility.INVISIBLE;
        setVisibility(visible);
    }
}
```
```java
public class Goblin extends Target {

    public Goblin() {
        setSize(Size.NORMAL);
        setVisibility(Visibility.VISIBLE);
    }

    @Override
    public String toString() {
        return "Goblin";
    }
}
```

Наконец, мы можем показать полный пример произнесения заклинаний `Wizard`.
```java
public static void main(String[] args) {
    var wizard = new Wizard();
    var goblin = new Goblin();

    goblin.printStatus();

    wizard.castSpell(goblin::changeSize);
    goblin.printStatus();

    wizard.castSpell(goblin::changeVisibility);
    goblin.printStatus();

    wizard.undoLastSpell();
    goblin.printStatus();

    wizard.undoLastSpell();
    goblin.printStatus();

    wizard.redoLastSpell();
    goblin.printStatus();

    wizard.redoLastSpell();
    goblin.printStatus();
}
```

Вывод программы:
```
Goblin, [size=normal] [visibility=visible]
Goblin, [size=small] [visibility=visible]
Goblin, [size=small] [visibility=invisible]
Goblin, [size=small] [visibility=visible]
Goblin, [size=normal] [visibility=visible]
Goblin, [size=small] [visibility=visible]
Goblin, [size=small] [visibility=invisible]
```
## Применимость
- **Когда вы хотите параметризовать объекты выполняемым действием.**
Команда превращает операции в объекты. А объекты можно передавать, хранить и взаимозаменять внутри других объектов.

Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать меню в разных приложениях, не меняя каждый раз код ваших классов. Применив паттерн, пользователям не придётся изменять классы меню, вместо этого они будут конфигурировать объекты меню различными командами.

- **Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.**
Как и любые другие объекты, команды можно сериализовать, то есть превратить в строку, чтобы потом сохранить в файл или базу данных. Затем в любой удобный момент её можно достать обратно, снова превратить в объект команды и выполнить. Таким же образом команды можно передавать по сети, логировать или выполнять на удалённом сервере.

- **Когда вам нужна операция отмены.**
Главная вещь, которая вам нужна, чтобы иметь возможность отмены операций, — это хранение истории. Среди многих способов, которыми можно это сделать, паттерн Команда является, пожалуй, самым популярным.

История команд выглядит как стек, в который попадают все выполненные объекты команд. Каждая команда перед выполнением операции сохраняет текущее состояние объекта, с которым она будет работать. После выполнения операции копия команды попадает в стек истории, все ещё неся в себе сохранённое состояние объекта. Если потребуется отмена, программа возьмёт последнюю команду из истории и возобновит сохранённое в ней состояние.

Этот способ имеет две особенности. Во-первых, точное состояние объектов не так-то просто сохранить, ведь часть его может быть приватным. Но с этим может помочь справиться паттерн Снимок.

Во-вторых, копии состояния могут занимать довольно много оперативной памяти. Поэтому иногда можно прибегнуть к альтернативной реализации, когда вместо восстановления старого состояния команда выполняет обратное действие. Недостаток этого способа в сложности (а иногда и невозможности) реализации обратного действия.
# Итератор
**Также известен как**: Iterator

**Сложность:** ⭐⭐
**Популярность:** ⭐⭐⭐

**Итератор** — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

Благодаря Итератору, клиент может обходить разные коллекции одним и тем же способом, используя единый интерфейс итераторов.

**Применимость:** Паттерн можно часто встретить в Java-коде, особенно в программах, работающих с разными типами коллекций, и где требуется обход разных сущностей.

Примеры Итератора в стандартных библиотеках Java:
- Все реализации [`java.util.Iterator`](http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html) (среди прочего также [`java.util.Scanner`](http://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html)).
- Все реализации [`java.util.Enumeration`](http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html).

**Признаки применения паттерна:** Итератор легко определить по методам навигации (например, получения следующего/предыдущего элемента и т. д.). Код использующий итератор зачастую вообще не имеет ссылок на коллекцию, с которой работает итератор. Итератор либо принимает коллекцию в параметрах конструктора при создании, либо возвращается самой коллекцией.
![pattern_iterator](/pictures/pattern_iterator.png)
## Проблема
Коллекции — самая распространённая структура данных, которую вы можете встретить в программировании. Это набор объектов, собранный в одну кучу по каким-то критериям.
![pattern_iterator_problem1](/pictures/pattern_iterator_problem1.png)

Большинство коллекций выглядят как обычный список элементов. Но есть и экзотические коллекции, построенные на основе деревьев, графов и других сложных структур данных.

Но как бы ни была структурирована коллекция, пользователь должен иметь возможность последовательно обходить её элементы, чтобы проделывать с ними какие-то действия.

Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход дерева в глубину, но завтра потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке.
![pattern_iterator_problem2](/pictures/pattern_iterator_problem2.png)

Добавляя всё новые алгоритмы в код коллекции, вы понемногу размываете её основную задачу, которая заключается в эффективном хранении данных. Некоторые алгоритмы могут быть и вовсе слишком «заточены» под определённое приложение и смотреться дико в общем классе коллекции.
## Решение
Идея паттерна Итератор состоит в том, чтобы **вынести поведение обхода коллекции из самой коллекции в отдельный класс**.
![pattern_iterator_solution](/pictures/pattern_iterator_solution.png)

Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом.

К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.
## Структура
![pattern_iterator_structure](/pictures/pattern_iterator_structure.png)

1. **Итератор** описывает интерфейс для доступа и обхода элементов коллекции.
2. **Конкретный итератор** реализует алгоритм обхода какой-то конкретной коллекции. Объект итератора должен сам отслеживать текущую позицию при обходе коллекции, чтобы отдельные итераторы могли обходить одну и ту же коллекцию независимо.
3. **Коллекция** описывает интерфейс получения итератора из коллекции. Как мы уже говорили, коллекции не всегда являются списком. Это может быть и база данных, и удалённое API, и даже дерево Компоновщика. Поэтому сама коллекция может создавать итераторы, так как она знает, какие именно итераторы способны с ней работать.
4. **Конкретная коллекция** возвращает новый экземпляр определённого конкретного итератора, связав его с текущим объектом коллекции. Обратите внимание, что сигнатура метода возвращает интерфейс итератора. Это позволяет клиенту не зависеть от конкретных классов итераторов.
5. **Клиент** работает со всеми объектами через интерфейсы коллекции и итератора. Так клиентский код не зависит от конкретных классов, что позволяет применять различные итераторы, не изменяя существующий код программы.
   
   В общем случае клиенты не создают объекты итераторов, а получают их из коллекций. Тем не менее, если клиенту требуется специальный итератор, он всегда может создать его самостоятельно.
## Пример кода
Главный класс в нашем примере паттерна проектирования Iterator на Java - это `TreasureChest`, содержащий предметы. Это демонстрирует, как реализовать и использовать итераторы для эффективного обхода коллекций в Java.
```java
public class TreasureChest {

	private final List<Item> items;

	public TreasureChest() {
		items = List.of(
			new Item(ItemType.POTION, "Potion of courage"),
			new Item(ItemType.RING, "Ring of shadows"),
			new Item(ItemType.POTION, "Potion of wisdom"),
			new Item(ItemType.POTION, "Potion of blood"),
			new Item(ItemType.WEAPON, "Sword of silver +1"),
			new Item(ItemType.POTION, "Potion of rust"),
			new Item(ItemType.POTION, "Potion of healing"),
			new Item(ItemType.RING, "Ring of armor"),
			new Item(ItemType.WEAPON, "Steel halberd"),
			new Item(ItemType.WEAPON, "Dagger of poison"));
	}
	
	public Iterator<Item> iterator(ItemType itemType) {
		return new TreasureChestItemIterator(this, itemType);
	}
	
	public List<Item> getItems() {
		return new ArrayList<>(items);
	}
}
```

Вот класс `Item`:
```java
public class Item {

	private ItemType type;
	private final String name;
	
	public Item(ItemType type, String name) {
		this.setType(type);
		this.name = name;
	}
	
	@Override
	public String toString() {
		return name;
	}
	
	public ItemType getType() {
		return type;
	}
	
	public final void setType(ItemType type) {
		this.type = type;
	}
}

public enum ItemType {
	ANY, WEAPON, RING, POTION
}
```

Интерфейс `Iterator` чрезвычайно прост.
```java
public interface Iterator<T> {

	boolean hasNext();
	
	T next();
}
```

В следующем примере мы продемонстрируем различные виды итераторов.
```java
@Slf4j
public class App {

    private static final TreasureChest TREASURE_CHEST = new TreasureChest();

    private static void demonstrateTreasureChestIteratorForType(ItemType itemType) {
        LOGGER.info("------------------------");
        LOGGER.info("Item Iterator for ItemType " + itemType + ": ");
        var itemIterator = TREASURE_CHEST.iterator(itemType);
        while (itemIterator.hasNext()) {
			LOGGER.info(itemIterator.next().toString());
        }
    }

    private static void demonstrateBstIterator() {
        LOGGER.info("------------------------");
        LOGGER.info("BST Iterator: ");
        var root = buildIntegerBst();
        var bstIterator = new BstIterator<>(root);
        while (bstIterator.hasNext()) {
            LOGGER.info("Next node: " + bstIterator.next().getVal());
        }
    }

    private static TreeNode<Integer> buildIntegerBst() {
        var root = new TreeNode<>(8);

        root.insert(3);
        root.insert(10);
        root.insert(1);
        root.insert(6);
        root.insert(14);
        root.insert(4);
        root.insert(7);
        root.insert(13);

        return root;
    }

    public static void main(String[] args) {
        demonstrateTreasureChestIteratorForType(RING);
        demonstrateTreasureChestIteratorForType(POTION);
        demonstrateTreasureChestIteratorForType(WEAPON);
        demonstrateTreasureChestIteratorForType(ANY);
        demonstrateBstIterator();
    }
}
```

Вывод программы:
```
------------------------
Item Iterator for ItemType RING: 
Ring of shadows
Ring of armor
------------------------
Item Iterator for ItemType POTION: 
Potion of courage
Potion of wisdom
Potion of blood
Potion of rust
Potion of healing
------------------------
Item Iterator for ItemType WEAPON: 
Sword of silver +1
Steel halberd
Dagger of poison
------------------------
Item Iterator for ItemType ANY: 
Potion of courage
Ring of shadows
Potion of wisdom
Potion of blood
Sword of silver +1
Potion of rust
Potion of healing
Ring of armor
Steel halberd
Dagger of poison
------------------------
BST Iterator: 
Next node: 1
Next node: 3
Next node: 4
Next node: 6
Next node: 7
Next node: 8
Next node: 10
Next node: 13
Next node: 14
```
## Применимость
- **Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).**
Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.

- **Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.**
Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг — будь то сам класс коллекции или часть бизнес-логики программы. Применив итератор, вы можете выделить код обхода структуры данных в собственный класс, упростив поддержку остального кода.

- **Когда вам хочется иметь единый интерфейс обхода различных структур данных.**
Итератор позволяет вынести реализации различных вариантов обхода в подклассы. Это позволит легко взаимозаменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.
# Посредник
**Также известен как**: Intermediary, Controller, Mediator

**Сложность:** ⭐⭐
**Популярность:** ⭐⭐

**Посредник** — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

Посредник убирает прямые связи между отдельными компонентами, заставляя их общаться друг с другом через себя.

**Применимость:** Пожалуй, самое популярное применение Посредника в Java-коде — это связь нескольких компонентов GUI одной программы.

Примеры Посредника в стандартных библиотеках Java:
- [`java.util.Timer`](http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html) (все методы `scheduleXXX()`)
- [`java.util.concurrent.Executor#execute()`](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-)
- [`java.util.concurrent.ExecutorService`](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html) (методы `invokeXXX()` и `submit()`)
- [`java.util.concurrent.ScheduledExecutorService`](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html) (все методы `scheduleXXX()`)
- [`java.lang.reflect.Method#invoke()`](http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-)
![pattern_mediator](/pictures/pattern_mediator.png)
## Проблема
Предположим, что у вас есть диалог создания профиля пользователя. Он состоит из всевозможных элементов управления — текстовых полей, чекбоксов, кнопок.
![pattern_mediator_problem1](/pictures/pattern_mediator_problem1.png)

Отдельные элементы диалога должны взаимодействовать друг с другом. Так, например, чекбокс «у меня есть собака» открывает скрытое поле для ввода имени домашнего любимца, а клик по кнопке отправки запускает проверку значений всех полей формы.
![pattern_mediator_problem2](/pictures/pattern_mediator_problem2.png)

Прописав эту логику прямо в коде элементов управления, вы поставите крест на их повторном использовании в других местах приложения. Они станут слишком тесно связанными с элементами диалога редактирования профиля, которые не нужны в других контекстах. Поэтому вы сможете использовать либо все элементы сразу, либо ни одного.
## Решение
**Паттерн Посредник заставляет объекты общаться не напрямую друг с другом, а через отдельный объект-посредник, который знает, кому нужно перенаправить тот или иной запрос.** Благодаря этому, компоненты системы будут зависеть только от посредника, а не от десятков других компонентов.

В нашем примере посредником мог бы стать диалог. Скорее всего, класс диалога и так знает, из каких элементов состоит, поэтому никаких новых связей добавлять в него не придётся.
![pattern_mediator_solution](/pictures/pattern_mediator_solution.png)

Основные изменения произойдут внутри отдельных элементов диалога. Если раньше при получении клика от пользователя объект кнопки сам проверял значения полей диалога, то теперь его единственной обязанностью будет сообщить диалогу о том, что произошёл клик. Получив извещение, диалог выполнит все необходимые проверки полей. Таким образом, вместо нескольких зависимостей от остальных элементов кнопка получит только одну — от самого диалога.

Чтобы сделать код ещё более гибким, можно выделить общий интерфейс для всех посредников, то есть диалогов программы. Наша кнопка станет зависимой не от конкретного диалога создания пользователя, а от абстрактного, что позволит использовать её и в других диалогах.

Таким образом, посредник скрывает в себе все сложные связи и зависимости между классами отдельных компонентов программы. А чем меньше связей имеют классы, тем проще их изменять, расширять и повторно использовать.
## Структура
![pattern_mediator_structure](/pictures/pattern_mediator_structure.png)

1. **Компоненты** — это разнородные объекты, содержащие бизнес-логику программы. Каждый компонент хранит ссылку на объект посредника, но работает с ним только через абстрактный интерфейс посредников. Благодаря этому, компоненты можно повторно использовать в другой программе, связав их с посредником другого типа.
2. **Посредник** определяет интерфейс для обмена информацией с компонентами. Обычно хватает одного метода, чтобы оповещать посредника о событиях, произошедших в компонентах. В параметрах этого метода можно передавать детали события: ссылку на компонент, в котором оно произошло, и любые другие данные.
3. **Конкретный посредник** содержит код взаимодействия нескольких компонентов между собой. Зачастую этот объект не только хранит ссылки на все свои компоненты, но и сам их создаёт, управляя дальнейшим жизненным циклом.
4. Компоненты не должны общаться друг с другом напрямую. Если в компоненте происходит важное событие, он должен оповестить своего посредника, а тот сам решит — касается ли событие других компонентов, и стоит ли их оповещать. При этом компонент-отправитель не знает кто обработает его запрос, а компонент-получатель не знает кто его прислал.
## Пример кода
В этом примере медиатор инкапсулирует взаимодействие набора объектов. Вместо того чтобы обращаться друг к другу напрямую, они используют интерфейс посредника.

Члены вечеринки `Rogue`, `Wizard`, `Hobbit` и `Hunter` наследуются от `PartyMemberBase`, реализующего интерфейс `PartyMember`.
```java
public interface PartyMember {

	void joinedParty(Party party);
	
	void partyAction(Action action);
	
	void act(Action action);
}

@Slf4j
public abstract class PartyMemberBase implements PartyMember {

	protected Party party;
	
	@Override
	public void joinedParty(Party party) {
		LOGGER.info("{} joins the party", this);
		this.party = party;
	}
	
	@Override
	public void partyAction(Action action) {
		LOGGER.info("{} {}", this, action.getDescription());
	}
	
	@Override
	public void act(Action action) {
		if (party != null) {
			LOGGER.info("{} {}", this, action);
			party.act(this, action);
		}
	}
	
	@Override
	public abstract String toString();
}

public class Rogue extends PartyMemberBase {

	@Override
	public String toString() {
		return "Rogue";
	}
}

// Wizard, Hobbit, and Hunter are implemented similarly
```

Наша система посредников состоит из интерфейса `Party` и её реализации.
```java
public interface Party {

	void addMember(PartyMember member);
	
	void act(PartyMember actor, Action action);
}

public class PartyImpl implements Party {

	private final List<PartyMember> members;
	
	public PartyImpl() {
		members = new ArrayList<>();
	}
	
	@Override
	public void act(PartyMember actor, Action action) {
		for (var member : members) {
			if (!member.equals(actor)) {
				member.partyAction(action);
			}
		}
	}
	
	@Override
	public void addMember(PartyMember member) {
		members.add(member);
		member.joinedParty(this);
	}
}
```

Вот демонстрация, показывающая паттерн медиатора в действии.
```java
public static void main(String[] args) {

    // create party and members
    Party party = new PartyImpl();
    var hobbit = new Hobbit();
    var wizard = new Wizard();
    var rogue = new Rogue();
    var hunter = new Hunter();

    // add party members
    party.addMember(hobbit);
    party.addMember(wizard);
    party.addMember(rogue);
    party.addMember(hunter);

    // perform actions -> the other party members
    // are notified by the party
    hobbit.act(Action.ENEMY);
    wizard.act(Action.TALE);
    rogue.act(Action.GOLD);
    hunter.act(Action.HUNT);
}
```

Вывод программы:
```
Hobbit joins the party
Wizard joins the party
Rogue joins the party
Hunter joins the party
Hobbit spotted enemies
Wizard runs for cover
Rogue runs for cover
Hunter runs for cover
Wizard tells a tale
Hobbit comes to listen
Rogue comes to listen
Hunter comes to listen
Rogue found gold
Hobbit takes his share of the gold
Wizard takes his share of the gold
Hunter takes his share of the gold
Hunter hunted a rabbit
Hobbit arrives for dinner
Wizard arrives for dinner
Rogue arrives for dinner
```
## Применимость
- **Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.**
Посредник позволяет поместить все эти связи в один класс, после чего вам будет легче их отрефакторить, сделать более понятными и гибкими.

- **Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.**
После применения паттерна компоненты теряют прежние связи с другими компонентами, а всё их общение происходит косвенно, через объект-посредник.

- **Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах.**
Если раньше изменение отношений в одном компоненте могли повлечь за собой лавину изменений во всех остальных компонентах, то теперь вам достаточно создать подкласс посредника и поменять в нём связи между компонентами.
# Снимок
**Также известен как**: Хранитель, Memento

**Сложность:** ⭐⭐⭐
**Популярность:** ⭐

**Снимок** — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.

При этом Снимок не раскрывает подробностей реализации объектов, и клиент не имеет доступа к защищённой информации объекта.

**Применимость:** Снимок на Java чаще всего реализуют с помощью сериализации. Но это не единственный, да и не самый эффективный метод сохранения состояния объектов во время выполнения программы.

Примеры Снимка в стандартных библиотеках Java:
- Все реализации [`java.io.Serializable`](http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html) могут быть использованы как аналог Снимка.
- Все реализации [`javax.faces.component.StateHolder`](http://docs.oracle.com/javaee/7/api/javax/faces/component/StateHolder.html)
![pattern_memento](/pictures/pattern_memento.png)
## Проблема
Предположим, что вы пишете программу текстового редактора. Помимо обычного редактирования, ваш редактор позволяет менять форматирование текста, вставлять картинки и прочее.

В какой-то момент вы решили сделать все эти действия отменяемыми. Для этого вам нужно сохранять текущее состояние редактора перед тем, как выполнить любое действие. Если потом пользователь решит отменить своё действие, вы достанете копию состояния из истории и восстановите старое состояние редактора.
![pattern_memento_problem1](/pictures/pattern_memento_problem1.png)

Чтобы сделать копию состояния объекта, достаточно скопировать значение его полей. Таким образом, если вы сделали класс редактора достаточно открытым, то любой другой класс сможет заглянуть внутрь, чтобы скопировать его состояние.

Казалось бы, что ещё нужно? Ведь теперь любая операция сможет сделать резервную копию редактора перед своим действием. Но такой наивный подход обеспечит вам уйму проблем в будущем. Ведь если вы решите провести рефакторинг — убрать или добавить парочку полей в класс редактора — то придётся менять код всех классов, которые могли копировать состояние редактора.
![pattern_memento_problem2](/pictures/pattern_memento_problem2.png)

Но это ещё не все. Давайте теперь рассмотрим сами копии состояния редактора. Из чего состоит состояние редактора? Даже самый примитивный редактор должен иметь несколько полей для хранения текущего текста, позиции курсора и прокрутки экрана. Чтобы сделать копию состояния, вам нужно записать значения всех этих полей в некий «контейнер».

Скорее всего, вам понадобится хранить массу таких контейнеров в качестве истории операций, поэтому удобнее всего сделать их объектами одного класса. Этот класс должен иметь много полей, но практически никаких методов. Чтобы другие объекты могли записывать и читать из него данные, вам придётся сделать его поля публичными. Но это приведёт к той же проблеме, что и с открытым классом редактора. Другие классы станут зависимыми от любых изменений в классе контейнера, который подвержен тем же изменениям, что и класс редактора.

Получается, нам придётся либо открыть классы для всех желающих, испытывая массу хлопот с поддержкой кода, либо оставить классы закрытыми, отказавшись от идеи отмены операций. Нет ли какого-то другого пути?
## Решение
Все проблемы, описанные выше, возникают из-за нарушения инкапсуляции. Это когда одни объекты пытаются сделать работу за других, влезая в их приватную зону, чтобы собрать необходимые для операции данные.

**Паттерн Снимок поручает создание копии состояния объекта самому объекту, который этим состоянием владеет.** Вместо того, чтобы делать снимок «извне», наш редактор сам сделает копию своих полей, ведь ему доступны все поля, даже приватные.

**Паттерн предлагает держать копию состояния в специальном объекте-_снимке_ с ограниченным интерфейсом**, позволяющим, например, узнать дату изготовления или название снимка. Но, с другой стороны, **снимок должен быть открыт для своего _создателя_, позволяя прочесть и восстановить его внутреннее состояние**.
![pattern_memento_solution](/pictures/pattern_memento_solution.png)

Такая схема позволяет создателям производить снимки и отдавать их для хранения другим объектам, называемым **опекунами**. Опекунам будет доступен только ограниченный интерфейс снимка, поэтому они никак не смогут повлиять на «внутренности» самого снимка. В нужный момент опекун может попросить создателя восстановить своё состояние, передав ему соответствующий снимок.

В примере с редактором вы можете сделать опекуном отдельный класс, который будет хранить список выполненных операций. Ограниченный интерфейс снимков позволит демонстрировать пользователю красивый список с названиями и датами выполненных операций. А когда пользователь решит откатить операцию, класс истории возьмёт последний снимок из стека и отправит его объекту редактор для восстановления.
## Структура
### Классическая реализация на вложенных классах
Классическая реализация паттерна полагается на механизм вложенных классов, который доступен лишь в некоторых языках программирования (C++, C#, Java).
![pattern_memento_structure1](/pictures/pattern_memento_structure1.png)

1. **Создатель** может производить снимки своего состояния, а также воспроизводить прошлое состояние, если подать в него готовый снимок.
2. **Снимок** — это простой объект данных, содержащий состояние создателя. Надёжнее всего сделать объекты снимков неизменяемыми, передавая в них состояние только через конструктор.
3. **Опекун** должен знать, когда делать снимок создателя и когда его нужно восстанавливать. 
   
   Опекун может хранить историю прошлых состояний создателя в виде стека из снимков. Когда понадобится отменить выполненную операцию, он возьмёт «верхний» снимок из стека и передаст его создателю для восстановления.
4. В данной реализации снимок — это внутренний класс по отношению к классу создателя. Именно поэтому он имеет полный доступ к полям и методам создателя, даже приватным. С другой стороны, опекун не имеет доступа ни к состоянию, ни к методам снимков и может всего лишь хранить ссылки на эти объекты.
### Реализация с пустым промежуточным интерфейсом
Подходит для языков, не имеющих механизма вложенных классов (например, PHP).
![pattern_memento_structure2](/pictures/pattern_memento_structure2.png)

1. В этой реализации создатель работает напрямую с конкретным классом снимка, а опекун — только с его ограниченным интерфейсом.
2. Благодаря этому достигается тот же эффект, что и в классической реализации. Создатель имеет полный доступ к снимку, а опекун — нет.
### Снимки с повышенной защитой
Когда нужно полностью исключить возможность доступа к состоянию создателей и снимков.
![pattern_memento_structure3](/pictures/pattern_memento_structure3.png)

1. Эта реализация разрешает иметь несколько видов создателей и снимков. Каждому классу создателей соответствует свой класс снимков. Ни создатели, ни снимки не позволяют другим объектам прочесть своё состояние.
2. Здесь опекун ещё более жёстко ограничен в доступе к состоянию создателей и снимков. Но, с другой стороны, опекун становится независим от создателей, поскольку метод восстановления теперь находится в самих снимках.
3. Снимки теперь связаны с теми создателями, из которых они сделаны. Они по-прежнему получают состояние через конструктор. Благодаря близкой связи между классами, снимки знают, как восстановить состояние своих создателей.
## Пример кода
В нашем астрологическом приложении мы используем паттерн Memento для захвата и восстановления состояния звёздных объектов. Каждое состояние сохраняется как снимок, что позволяет нам возвращаться к предыдущим состояниям по мере необходимости.

Давайте сначала определим типы звезд, с которыми мы можем работать.
```java
public enum StarType {
	SUN("sun"),
	RED_GIANT("red giant"),
	WHITE_DWARF("white dwarf"),
	SUPERNOVA("supernova"),
	DEAD("dead star");
	// ...
}
```

Далее перейдем непосредственно к основному. Вот класс `Star` вместе со снимками, которыми нам нужно манипулировать. Особенно обратите внимание на методы `getMemento` и `setMemento`.
```java
public interface StarMemento {
}

public class Star {

    private StarType type;
    private int ageYears;
    private int massTons;

    public Star(StarType startType, int startAge, int startMass) {
        this.type = startType;
        this.ageYears = startAge;
        this.massTons = startMass;
    }

    public void timePasses() {
        ageYears *= 2;
        massTons *= 8;
        switch (type) {
            case RED_GIANT -> type = StarType.WHITE_DWARF;
            case SUN -> type = StarType.RED_GIANT;
            case SUPERNOVA -> type = StarType.DEAD;
            case WHITE_DWARF -> type = StarType.SUPERNOVA;
            case DEAD -> {
                ageYears *= 2;
                massTons = 0;
            }
            default -> {
            }
        }
    }

    StarMemento getMemento() {
        var state = new StarMementoInternal();
        state.setAgeYears(ageYears);
        state.setMassTons(massTons);
        state.setType(type);
        return state;
    }

    void setMemento(StarMemento memento) {
        var state = (StarMementoInternal) memento;
        this.type = state.getType();
        this.ageYears = state.getAgeYears();
        this.massTons = state.getMassTons();
    }

    @Override
    public String toString() {
        return String.format("%s age: %d years mass: %d tons", type.toString(), ageYears, massTons);
    }

    private static class StarMementoInternal implements StarMemento {

        private StarType type;
        private int ageYears;
        private int massTons;

        // setters and getters ->
        // ...
    }
}
```

И наконец, вот как мы используем снимки для хранения и восстановления звёздных состояний.
```java
public static void main(String[] args) {
    var states = new Stack<StarMemento>();

    var star = new Star(StarType.SUN, 10000000, 500000);
    LOGGER.info(star.toString());
    states.add(star.getMemento());
    star.timePasses();
    LOGGER.info(star.toString());
    states.add(star.getMemento());
    star.timePasses();
    LOGGER.info(star.toString());
    states.add(star.getMemento());
    star.timePasses();
    LOGGER.info(star.toString());
    states.add(star.getMemento());
    star.timePasses();
    LOGGER.info(star.toString());
    while (!states.isEmpty()) {
        star.setMemento(states.pop());
        LOGGER.info(star.toString());
    }
}
```

Вывод программы:
```
sun age: 10000000 years mass: 500000 tons
red giant age: 20000000 years mass: 4000000 tons
white dwarf age: 40000000 years mass: 32000000 tons
supernova age: 80000000 years mass: 256000000 tons
dead star age: 160000000 years mass: 2048000000 tons
supernova age: 80000000 years mass: 256000000 tons
white dwarf age: 40000000 years mass: 32000000 tons
red giant age: 20000000 years mass: 4000000 tons
sun age: 10000000 years mass: 500000 tons
```
## Применимость
- **Когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии.**
Паттерн Снимок позволяет создавать любое количество снимков объекта и хранить их, независимо от объекта, с которого делают снимок. Снимки часто используют не только для реализации операции отмены, но и для транзакций, когда состояние объекта нужно «откатить», если операция не удалась.

- **Когда прямое получение состояния объекта раскрывает приватные детали его реализации, нарушая инкапсуляцию.**
Паттерн предлагает изготовить снимок самому исходному объекту, поскольку ему доступны все поля, даже приватные.
# Наблюдатель
**Также известен как**: Издатель-Подписчик, Слушатель, Observer

**Сложность:** ⭐⭐
**Популярность:** ⭐⭐⭐

**Наблюдатель** — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

При этом наблюдатели могут свободно подписываться и отписываться от этих оповещений.

**Применимость:** Наблюдатель можно часто встретить в Java коде, особенно там, где применяется событийная модель отношений между компонентами. Наблюдатель позволяет отдельным компонентам реагировать на события, происходящие в других компонентах.

Примеры Наблюдателя в стандартных библиотеках Java:
- [`java.util.Observer`](http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html)/[`java.util.Observable`](http://docs.oracle.com/javase/8/docs/api/java/util/Observable.html) (редко используется в реальной жизни)
- Все реализации [`java.util.EventListener`](http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html) (практически во всём Swing-е)
- [`javax.servlet.http.HttpSessionBindingListener`](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html)
- [`javax.servlet.http.HttpSessionAttributeListener`](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionAttributeListener.html)
- [`javax.faces.event.PhaseListener`](http://docs.oracle.com/javaee/7/api/javax/faces/event/PhaseListener.html)

**Признаки применения паттерна:** Наблюдатель можно определить по механизму подписки и методам оповещения, которые вызывают компоненты программы.
![pattern_observer](/pictures/pattern_observer.png)
## Проблема
Представьте, что вы имеете два объекта: `Покупатель` и `Магазин`. В магазин вот-вот должны завезти новый товар, который интересен покупателю.

Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.
![pattern_observer_problem](/pictures/pattern_observer_problem.png)

С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.

Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные оповещения.
## Решение
Давайте называть `Издателями` те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, которые хотят отслеживать изменения этого состояния, назовём `Подписчиками`.

**Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно.** Он предоставит методы, с помощью которых **подписчики могли бы добавлять или убирать себя из списка**.
![pattern_observer_solution1](/pictures/pattern_observer_solution1.png)

Теперь самое интересное. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков.

Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.
![pattern_observer_solution2](/pictures/pattern_observer_solution2.png)

Увидев, как складно всё работает, вы можете выделить общий интерфейс, описывающий методы подписки и отписки, и для всех издателей. После этого подписчики смогут работать с разными типами издателей, а также получать оповещения от них через один и тот же метод.
## Структура
![pattern_observer_structure](/pictures/pattern_observer_structure.png)

1. **Издатель** владеет внутренним состоянием, изменение которого интересно отслеживать подписчикам. Издатель содержит механизм подписки: список подписчиков и методы подписки/отписки.
2. Когда внутреннее состояние издателя меняется, он оповещает своих подписчиков. Для этого издатель проходит по списку подписчиков и вызывает их метод оповещения, заданный в общем интерфейсе подписчиков.
3. **Подписчик** определяет интерфейс, которым пользуется издатель для отправки оповещения. В большинстве случаев для этого достаточно единственного метода.
4. **Конкретные подписчики** выполняют что-то в ответ на оповещение, пришедшее от издателя. Эти классы должны следовать общему интерфейсу подписчиков, чтобы издатель не зависел от конкретных классов подписчиков.
5. По приходу оповещения подписчику нужно получить обновлённое состояние издателя. Издатель может передать это состояние через параметры метода оповещения. Более гибкий вариант — передавать через параметры весь объект издателя, чтобы подписчик мог сам получить требуемые данные. Как вариант, подписчик может постоянно хранить ссылку на объект издателя, переданный ему в конструкторе.
6. **Клиент** создаёт объекты издателей и подписчиков, а затем регистрирует подписчиков на обновления в издателях.
## Пример кода
В далёкой-далёкой стране живут расы хоббитов и орков. Обе они в основном живут на открытом воздухе, поэтому внимательно следят за изменениями погоды. Можно сказать, что они постоянно наблюдают за погодой.

Сначала представим интерфейс `WeatherObserver` и наши расы - `Orcs` и `Hobbits`.
```java
public interface WeatherObserver {

	void update(WeatherType currentWeather);
}

@Slf4j
public class Orcs implements WeatherObserver {

	@Override
	public void update(WeatherType currentWeather) {
		LOGGER.info("The orcs are facing " + currentWeather.getDescription() + " weather now");
	}
}

@Slf4j
public class Hobbits implements WeatherObserver {

  @Override
	public void update(WeatherType currentWeather) {
		switch (currentWeather) {
			LOGGER.info("The hobbits are facing " + currentWeather.getDescription() + " weather now");
		}
	}
}
```

А вот `Weather` постоянно меняется.
```java
@Slf4j
public class Weather {

	private WeatherType currentWeather;
	private final List<WeatherObserver> observers;
	
	public Weather() {
		observers = new ArrayList<>();
		currentWeather = WeatherType.SUNNY;
	}
	
	public void addObserver(WeatherObserver obs) {
		observers.add(obs);
	}
	
	public void removeObserver(WeatherObserver obs) {
		observers.remove(obs);
	}
	
	/**
	* Makes time pass for weather.
	*/
	public void timePasses() {
		var enumValues = WeatherType.values();
		currentWeather = enumValues[(currentWeather.ordinal() + 1) % enumValues.length];
		LOGGER.info("The weather changed to {}.", currentWeather);
		notifyObservers();
	}
	
	private void notifyObservers() {
		for (var obs : observers) {
			obs.update(currentWeather);
		}
	}
}
```

Вот полный пример в действии.
```java
  public static void main(String[] args) {

    var weather = new Weather();
    weather.addObserver(new Orcs());
    weather.addObserver(new Hobbits());

    weather.timePasses();
    weather.timePasses();
    weather.timePasses();
    weather.timePasses();

    // Generic observer inspired by Java Generics and Collections by Naftalin & Wadler
    LOGGER.info("--Running generic version--");
    var genericWeather = new GenWeather();
    genericWeather.addObserver(new GenOrcs());
    genericWeather.addObserver(new GenHobbits());

    genericWeather.timePasses();
    genericWeather.timePasses();
    genericWeather.timePasses();
    genericWeather.timePasses();
  }
```

Вывод программы:
```
The weather changed to rainy.
The orcs are facing Rainy weather now
The hobbits are facing Rainy weather now
The weather changed to windy.
The orcs are facing Windy weather now
The hobbits are facing Windy weather now
The weather changed to cold.
The orcs are facing Cold weather now
The hobbits are facing Cold weather now
The weather changed to sunny.
The orcs are facing Sunny weather now
The hobbits are facing Sunny weather now
--Running generic version--
The weather changed to rainy.
The orcs are facing Rainy weather now
The hobbits are facing Rainy weather now
The weather changed to windy.
The orcs are facing Windy weather now
The hobbits are facing Windy weather now
The weather changed to cold.
The orcs are facing Cold weather now
The hobbits are facing Cold weather now
The weather changed to sunny.
The orcs are facing Sunny weather now
The hobbits are facing Sunny weather now
```
## Применимость
- **Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.**
Описанная проблема может возникнуть при разработке библиотек пользовательского интерфейса, когда вам надо дать возможность сторонним классам реагировать на клики по кнопкам.

Паттерн Наблюдатель позволяет любому объекту с интерфейсом подписчика зарегистрироваться на получение оповещений о событиях, происходящих в объектах-издателях.

- **Когда одни объекты должны наблюдать за другими, но только в определённых случаях.**
Издатели ведут динамические списки. Все наблюдатели могут подписываться или отписываться от получения оповещений прямо во время выполнения программы.
# Состояние
**Также известен как**: State

**Сложность:** ⭐
**Популярность:** ⭐⭐

**Состояние** — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

Поведения, зависящие от состояния, переезжают в отдельные классы. Первоначальный класс хранит ссылку на один из таких объектов-состояний и делегирует ему работу.

**Применимость:** Паттерн Состояние часто используют в Java для превращения в объекты громоздких стейт-машин, построенных на операторах `switch`.

Примеры Состояния в стандартных библиотеках Java:
- [`javax.faces.lifecycle.LifeCycle#execute()`](http://docs.oracle.com/javaee/7/api/javax/faces/lifecycle/Lifecycle.html#execute-javax.faces.context.FacesContext-) (контролируемый из [`FacesServlet`](http://docs.oracle.com/javaee/7/api/javax/faces/webapp/FacesServlet.html): поведение зависит от текущей фазы (состояния) JSF)

**Признаки применения паттерна:** Методы класса делегируют работу одному вложенному объекту.
![pattern_state](/pictures/pattern_state.png)
## Проблема
Паттерн Состояние невозможно рассматривать в отрыве от концепции _машины состояний_, также известной как _стейт-машина_ или _конечный автомат_.
![pattern_state_problem1](/pictures/pattern_state_problem1.png)

Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. Набор этих состояний, а также переходов между ними, предопределён и _конечен_. Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.

Такой подход можно применить и к отдельным объектам. Например, объект `Документ` может принимать три состояния: `Черновик`, `Модерация` или `Опубликован`. В каждом из этих состоянии метод `опубликовать` будет работать по-разному:
- Из черновика он отправит документ на модерацию.
- Из модерации — в публикацию, но при условии, что это сделал администратор.
- В опубликованном состоянии метод не будет делать ничего.
![pattern_state_problem2](/pictures/pattern_state_problem2.png)

Машину состояний чаще всего реализуют с помощью множества условных операторов, `if` либо `switch`, которые проверяют текущее состояние объекта и выполняют соответствующее поведение. Наверняка вы уже реализовали хотя бы одну машину состояний в своей жизни, даже не зная об этом. Как насчёт вот такого кода, выглядит знакомо?
```java
class Document is
    field state: string
    // ...
    method publish() is
        switch (state)
            "draft":
                state = "moderation"
                break
            "moderation":
                if (currentUser.role == "admin")
                    state = "published"
                break
            "published":
                // Do nothing.
                break
    // ...
```

Основная проблема такой машины состояний проявится в том случае, если в `Документ` добавить ещё десяток состояний. Каждый метод будет состоять из увесистого условного оператора, перебирающего доступные состояния. Такой код крайне сложно поддерживать. Малейшее изменение логики переходов заставит вас перепроверять работу всех методов, которые содержат условные операторы машины состояний.

Путаница и нагромождение условий особенно сильно проявляется в старых проектах. Набор возможных состояний бывает трудно предопределить заранее, поэтому они всё время добавляются в процессе эволюции программы. Из-за этого решение, которое выглядело простым и эффективным в самом начале разработки, может впоследствии стать проекцией большого макаронного монстра.
## Решение
**Паттерн Состояние предлагает создать отдельные классы для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.**

Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый **контекстом**, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.
![pattern_state_solution](/pictures/pattern_state_solution.png)

Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу. Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

Очень важным нюансом, отличающим этот паттерн от Стратегии, является то, что и контекст, и сами конкретные состояния могут знать друг о друге и инициировать переходы от одного состояния к другому.
## Структура
![pattern_state_structure](/pictures/pattern_state_structure.png)

1. **Контекст** хранит ссылку на объект состояния и делегирует ему часть работы, зависящей от состояний. Контекст работает с этим объектом через общий интерфейс состояний. Контекст должен иметь метод для присваивания ему нового объекта-состояния.
2. **Состояние** описывает общий интерфейс для всех конкретных состояний.
3. **Конкретные состояния** реализуют поведения, связанные с определённым состоянием контекста. Иногда приходится создавать целые иерархии классов состояний, чтобы обобщить дублирующий код.
   
   Состояние может иметь обратную ссылку на объект контекста. Через неё не только удобно получать из контекста нужную информацию, но и осуществлять смену его состояния.
4. И контекст, и объекты конкретных состояний могут решать, когда и какое следующее состояние будет выбрано. Чтобы переключить состояние, нужно подать другой объект-состояние в контекст.
## Пример кода
В нашем программном примере есть мамонт с чередующимися настроениями.

Во-первых, здесь представлен интерфейс `State` и его конкретные реализации.
```java
public interface State {

	void onEnterState();
	
	void observe();
}

@Slf4j
public class PeacefulState implements State {

	private final Mammoth mammoth;
	
	public PeacefulState(Mammoth mammoth) {
		this.mammoth = mammoth;
	}
	
	@Override
	public void observe() {
		LOGGER.info("{} is calm and peaceful.", mammoth);
	}
	
	@Override
	public void onEnterState() {
		LOGGER.info("{} calms down.", mammoth);
	}
}

@Slf4j
public class AngryState implements State {

	private final Mammoth mammoth;
	
	public AngryState(Mammoth mammoth) {
		this.mammoth = mammoth;
	}
	
	@Override
	public void observe() {
		LOGGER.info("{} is furious!", mammoth);
	}
	
	@Override
	public void onEnterState() {
		LOGGER.info("{} gets angry!", mammoth);
	}
}
```

А вот мамонт, содержащий состояние. Состояние изменяется через вызовы метода `timePasses`.
```java
public class Mammoth {

	private State state;
	
	public Mammoth() {
		state = new PeacefulState(this);
	}
	
	public void timePasses() {
		if (state.getClass().equals(PeacefulState.class)) {
			changeStateTo(new AngryState(this));
		} else {
			changeStateTo(new PeacefulState(this));
		}
	}
	
	private void changeStateTo(State newState) {
		this.state = newState;
		this.state.onEnterState();
	}
	
	@Override
	public String toString() {
		return "The mammoth";
	}
	
	public void observe() {
		this.state.observe();
	}
}
```

Вот полный пример того, как мамонт ведет себя со временем.
```java
public static void main(String[] args) {

    var mammoth = new Mammoth();
    mammoth.observe();
    mammoth.timePasses();
    mammoth.observe();
    mammoth.timePasses();
    mammoth.observe();
}
```

Вывод программы:
```
The mammoth gets angry!
The mammoth is furious!
The mammoth calms down.
The mammoth is calm and peaceful.
```
## Применимость
- **Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.**
Паттерн предлагает выделить в собственные классы все поля и методы, связанные с определёнными состояниями. Первоначальный объект будет постоянно ссылаться на один из объектов-состояний, делегируя ему часть своей работы. Для изменения состояния в контекст достаточно будет подставить другой объект-состояние.

- **Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса.**
Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно поселить и все поля, связанные с данным состоянием.

- **Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.**
Паттерн Состояние позволяет реализовать иерархическую машину состояний, базирующуюся на наследовании. Вы можете отнаследовать похожие состояния от одного родительского класса и вынести туда весь дублирующий код.
# Стратегия
**Также известен как**: Strategy

**Сложность:** ⭐
**Популярность:** ⭐⭐⭐

**Стратегия** — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект другим, если требуется иной способ решения задачи.

**Применимость:** Стратегия часто используется в Java-коде, особенно там, где нужно подменять алгоритм во время выполнения программы. Начиная с Java 8, многие примеры стратегии можно заменить простыми lambda-выражениями.

Примеры Стратегии в стандартных библиотеках Java:
- [`java.util.Comparator#compare()`](http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-), вызываемые из `Collections#sort()`.
- [`javax.servlet.http.HttpServlet`](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html): метод `service()`, а также все методы `doXXX()` принимают объекты `HttpServletRequest` и `HttpServletResponse` в параметрах.
- [`javax.servlet.Filter#doFilter()`](http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-)

**Признаки применения паттерна:** Класс делегирует выполнение вложенному объекту абстрактного типа или интерфейса.
![pattern_strategy](/pictures/pattern_strategy.png)
## Проблема
Вы решили написать приложение-навигатор для путешественников. Оно должно показывать красивую и удобную карту, позволяющую с лёгкостью ориентироваться в незнакомом городе.

Одной из самых востребованных функций являлся поиск и прокладывание маршрутов. Пребывая в неизвестном ему городе, пользователь должен иметь возможность указать начальную точку и пункт назначения, а навигатор — проложит оптимальный путь.

Первая версия вашего навигатора могла прокладывать маршрут лишь по дорогам, поэтому отлично подходила для путешествий на автомобиле. Но, очевидно, не все ездят в отпуск на машине. Поэтому следующим шагом вы добавили в навигатор прокладывание пеших маршрутов.

Через некоторое время выяснилось, что некоторые люди предпочитают ездить по городу на общественном транспорте. Поэтому вы добавили и такую опцию прокладывания пути.

Но и это ещё не всё. В ближайшей перспективе вы хотели бы добавить прокладывание маршрутов по велодорожкам. А в отдалённом будущем — интересные маршруты посещения достопримечательностей.
![pattern_strategy_problem](/pictures/pattern_strategy_problem.png)

Если с популярностью навигатора не было никаких проблем, то техническая часть вызывала вопросы и периодическую головную боль. С каждым новым алгоритмом код основного класса навигатора увеличивался вдвое. В таком большом классе стало довольно трудно ориентироваться.

Любое изменение алгоритмов поиска, будь то исправление багов или добавление нового алгоритма, затрагивало основной класс. Это повышало риск сделать ошибку, случайно задев остальной работающий код.

Кроме того, осложнялась командная работа с другими программистами, которых вы наняли после успешного релиза навигатора. Ваши изменения нередко затрагивали один и тот же код, создавая конфликты, которые требовали дополнительного времени на их разрешение.
## Решение
**Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые _стратегиями_.**

Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.

Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, не трогая код контекста.
![pattern_strategy_solution](/pictures/pattern_strategy_solution.png)

В нашем примере каждый алгоритм поиска пути переедет в свой собственный класс. В этих классах будет определён лишь один метод, принимающий в параметрах координаты начала и конца пути, а возвращающий массив точек маршрута.

Хотя каждый класс будет прокладывать маршрут по-своему, для навигатора это не будет иметь никакого значения, так как его работа заключается только в отрисовке маршрута. Навигатору достаточно подать в стратегию данные о начале и конце маршрута, чтобы получить массив точек маршрута в оговорённом формате.

Класс навигатора будет иметь метод для установки стратегии, позволяя изменять стратегию поиска пути на лету. Такой метод пригодится клиентскому коду навигатора, например, переключателям типов маршрутов в пользовательском интерфейсе.
## Структура
![pattern_strategy_structure](/pictures/pattern_strategy_structure.png)

1. **Контекст** хранит ссылку на объект конкретной стратегии, работая с ним через общий интерфейс стратегий.
2. **Стратегия** определяет интерфейс, общий для всех вариаций алгоритма. Контекст использует этот интерфейс для вызова алгоритма.
   
   Для контекста неважно, какая именно вариация алгоритма будет выбрана, так как все они имеют одинаковый интерфейс.
3. **Конкретные стратегии** реализуют различные вариации алгоритма.
4. Во время выполнения программы контекст получает вызовы от клиента и делегирует их объекту конкретной стратегии.
5. Клиент должен создать объект конкретной стратегии и передать его в конструктор контекста. Кроме этого, клиент должен иметь возможность заменить стратегию на лету, используя сеттер. Благодаря этому, контекст не будет знать о том, какая именно стратегия сейчас выбрана.
## Пример кода
Уничтожение драконов - опасная работа. С опытом она становится легче. Драконоборцы-ветераны разработали различные стратегии борьбы с разными видами драконов.

Давайте рассмотрим, как реализовать интерфейс `DragonSlayingStrategy` в Java, и продемонстрируем различные варианты применения паттерна Strategy.
```java
@FunctionalInterface
public interface DragonSlayingStrategy {

	void execute();
}

@Slf4j
public class MeleeStrategy implements DragonSlayingStrategy {

	@Override
	public void execute() {
		LOGGER.info("With your Excalibur you sever the dragon's head!");
	}
}

@Slf4j
public class ProjectileStrategy implements DragonSlayingStrategy {

	@Override
	public void execute() {
		LOGGER.info("You shoot the dragon with the magical crossbow and it falls dead on the ground!");
	}
}

@Slf4j
public class SpellStrategy implements DragonSlayingStrategy {

	@Override
	public void execute() {
		LOGGER.info("You cast the spell of disintegration and the dragon vaporizes in a pile of dust!");
	}
}
```

А вот и могучий `DragonSlayer`, который может выбирать стратегию боя в зависимости от противника.
```java
public class DragonSlayer {

	private DragonSlayingStrategy strategy;
	
	public DragonSlayer(DragonSlayingStrategy strategy) {
		this.strategy = strategy;
	}
	
	public void changeStrategy(DragonSlayingStrategy strategy) {
		this.strategy = strategy;
	}
	
	public void goToBattle() {
		strategy.execute();
	}
}
```

Наконец, вот `DragonSlayer` в действии.
```java
@Slf4j
public class App {

  private static final String RED_DRAGON_EMERGES = "Red dragon emerges.";
  private static final String GREEN_DRAGON_SPOTTED = "Green dragon spotted ahead!";
  private static final String BLACK_DRAGON_LANDS = "Black dragon lands before you.";

  public static void main(String[] args) {
	// GoF Strategy pattern
    LOGGER.info(GREEN_DRAGON_SPOTTED);
    var dragonSlayer = new DragonSlayer(new MeleeStrategy());
    dragonSlayer.goToBattle();
    LOGGER.info(RED_DRAGON_EMERGES);
    dragonSlayer.changeStrategy(new ProjectileStrategy());
    dragonSlayer.goToBattle();
    LOGGER.info(BLACK_DRAGON_LANDS);
    dragonSlayer.changeStrategy(new SpellStrategy());
    dragonSlayer.goToBattle();

    // Java 8 functional implementation Strategy pattern
    LOGGER.info(GREEN_DRAGON_SPOTTED);
    dragonSlayer = new DragonSlayer(
        () -> LOGGER.info("With your Excalibur you sever the dragon's head!"));
    dragonSlayer.goToBattle();
    LOGGER.info(RED_DRAGON_EMERGES);
    dragonSlayer.changeStrategy(() -> LOGGER.info(
        "You shoot the dragon with the magical crossbow and it falls dead on the ground!"));
    dragonSlayer.goToBattle();
    LOGGER.info(BLACK_DRAGON_LANDS);
    dragonSlayer.changeStrategy(() -> LOGGER.info(
        "You cast the spell of disintegration and the dragon vaporizes in a pile of dust!"));
    dragonSlayer.goToBattle();

    // Java 8 lambda implementation with enum Strategy pattern
    LOGGER.info(GREEN_DRAGON_SPOTTED);
    dragonSlayer.changeStrategy(LambdaStrategy.Strategy.MELEE_STRATEGY);
    dragonSlayer.goToBattle();
    LOGGER.info(RED_DRAGON_EMERGES);
    dragonSlayer.changeStrategy(LambdaStrategy.Strategy.PROJECTILE_STRATEGY);
    dragonSlayer.goToBattle();
    LOGGER.info(BLACK_DRAGON_LANDS);
    dragonSlayer.changeStrategy(LambdaStrategy.Strategy.SPELL_STRATEGY);
    dragonSlayer.goToBattle();
  }
}
```

Вывод программы:
```
Green dragon spotted ahead!
With your Excalibur you sever the dragon's head!
Red dragon emerges.
You shoot the dragon with the magical crossbow and it falls dead on the ground!
Black dragon lands before you.
You cast the spell of disintegration and the dragon vaporizes in a pile of dust!
Green dragon spotted ahead!
With your Excalibur you sever the dragon's head!
Red dragon emerges.
You shoot the dragon with the magical crossbow and it falls dead on the ground!
Black dragon lands before you.
You cast the spell of disintegration and the dragon vaporizes in a pile of dust!
Green dragon spotted ahead!
With your Excalibur you sever the dragon's head!
Red dragon emerges.
You shoot the dragon with the magical crossbow and it falls dead on the ground!
Black dragon lands before you.
You cast the spell of disintegration and the dragon vaporizes in a pile of dust!
```
## Применимость
- **Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.**
Стратегия позволяет варьировать поведение объекта во время выполнения программы, подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).

- **Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.**
Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов, а затем свести первоначальные классы к одному, сделав поведение этого класса настраиваемым.

- **Когда вы не хотите обнажать детали реализации алгоритмов для других классов.**
Стратегия позволяет изолировать код, данные и зависимости алгоритмов от других объектов, скрыв эти детали внутри классов-стратегий.

- **Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма.**
Стратегия помещает каждую лапу такого оператора в отдельный класс-стратегию. Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу. Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию.
# Шаблонный метод
**Также известен как**: Template Method

**Сложность:** ⭐
**Популярность:** ⭐⭐

**Шаблонный метод** — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

**Применимость:** Шаблонные методы можно встретить во многих библиотечных классах Java. Разработчики создают их, чтобы позволить клиентам легко и быстро расширять стандартный код при помощи наследования.

Примеры Шаблонных методов в стандартных библиотеках Java:
- Все не-абстрактные методы классов [`java.io.InputStream`](http://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html), [`java.io.OutputStream`](http://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html), [`java.io.Reader`](http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html) и [`java.io.Writer`](http://docs.oracle.com/javase/8/docs/api/java/io/Writer.html).
- Все не-абстрактные методы классов [`java.util.AbstractList`](http://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html), [`java.util.AbstractSet`](http://docs.oracle.com/javase/8/docs/api/java/util/AbstractSet.html) и [`java.util.AbstractMap`](http://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html).
- [`javax.servlet.http.HttpServlet`](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html), все методы `doXXX()` по умолчанию возвращают HTTP-код 405 "Method Not Allowed". Однако вы можете переопределить их при желании.

**Признаки применения паттерна:** Класс заставляет своих потомков реализовать методы-шаги, но самостоятельно реализует структуру алгоритма.
![pattern_template_method](/pictures/pattern_template_method.png)
## Проблема
Вы пишете программу для дата-майнинга в офисных документах. Пользователи будут загружать в неё документы в разных форматах (PDF, DOC, CSV), а программа должна извлекать из них полезную информацию.

В первой версии вы ограничились только обработкой DOC-файлов. В следующей версии добавили поддержку CSV. А через месяц прикрутили работу с PDF-документами.
![pattern_template_method_problem](/pictures/pattern_template_method_problem.png)

В какой-то момент вы заметили, что код всех трёх классов обработки документов хоть и отличается в части работы с файлами, но содержат довольно много общего в части самого извлечения данных. Было бы здорово избавится от повторной реализации алгоритма извлечения данных в каждом из классов.

К тому же остальной код, работающий с объектами этих классов, наполнен условиями, проверяющими тип обработчика перед началом работы. Весь этот код можно упростить, если слить все три класса воедино либо свести их к общему интерфейсу.
## Решение
**Паттерн Шаблонный метод предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном _шаблонном_ методе друг за другом.**

Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.

В нашем примере с дата-майнингом мы можем создать общий базовый класс для всех трёх алгоритмов. Этот класс будет состоять из шаблонного метода, который последовательно вызывает шаги разбора документов.
![pattern_template_method_solution](/pictures/pattern_template_method_solution.png)

Для начала шаги шаблонного метода можно сделать абстрактными. Из-за этого все подклассы должны будут реализовать каждый из шагов по-своему. В нашем случае все подклассы и так содержат реализацию каждого из шагов, поэтому ничего дополнительно делать не нужно.

По-настоящему важным является следующий этап. Теперь мы можем определить общее для всех классов поведение и вынести его в суперкласс. В нашем примере шаги открытия, считывания и закрытия могут отличаться для разных типов документов, поэтому останутся абстрактными. А вот одинаковый для всех типов документов код обработки данных переедет в базовый класс.

Как видите, у нас получилось два вида шагов: **абстрактные**, которые каждый подкласс обязательно должен реализовать, а также шаги **с реализацией по умолчанию**, которые можно переопределять в подклассах, но не обязательно.

Но есть и третий тип шагов — **хуки**: их не обязательно переопределять, но они не содержат никакого кода, выглядя как обычные методы. Шаблонный метод останется рабочим, даже если ни один подкласс не переопределит такой хук. Однако, хук даёт подклассам дополнительные точки «вклинивания» в шаблонный метод.
## Структура
![pattern_template_method_structure](/pictures/pattern_template_method_structure.png)

1. **Абстрактный класс** определяет шаги алгоритма и содержит шаблонный метод, состоящий из вызовов этих шагов. Шаги могут быть как абстрактными, так и содержать реализацию по умолчанию.
2. **Конкретный класс** переопределяет некоторые (или все) шаги алгоритма. Конкретные классы не переопределяют сам шаблонный метод.
## Пример кода
Наш программный пример посвящён ворам и воровству. Общие действия при краже предмета одинаковы. Сначала вы выбираете цель, затем каким-то образом запутываете её и, наконец, крадёте предмет. Однако реализовать эти шаги можно по-разному.

Сначала представим класс шаблонного метода `StealingMethod` вместе с его конкретными реализациями `SubtleMethod` и `HitAndRunMethod`. Чтобы убедиться, что подклассы не переопределят шаблонный метод, шаблонный метод (в нашем случае метод `steal`) должен быть объявлен `final`, иначе скелет, определенный в базовом классе, может быть переопределен в подклассах.
```java
@Slf4j
public abstract class StealingMethod {

	protected abstract String pickTarget();
	
	protected abstract void confuseTarget(String target);
	
	protected abstract void stealTheItem(String target);
	
	public final void steal() {
		var target = pickTarget();
		LOGGER.info("The target has been chosen as {}.", target);
		confuseTarget(target);
		stealTheItem(target);
	}
}

@Slf4j
public class SubtleMethod extends StealingMethod {

	@Override
	protected String pickTarget() {
		return "shop keeper";
	}
	
	@Override
	protected void confuseTarget(String target) {
		LOGGER.info("Approach the {} with tears running and hug him!", target);
	}
	
	@Override
	protected void stealTheItem(String target) {
		LOGGER.info("While in close contact grab the {}'s wallet.", target);
	}
}

@Slf4j
public class HitAndRunMethod extends StealingMethod {

	@Override
	protected String pickTarget() {
		return "old goblin woman";
	}
	
	@Override
	protected void confuseTarget(String target) {
		LOGGER.info("Approach the {} from behind.", target);
	}
	
	@Override
	protected void stealTheItem(String target) {
		LOGGER.info("Grab the handbag and run away fast!");
	}
}
```

Вот класс вора халфлинга, содержащий метод шаблона.
```java
public class HalflingThief {

	private StealingMethod method;
	
	public HalflingThief(StealingMethod method) {
		this.method = method;
	}
	
	public void steal() {
		method.steal();
	}
	
	public void changeMethod(StealingMethod method) {
		this.method = method;
	}
}
```

И наконец, мы покажем, как вор-халфлинг использует различные способы кражи.
```java
public static void main(String[] args) {
    var thief = new HalflingThief(new HitAndRunMethod());
    thief.steal();
    thief.changeMethod(new SubtleMethod());
    thief.steal();
}
```

Вывод программы:
```
The target has been chosen as old goblin woman.
Approach the old goblin woman from behind.
Grab the handbag and run away fast!
The target has been chosen as shop keeper.
Approach the shop keeper with tears running and hug him!
While in close contact grab the shop keeper's wallet.
```
## Применимость
- **Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.**
Шаблонный метод позволяет подклассам расширять определённые шаги алгоритма через наследование, не меняя при этом структуру алгоритмов, объявленную в базовом классе.

- **Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.**
Паттерн шаблонный метод предлагает создать для похожих классов общий суперкласс и оформить в нём главный алгоритм в виде шагов. Отличающиеся шаги можно переопределить в подклассах.

Это позволит убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях.
# Посетитель
**Также известен как**: Visitor

**Сложность:** ⭐⭐⭐
**Популярность:** ⭐

**Посетитель** — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.

**Применимость:** Посетитель нечасто встречается в Java-коде из-за своей сложности и нюансов реализации.

Примеры Посетителей в стандартных библиотеках Java:
- [`javax.lang.model.element.AnnotationValue`](http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/AnnotationValue.html) и [`AnnotationValueVisitor`](http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/AnnotationValueVisitor.html)
- [`javax.lang.model.element.Element`](http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/Element.html) и [`ElementVisitor`](http://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/ElementVisitor.html)
- [`javax.lang.model.type.TypeMirror`](http://docs.oracle.com/javase/8/docs/api/javax/lang/model/type/TypeMirror.html) и [`TypeVisitor`](http://docs.oracle.com/javase/8/docs/api/javax/lang/model/type/TypeVisitor.html)
- [`java.nio.file.FileVisitor`](http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html) и [`SimpleFileVisitor`](http://docs.oracle.com/javase/8/docs/api/java/nio/file/SimpleFileVisitor.html)
- [`javax.faces.component.visit.VisitContext`](http://docs.oracle.com/javaee/7/api/javax/faces/component/visit/VisitContext.html) и [`VisitCallback`](http://docs.oracle.com/javaee/7/api/javax/faces/component/visit/VisitCallback.html)
![pattern_visitor](/pictures/pattern_visitor.png)
## Проблема
Ваша команда разрабатывает приложение, работающее с геоданными в виде графа. Узлами графа являются городские локации: памятники, театры, рестораны, важные предприятия и прочее. Каждый узел имеет ссылки на другие, ближайшие к нему узлы. Каждому типу узлов соответствует свой класс, а каждый узел представлен отдельным объектом.
![pattern_visitor_problem1](/pictures/pattern_visitor_problem1.png)

Ваша задача — сделать экспорт этого графа в XML. Дело было бы плёвым, если бы вы могли редактировать классы узлов. Достаточно было бы добавить метод экспорта в каждый тип узла, а затем, перебирая узлы графа, вызывать этот метод для каждого узла. Благодаря полиморфизму, решение получилось бы изящным, так как вам не пришлось бы привязываться к конкретным классам узлов.

Но, к сожалению, классы узлов вам изменить не удалось. Системный архитектор сослался на то, что код классов узлов сейчас очень стабилен, и от него многое зависит, поэтому он не хочет рисковать и позволять кому-либо его трогать.
![pattern_visitor_problem2](/pictures/pattern_visitor_problem2.png)

К тому же он сомневался в том, что экспорт в XML вообще уместен в рамках этих классов. Их основная задача была связана с геоданными, а экспорт выглядит в рамках этих классов чужеродно.

Была и ещё одна причина запрета. Если на следующей неделе вам бы понадобился экспорт в какой-то другой формат данных, то эти классы снова пришлось бы менять.
## Решение
**Паттерн Посетитель предлагает разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в нескольких классах.** Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. Вместо этого вы будете передавать эти объекты в методы посетителя.

Код поведения, скорее всего, должен отличаться для объектов разных классов, поэтому и методов у посетителя должно быть несколько. Названия и принцип действия этих методов будут схожи, но основное отличие будет в типе принимаемого в параметрах объекта, например:
```java
class ExportVisitor implements Visitor is
    method doForCity(City c) { ... }
    method doForIndustry(Industry f) { ... }
    method doForSightSeeing(SightSeeing ss) { ... }
    // ...
```

Здесь возникает вопрос: как подавать узлы в объект-посетитель? Так как все методы имеют отличающуюся сигнатуру, использовать полиморфизм при переборе узлов не получится. Придётся проверять тип узлов для того, чтобы выбрать соответствующий метод посетителя.
```java
foreach (Node node in graph)
    if (node instanceof City)
        exportVisitor.doForCity((City) node)
    if (node instanceof Industry)
        exportVisitor.doForIndustry((Industry) node)
    // ...
```

**Тут не поможет даже механизм перегрузки методов (доступный в Java и C#). Если назвать все методы одинаково, то неопределённость реального типа узла всё равно не даст вызвать правильный метод.** Механизм перегрузки всё время будет вызывать метод посетителя, соответствующий типу `Node`, а не реального класса поданного узла.

Но паттерн Посетитель решает и эту проблему, используя механизм **двойной диспетчеризации**. Вместо того, чтобы самим искать нужный метод, мы можем поручить это объектам, которые передаём в параметрах посетителю. А они уже вызовут правильный метод посетителя.
```java
// Client code
foreach (Node node in graph)
    node.accept(exportVisitor)

// City
class City is
    method accept(Visitor v) is
        v.doForCity(this)
    // ...

// Industry
class Industry is
    method accept(Visitor v) is
        v.doForIndustry(this)
    // ...
```

Как видите, изменить классы узлов всё-таки придётся. Но это простое изменение позволит применять к объектам узлов и другие поведения, ведь классы узлов будут привязаны не к конкретному классу посетителей, а к их общему интерфейсу. Поэтому если придётся добавить в программу новое поведение, вы создадите новый класс посетителей и будете передавать его в методы узлов.
## Структура
![pattern_visitor_structure](/pictures/pattern_visitor_structure.png)

1. **Посетитель** описывает общий интерфейс для всех типов посетителей. Он объявляет набор методов, отличающихся типом входящего параметра, которые нужны для запуска операции для всех типов конкретных элементов. В языках, поддерживающих перегрузку методов, эти методы могут иметь одинаковые имена, но типы их параметров должны отличаться.
2. **Конкретные посетители** реализуют какое-то особенное поведение для всех типов элементов, которые можно подать через методы интерфейса посетителя.
3. **Элемент** описывает метод _принятия_ посетителя. Этот метод должен иметь единственный параметр, объявленный с типом интерфейса посетителя.
4. **Конкретные элементы** реализуют методы _принятия_ посетителя. Цель этого метода — вызвать тот метод посещения, который соответствует типу этого элемента. Так посетитель узнает, с каким именно элементом он работает.
5. **Клиентом** зачастую выступает коллекция или сложный составной объект, например, дерево Компоновщика. Зачастую клиент не привязан к конкретным классам элементов, работая с ними через общий интерфейс элементов.
## Пример кода
Рассмотрим древовидную структуру с армейскими подразделениями. Командир имеет в подчинении двух сержантов, а каждый сержант имеет в подчинении трёх солдат. Учитывая, что иерархия реализует паттерн посетителя, мы можем легко создавать новые объекты, взаимодействующие с командиром, сержантами, солдатами или всеми ими.

Учитывая приведенный выше пример с армейским подразделением, у нас есть базовые типы `Unit` и `UnitVisitor`.
```java
public abstract class Unit {

	private final Unit[] children;
	
	public Unit(Unit... children) {
		this.children = children;
	}
	
	public void accept(UnitVisitor visitor) {
		Arrays.stream(children).forEach(child -> child.accept(visitor));
	}
}

public interface UnitVisitor {

	void visit(Soldier soldier);
	
	void visit(Sergeant sergeant);
	
	void visit(Commander commander);
}
```

Затем у нас есть конкретные подразделения - `Commander`, `Sergeant`, и `Soldier`.
```java
public class Commander extends Unit {

	public Commander(Unit... children) {
		super(children);
	}
	
	@Override
	public void accept(UnitVisitor visitor) {
		visitor.visit(this);
		super.accept(visitor);
	}
	
	@Override
	public String toString() {
		return "commander";
	}
}

public class Sergeant extends Unit {

	public Sergeant(Unit... children) {
		super(children);
	}
	
	@Override
	public void accept(UnitVisitor visitor) {
		visitor.visit(this);
		super.accept(visitor);
	}
	
	@Override
	public String toString() {
		return "sergeant";
	}
}

public class Soldier extends Unit {

	public Soldier(Unit... children) {
		super(children);
	}
	
	@Override
	public void accept(UnitVisitor visitor) {
		visitor.visit(this);
		super.accept(visitor);
	}
	
	@Override
	public String toString() {
		return "soldier";
	}
}
```

Вот конкретные посетители `CommanderVisitor`, `SergeantVisitor` и `SoldierVisitor`.
```java
@Slf4j
public class CommanderVisitor implements UnitVisitor {

	@Override
	public void visit(Soldier soldier) {
		// Do nothing
	}
	
	@Override
	public void visit(Sergeant sergeant) {
		// Do nothing
	}
	
	@Override
	public void visit(Commander commander) {
		LOGGER.info("Good to see you {}", commander);
	}
}

@Slf4j
public class SergeantVisitor implements UnitVisitor {

	@Override
	public void visit(Soldier soldier) {
		// Do nothing
	}
	
	@Override
	public void visit(Sergeant sergeant) {
		LOGGER.info("Hello {}", sergeant);
	}
	
	@Override
	public void visit(Commander commander) {
		// Do nothing
	}
}

@Slf4j
public class SoldierVisitor implements UnitVisitor {

	@Override
	public void visit(Soldier soldier) {
		LOGGER.info("Greetings {}", soldier);
	}
	
	@Override
	public void visit(Sergeant sergeant) {
		// Do nothing
	}
	
	@Override
	public void visit(Commander commander) {
		// Do nothing
	}
}
```

Наконец, мы можем продемонстрировать силу посетителей в действии.
```java
public static void main(String[] args) {

    var commander = new Commander(
		new Sergeant(new Soldier(), new Soldier(), new Soldier()),
		new Sergeant(new Soldier(), new Soldier(), new Soldier())
    );
    commander.accept(new SoldierVisitor());
    commander.accept(new SergeantVisitor());
    commander.accept(new CommanderVisitor());
}
```

Вывод программы:
```
Greetings soldier
Greetings soldier
Greetings soldier
Greetings soldier
Greetings soldier
Greetings soldier
Hello sergeant
Hello sergeant
Good to see you commander
```
## Применимость
- **Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.**
Посетитель позволяет применять одну и ту же операцию к объектам различных классов.

- **Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.**
Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции.

- **Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.**
Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.
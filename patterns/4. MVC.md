Взято с [Otus](https://otus.ru/journal/chto-takoe-model-mvc/), [SkillBox](https://skillbox.ru/media/code/chto_takoe_mvc_bazovye_kontseptsii_i_primer_prilozheniya/), [doka](https://doka.guide/tools/architecture-mvc/).
# MVC
Модель **MVC** представляет собой шаблон (паттерн) программирования, позволяющий делить логику программного приложения на 3 части. Расшифровка аббревиатуры довольно проста:
- **M — Model (Модель)**. Model получает данные от контроллера, осуществляет выполнение нужных операций, а потом передаёт данные во View;
- **V — View (Вид, Представление)**. View получает данные от Model с последующим выводом их для пользователя;
- **C — Controller (Контроллер)**. Контроллер в MVC — это блок, обрабатывающий действия пользователя и проверяющий полученную информацию, которая затем передаётся в Model.
![mvc1](/pictures/mvc1.jpg)

Таким образом, модель MVC — это особый **способ организации кода**, предполагающий выделение блоков, каждый из которых будет отвечать за решение своих задач. Один отвечает за данные программного приложения, другой — за внешний вид, третий — за работу приложения. В этом контексте компоненты можно описать следующим образом:
- **Модель** — отвечает за данные, определяет структуру программного приложения;
- **Представление** — обеспечивает взаимодействие с пользователем. Определяет внешний вид программного приложения, а также способы его использования;
- **Контроллер** — это компонент, отвечающий в паттерне MVC за связь между Моделью и Представлением. Его код определяет, как веб-сайт реагирует на действия пользователя. Можно назвать этот блок **мозгом** приложения.
## Пример
Чтобы лучше вникнуть в этот паттерн, стоит применить его на практике. Для этого сверстайте такую форму:
```xml
<StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
	<StackPanel Orientation="Horizontal">
		<TextBox Name="Num1TextBox" Margin="5" Width="50"/>
		<TextBlock Text="+" Margin="5" FontWeight="Bold"/>
		<TextBox Name="Num2TextBox" Margin="5" Width="50"/>
	</StackPanel>
	<TextBlock Text="0" Name="ResultTextBlock" TextAlignment="Center" Margin="5"/>
	<Button Content="Посчитать" Name="CalculateButton" Click="CalculateButton_Click" Margin="5"/>
</StackPanel>
```

Это и есть **View** — его видит пользователь. Тут есть кнопка, при нажатии на которую вызывается Controller:
```c#
private void CalculateButton_Click(object sender, RoutedEventArgs e) {
	// Метод, который вызывается при нажатии на кнопку "Посчитать"
	
	// Валидация полученных данных
	string text1 = Num1TextBox.Text.Trim();
	string text2 = Num2TextBox.Text.Trim();

	int num1 = 0;
	int num2 = 0;

	if (!string.IsNullOrEmpty(text1) && !string.IsNullOrEmpty(text2)) {
		try {
			num1 = Convert.ToInt32(text1);
			num2 = Convert.ToInt32(text2);
		}
		catch (Exception exc) { }

		Calculate(num1, num2); // Передача данных модели
	}
}
```

**Контроллер** получает пользовательский ввод и обрабатывает данные. Он также может проверять права пользователя. Если валидация проходит успешно, данные передаются в Model:
```c#
public void Calculate(int num1, int num2) {
	result = num1 + num2; // Проведение операций с полученными данными

	UpdateView(); // Вызов обновления представления
}
```

**Модель** проводит с этими данными необходимые операции, а затем вызывает метод обновления вида:
```c#
public void UpdateView() {
	ResultTextBlock.Text = result.ToString(); //Изменение вида
}
```
## Похожие паттерны
Каждая из вариаций паттерна MVC — это паттерн, слегка отличающийся от MVC спецификой или ответственностью компонентов. Чтобы лучше понять разницу между ними, советуем прочесть статью «[MVC and its alternatives](https://herbertograca.com/2017/08/17/mvc-and-its-variants/)».
### MVVM, Model-View-Viewmodel
В **MVVM (сокращение от Model—View—Viewmodel)** вместо контроллера используется **Viewmodel**. Это «надстройка» над представлением, которая связывает данные и представление так, что разработчикам больше не нужно писать самим логику обновления UI и обработки команд пользователя.
![mvc2](/pictures/mvc2.webp)

Для работы связывания нужен **Binder (биндер)** — фреймворк, библиотека или целый язык, который автоматически отображает изменения из модели в UI.
### MVP, Model-View-Presenter
В **MVP (сокращение от Model-View-Presenter)** место контроллера занимает **презентер**.

Главное отличие от MVC в том, как расположены компоненты и, соответственно, как передаются данные. Если в MVC данные передавались по кругу, то в MVP компоненты располагаются по линии. На концах находятся модель и представление, а между ними — презентер.
![mvc3](/pictures/mvc3.webp)

Презентер забирает на себя всю логику обработки данных, обновления представления и обработки пользовательских команд.

Представление в этом случае пассивно: оно не делает ничего, кроме отображения данных так, как ему скажет презентер. Если в MVC представление могло брать форматирование вывода на себя, то в MVP за это тоже будет отвечать презентер.

Плюс такого подхода в том, что не возникает вопросов, какой код к чему относится. Минус — в том, что презентер быстро становится большим и сложным. Приходится разбивать его на модули поменьше, вероятно, добавлять дополнительные «слои».
Взято с Habr ([1](https://habr.com/ru/companies/ruvds/articles/438796/)), ([2](https://habr.com/ru/companies/ruvds/articles/439978/)), ([3](https://habr.com/ru/companies/ruvds/articles/439980/)), ([4](https://habr.com/ru/companies/ruvds/articles/440660/)), [SkillBox](https://skillbox.ru/media/code/kak-rabotaet-docker-podrobnyy-gayd-ot-tekhlida/).
# Docker
**Docker** — это платформа, которая позволяет упаковать в контейнер приложение со всем окружением и зависимостями, а затем доставить и запустить его в целевой системе.

Приложение, упакованное в контейнер, изолируется от операционной системы и других приложений. Поэтому разработчики могут не задумываться, в каком окружении будет работать их приложение, а инженеры по эксплуатации — единообразно запускать приложения и меньше заботиться о системных зависимостях.
## Концепции
### Виртуальные машины
Предшественниками контейнеров Docker были виртуальные машины. Виртуальная машина, как и контейнер, изолирует от внешней среды приложение и его зависимости. Однако контейнеры Docker обладают преимуществами перед виртуальными машинами. Так, они потребляют меньше ресурсов, их очень легко переносить, они быстрее запускаются и приходят в работоспособное состояние.

Контейнеры и виртуальные машины — это разные способы виртуализации. Только виртуалка реализует её на уровне железа, а Docker — на уровне операционной системы.

Виртуальная машина функционирует как отдельный компьютер с собственным оборудованием и операционной системой. Распространённая практика — купить большой сервер и установить на него гипервизор, базу для виртуалок. Сервер «нарезается» на много виртуальных компьютеров, что избавляет нас от необходимости покупать их отдельно.

Виртуальные компьютеры вполне полноценны. На них можно установить операционную систему любого семейства и работать в ней, например, через графический интерфейс в многопользовательском режиме, устанавливая и запуская множество приложений и сервисов.

Если цель виртуалки — полностью воспроизвести устройство компьютера, то **основная цель Docker — создать среду для одного приложения**. Виртуальная среда контейнера запускается внутри операционной системы. Ей не нужно виртуализировать оборудование — она использует его через ОС. Поэтому контейнеры Docker потребляют меньше ресурсов, быстрее развёртываются, проще масштабируются и меньше весят.

> Выделять под приложение целую виртуалку, устанавливать и настраивать операционную систему, раздавать права доступа — слишком дорого. В большинстве случаев достаточно простого окружения, в котором запустится приложение. Для этого как раз подходит контейнер, который вмещает одно главное приложение.

Оба способа изолируют приложение от основной операционной системы, но если на виртуалку можно поставить любую ОС, то Docker ориентирован на ядро Linux.
### Образ (Image) контейнера
То, что в терминологии Docker называется «**образом**», или, по-английски, «**image**», это совсем не то же самое, что, например, фотография (это — одно из значений слова «image»).

Образы контейнеров Docker можно сравнить с чертежами, с формочками для печенья, или с пресс-формами для изготовления пластиковых изделий. **Образы** — это неизменные шаблоны, которые используются для создания одинаковых контейнеров.

В образе контейнера Docker содержится образ базовой операционной системы, код приложения, библиотеки, от которого оно зависит. Всё это скомпоновано в виде единой сущности, на основе которой можно создать контейнер.
### Файл Dockerfile
Файл **Dockerfile** содержит набор инструкций, следуя которым Docker будет собирать образ контейнера. Этот файл содержит описание базового образа, который будет представлять собой исходный слой образа. Среди популярных официальных базовых образов можно отметить [python](https://hub.docker.com/_/python/), [ubuntu](https://hub.docker.com/_/ubuntu), [alpine](https://hub.docker.com/_/alpine).

В образ контейнера, поверх базового образа, можно добавлять дополнительные слои. Делается это в соответствии с инструкциями из Dockerfile. Например, если Dockerfile описывает образ, который планируется использовать для решения задач машинного обучения, то в нём могут быть инструкции для включения в промежуточный слой такого образа библиотек NumPy, Pandas и Scikit-learn.

И, наконец, в образе может содержаться, поверх всех остальных, ещё один тонкий слой, данные, хранящиеся в котором, поддаются изменению. Это — небольшой по объёму слой, содержащий программу, которую планируется запускать в контейнере.
### Контейнер Docker
Для того чтобы запустить **контейнер**, нам нужен, во-первых, образ контейнера, во-вторых — среда, в которой установлен Docker, способная понять команду вида `docker run image_name`. Эта команда создаёт контейнер из образа и запускает его.
### Репозиторий контейнеров
Если вы хотите дать возможность другим людям создавать контейнеры на основе вашего образа, вы можете отправить этот образ в **облачное хранилище**. Самым крупным подобным хранилищем является репозиторий [Docker Hub](https://hub.docker.com/). Он используется при работе с Docker по умолчанию.
# Термины экосистемы Docker
## Механизмы Docker
### Платформа (Platform) Docker
**Платформа Docker** ([Docker Platform](https://docs.docker.com/engine/docker-overview/#the-docker-platform)) — это программа, которая даёт нам возможность упаковывать приложения в контейнеры и запускать их на серверах. Платформа Docker позволяет помещать в контейнеры код и его зависимости. Как результат, системы, основанные на контейнерах, легко масштабировать, так как контейнеры можно переносить и воспроизводить.
### Движок (Engine) Docker
**Движок Docker** ([Docker Engine](https://www.docker.com/products/docker-engine)) — это клиент-серверное приложение. Компания Docker разделила движок Docker на два продукта. [Docker Community Edition](https://docs.docker.com/install/) (CE) — это бесплатное ПО, во многом основанное на опенсорсных инструментах.

Вероятно, вы будете пользоваться именно этой версией Docker. [Docker Enterprise](https://www.docker.com/products/docker-enterprise) — это платная версия системы, дающая пользователям дополнительные возможности в области поддержки систем, управления ими и безопасности. Платная версия Docker даёт компании средства, необходимые для её существования.
### Клиент (Client) Docker
![docker1](/pictures/docker1.png)

**Клиент Docker** ([Docker Client](https://docs.docker.com/engine/docker-overview/)) — это основное средство, которое используют для взаимодействия с Docker. Так, при работе с интерфейсом командной строки Docker ([Docker Command Line Interface](https://docs.docker.com/engine/reference/commandline/cli/), CLI), в терминал вводят команды, начинающиеся с ключевого слова `docker`, обращаясь к клиенту. Затем клиент использует API Docker для отправки команд демону Docker.
### Демон (Daemon) Docker
**Демон Docker** ([Docker Daemon](https://docs.docker.com/engine/docker-overview/)) — это сервер Docker, который ожидает запросов к API Docker. Демон Docker управляет образами, контейнерами, сетями и томами.
### Тома (Volumes) Docker
**Тома Docker** ([Docker Volumes](https://docs.docker.com/storage/volumes/)) представляют собой наиболее предпочтительный механизм постоянного хранения данных, потребляемых или производимых приложениями.
### Реестр (Registry) Docker
**Реестр Docker** ([Docker Registry](https://hub.docker.com/)) представляет собой удалённую платформу, используемую для хранения образов Docker. В ходе работы с Docker образы отправляют в реестр и загружают из него. Подобный реестр может быть организован тем, кто пользуется Docker. Кроме того, поставщики облачных услуг могут поддерживать и собственные реестры. Например, это касается [AWS](https://aws.amazon.com/ecr/) и [Google Cloud](https://cloud.google.com/container-registry/).
### Хаб (Hub) Docker
**Хаб Docker** ([Docker Hub](https://hub.docker.com/)) — это самый крупный реестр образов Docker. Кроме того, именно этот реестр используется при работе с Docker по умолчанию. Пользоваться хабом Docker можно бесплатно.
### Репозиторий (Repository) Docker
**Репозиторием Docker** ([Docker Repository](https://docs.docker.com/docker-hub/repos/)) называют набор образов Docker, обладающих одинаковыми именами и разными тегами. Теги — это идентификаторы образов.

Обычно в репозиториях хранятся разные версии одних и тех же образов. Например, [Python](https://hub.docker.com/_/python) — это имя популярнейшего официального репозитория Docker на хабе Docker. А вот Python:3.7-slim — это версия образа с тегом 3.7-slim в репозитории Python. В реестр можно отправить как целый репозиторий, так и отдельный образ.
## Масштабирование решений, основанных на контейнерах
### Сеть (Networking) Docker
![docker2](/pictures/docker2.png)

**Сетевые механизмы Docker** ([Docker Networking](https://docs.docker.com/engine/tutorials/networkingcontainers/)) позволяют организовывать связь между контейнерами Docker. Соединённые с помощью сети контейнеры могут выполняться на одном и том же хосте или на разных хостах.
### Docker Compose
**[Docker Compose](https://docs.docker.com/compose/)** — это инструмент, который упрощает развёртывание приложений, для работы которых требуется несколько контейнеров Docker. Docker Compose позволяет выполнять команды, описываемые в файле *docker-compose.yml*. Эти команды можно выполнять столько раз, сколько потребуется. Интерфейс командной строки Docker Compose упрощает взаимодействие с многоконтейнерными приложениями. Этот инструмент устанавливается при установке Docker.
### Docker Swarm
**[Docker Swarm](https://docs.docker.com/engine/swarm/)** — это решение, предназначенное для управления контейнерными развёртываниями (то есть, как говорят, для оркестрации контейнеров).
### Сервисы (Services) Docker
**Сервисы Docker** ([Docker Services](https://docs.docker.com/get-started/part3/#introduction)) — это различные части распределённого приложения. Вот что о них говорится в [документации](https://docs.docker.com/get-started/part3/#introduction):  
> **Сервисы** — это всего лишь «контейнеры в продакшне». В пределах сервиса выполняется лишь один образ, но сервис определяет то, как именно выполняется образ. В частности, речь идёт о том, какие порты должны использоваться, сколько реплик контейнера должно выполняться для того, чтобы сервис обеспечивал бы необходимую вычислительную мощность, и так далее. Масштабирование сервисов предусматривает изменение количества экземпляров контейнера, в которых работает некая программа, благодаря чему сервису выделяется столько системных ресурсов, сколько ему требуется для решения некоей задачи. 
  
Сервисы Docker позволяют масштабировать контейнеры в пределах нескольких демонов Docker, благодаря им существует и технология Docker Swarm.
### Kubernetes
**[Kubernetes](https://kubernetes.io/)** — это технология, которая позволяет автоматизировать развёртывание и масштабирование контейнеризированных приложений, а также управление ими. Это — бесспорный лидер рынка средств для оркестрации контейнеров. Если вам нужен инструмент для работы с группами контейнеров, для масштабирования решений, основанных на них, используйте не Docker Swarm, а Kubernetes. Kubernetes не является частью Docker. Они с Docker, скорее, похожи на лучших друзей.
# Dockerfile
## Образы Docker
Вспомните о том, что контейнер Docker — это образ Docker, вызванный к жизни. Это — самодостаточная операционная система, в которой имеется только самое необходимое и код приложения.

Образы Docker являются результатом процесса их сборки, а контейнеры Docker — это выполняющиеся образы. В самом сердце Docker находятся файлы **Dockerfile**. Подобные файлы сообщают Docker о том, как собирать образы, на основе которых создаются контейнеры.

Каждому образу Docker соответствует файл, который называется ***Dockerfile***. Его имя записывается именно так — без расширения. При запуске команды `docker build` для создания нового образа подразумевается, что *Dockerfile* находится в текущей рабочей директории. Если этот файл находится в каком-то другом месте, его расположение можно указать с использованием флага `-f`.

Контейнеры состоят из слоёв. Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения. Dockerfile сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.

Каждый слой, на самом деле, это всего лишь файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.

**Базовый образ** — это то, что является исходным слоем (или слоями) создаваемого образа. Базовый образ ещё называют родительским образом.

Когда образ загружается из удалённого репозитория на локальный компьютер, то физически скачиваются лишь слои, которых на этом компьютере нет. Docker стремится экономить пространство и время путём повторного использования существующих слоёв.
## Файлы Dockerfile
В **файлах Dockerfile** содержатся инструкции по созданию образа. С них, набранных заглавными буквами, начинаются строки этого файла. После инструкций идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз. Вот как это выглядит:
```dockerfile
FROM ubuntu:18.04
COPY . /app
```

**Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`**. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать, например — открыть какой-то порт или выполнить какую-то команду.
## Инструкции Dockerfile и примеры их использования
1. `FROM` — задаёт базовый (родительский) образ.
2. `LABEL` — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
3. `ENV` — устанавливает постоянные переменные среды.
4. `RUN` — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
5. `COPY` — копирует в контейнер файлы и папки.
6. `ADD` — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
7. `CMD` — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`.
8. `WORKDIR` — задаёт рабочую директорию для следующей инструкции.
9. `ARG` — задаёт переменные для передачи Docker во время сборки образа.
10. `ENTRYPOINT` — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.
11. `EXPOSE` — указывает на необходимость открыть порт.
12. `VOLUME` — создаёт точку монтирования для работы с постоянным хранилищем.
### Простой Dockerfile
Dockerfile может быть чрезвычайно простым и коротким. Например — таким:  
```dockerfile
FROM ubuntu:18.04
```
### Инструкция `FROM`
**Файл Dockerfile должен начинаться с инструкции `FROM`, или с инструкции `ARG`, за которой идёт инструкция `FROM`.**

Ключевое слово [**`FROM`**](https://docs.docker.com/engine/reference/builder/#from) сообщает Docker о том, чтобы при сборке образа использовался бы базовый образ, который соответствует предоставленному имени и тегу. Базовый образ, кроме того, ещё называют [родительским образом](https://docs.docker.com/develop/develop-images/baseimages/).

В этом примере базовый образ хранится в репозитории [ubuntu](https://hub.docker.com/_/ubuntu). Ubuntu — это название официального репозитория Docker, предоставляющего базовую версию популярной ОС семейства Linux, которая называется Ubuntu.

Обратите внимание на то, что рассматриваемый Dockerfile включает в себя тег `18.04`, уточняющий то, какой именно базовый образ нам нужен. Именно этот образ и будет загружен при сборке нашего образа. Если тег в инструкцию не включён, тогда Docker исходит из предположения о том, что требуется самый свежий образ из репозитория. Для того чтобы яснее выразить свои намерения, автору Dockerfile рекомендуется указывать то, какой именно образ ему нужен.

Когда вышеописанный Dockerfile используется на локальной машине для сборки образа в первый раз, Docker загрузит слои, определяемые образом `ubuntu`. Их можно представить наложенными друг на друга. Каждый следующий слой представляет собой файл, описывающий отличия образа в сравнении с тем его состоянием, в котором он был после добавления в него предыдущего слоя.

При создании контейнера слой, в который можно вносить изменения, добавляется поверх всех остальных слоёв. Данные, находящиеся в остальных слоях, можно только читать.
![docker3](/pictures/docker3.jpg)

Docker, ради эффективности, использует стратегию копирования при записи. Если слой в образе существует на предыдущем уровне и какому-то слою нужно произвести чтение данных из него, Docker использует существующий файл. При этом ничего загружать не нужно.

Когда образ выполняется, если слой нужно модифицировать средствами контейнера, то соответствующий файл копируется в самый верхний, изменяемый слой.

Продолжим рассмотрение инструкций, которые используются в Dockerfile, приведя пример такого файла с более сложной структурой.
### Более сложный Dockerfile
Хотя файл Dockerfile, который мы только что рассмотрели, получился аккуратным и понятным, он устроен слишком просто, в нём используется всего одна инструкция. Кроме того, там нет инструкций, вызываемых во время выполнения контейнера. Взглянем на ещё один файл, который собирает маленький образ. В нём имеются механизмы, определяющие команды, вызываемые во время выполнения контейнера.
```dockerfile
FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
ENV ADMIN="jeff"
RUN apk update && apk upgrade && apk add bash
COPY . ./app
ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 \
/my_app_directory
RUN ["mkdir", "/a_directory"]
CMD ["python", "./my_script.py"]
```

Базой этого образа является официальный образ Python с тегом 3.7.2-alpine3.8. Проанализировав [этот](https://github.com/docker-library/python/blob/ab8b829cfefdb460ebc17e570332f0479039e918/3.7/alpine3.8/Dockerfile) код можно увидеть, что данный базовый образ включает в себя Linux, Python, и, по большому счёту, этим его состав и ограничивается. Образы ОС Alpine весьма популярны в мире Docker. Дело в том, что они отличаются маленькими размерами, высокой скоростью работы и безопасностью. Однако образы Alpine не отличаются широкими возможностями, характерными для обычных операционных систем. Поэтому для того, чтобы собрать на основе такого образа что-то полезное, создателю образа нужно установить в него необходимые ему пакеты.
### Инструкция `LABEL`
Инструкция [**`LABEL`**](https://docs.docker.com/engine/reference/builder/#label) (метка) позволяет добавлять в образ метаданные. В случае с рассматриваемым сейчас файлом, она включает в себя контактные сведения создателя образа. Объявление меток не замедляет процесс сборки образа и не увеличивает его размер. Они лишь содержат в себе полезную информацию об образе Docker, поэтому их рекомендуется включать в файл.
### Инструкция `ENV`
Инструкция [**`ENV`**](https://docs.docker.com/engine/reference/builder/#env) позволяет задавать постоянные переменные среды, которые будут доступны в контейнере во время его выполнения. В предыдущем примере после создания контейнера можно пользоваться переменной `ADMIN`.

Инструкция `ENV` хорошо подходит для задания констант. Если вы используете некое значение в Dockerfile несколько раз, скажем, при описании команд, выполняющихся в контейнере, и подозреваете, что, возможно, вам когда-нибудь придётся сменить его на другое, его имеет смысл записать в подобную константу.

Надо отметить, что в файлах Dockerfile часто существуют разные способы решения одних и тех же задач. Что именно использовать — это вопрос, на решение которого влияет стремление к соблюдению принятых в среде Docker методов работы, к обеспечению прозрачности решения и его высокой производительности. Например, инструкции `RUN`, `CMD` и `ENTRYPOINT` служат разным целям, но все они используются для выполнения команд.
### Инструкция `RUN`
Инструкция [**`RUN`**](https://docs.docker.com/engine/reference/builder/#run) позволяет создать слой во время сборки образа. После её выполнения в образ добавляется новый слой, его состояние фиксируется. Инструкция `RUN` часто используется для установки в образы дополнительных пакетов. В предыдущем примере инструкция `RUN apk update && apk upgrade` сообщает Docker о том, что системе нужно обновить пакеты из базового образа. Вслед за этими двумя командами идёт команда `&& apk add bash`, указывающая на то, что в образ нужно установить bash.

То, что в командах выглядит как `apk` — это сокращение от [Alpine Linux package manager](https://www.cyberciti.biz/faq/10-alpine-linux-apk-command-examples/) (менеджер пакетов Alpine Linux). Если вы используете базовый образ какой-то другой ОС семейства Linux, тогда вам, например, при использовании Ubuntu, для установки пакетов может понадобиться команда вида `RUN apt-get`.

**Инструкция `RUN` и схожие с ней инструкции — такие, как `CMD` и `ENTRYPOINT`, могут быть использованы либо в exec-форме, либо в shell-форме.** **Exec-форма** использует синтаксис, напоминающий описание JSON-массива. Например, это может выглядеть так: `RUN ["my_executable", "my_first_param1", "my_second_param2"]`.

В предыдущем примере мы использовали **shell-форму** инструкции `RUN` в таком виде: `RUN apk update && apk upgrade && apk add bash`.

Позже в нашем Dockerfile использована exec-форма инструкции `RUN`, в виде `RUN ["mkdir", "/a_directory"]` для создания директории. При этом, используя инструкцию в такой форме, нужно помнить о необходимости оформления строк с помощью двойных кавычек, как это принято в формате JSON.
### Инструкция `COPY`
Инструкция [**`COPY`**](https://docs.docker.com/engine/reference/builder/#copy) представлена в нашем файле так: `COPY . ./app`. Она сообщает Docker о том, что нужно взять файлы и папки из локального контекста сборки и добавить их в текущую рабочую директорию образа. Если целевая директория не существует, эта инструкция её создаст.
### Инструкция `ADD`
Инструкция [**`ADD`**](https://docs.docker.com/engine/reference/builder/#add) позволяет решать те же задачи, что и `COPY`, но с ней связана ещё пара вариантов использования. Так, **с помощью этой инструкции можно добавлять в контейнер файлы, загруженные из удалённых источников, а также распаковывать локальные .tar-файлы**.

В этом примере инструкция `ADD` была использована для копирования файла, доступного по URL, в директорию контейнера `my_app_directory`. Надо отметить, однако, что [документация Docker](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) не рекомендует использование подобных файлов, полученных по URL, так как удалить их нельзя, и так как они увеличивают размер образа.
### Инструкция `CMD`
Инструкция [**`CMD`**](https://docs.docker.com/engine/reference/builder/#cmd) предоставляет Docker команду, которую нужно выполнить при запуске контейнера. Результаты выполнения этой команды не добавляются в образ во время его сборки. В нашем примере с помощью этой команды запускается скрипт *my_script.py* во время выполнения контейнера.

Вот ещё кое-что, что нужно знать об инструкции `CMD`:  
- **В одном файле Dockerfile может присутствовать лишь одна инструкция `CMD`**. Если в файле есть несколько таких инструкций, система проигнорирует все кроме последней.
- Инструкция `CMD` может иметь exec-форму. Если в эту инструкцию не входит упоминание исполняемого файла, тогда в файле должна присутствовать инструкция `ENTRYPOINT`. В таком случае обе эти инструкции должны быть представлены в формате `JSON`.
- **Аргументы командной строки, передаваемые `docker run`, переопределяют аргументы, предоставленные инструкции `CMD` в Dockerfile**.
### Ещё более сложный Dockerfile
Рассмотрим ещё один файл Dockerfile, в котором будут использованы некоторые новые команды.
```dockerfile
FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
# Устанавливаем зависимости
RUN apk add --update git
# Задаём текущую рабочую директорию
WORKDIR /usr/src/my_app_directory
# Копируем код из локального контекста в рабочую директорию образа
COPY . .
# Задаём значение по умолчанию для переменной
ARG my_var=my_default_value
# Настраиваем команду, которая должна быть запущена в контейнере во время его выполнения
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
# Открываем порты
EXPOSE 8000
# Создаём том для хранения данных
VOLUME /my_volume
```

В этом примере, кроме прочего, вы можете видеть комментарии, которые начинаются с символа `#`.  

Одно из основных действий, выполняемых средствами Dockerfile — это установка пакетов. Как уже было сказано, существуют различные способы установки пакетов с помощью инструкции `RUN`.

Пакеты в образ Alpine Docker можно устанавливать с помощью `apk`. Для этого, как мы уже говорили, применяется команда вида `RUN apk update && apk upgrade && apk add bash`.

Кроме того, пакеты Python в образ можно устанавливать с помощью [pip](https://pypi.org/project/pip/), [wheel](https://pythonwheels.com/) и [conda](https://medium.com/@chadlagore/conda-environments-with-docker-82cdc9d25754). Если речь идёт не о Python, а о других языках программирования, то при подготовке соответствующих образов могут использоваться и другие менеджеры пакетов.

При этом для того, чтобы установка была бы возможной, нижележащий слой должен предоставить слою, в который выполняется установка пакетов, подходящий менеджер пакетов. Поэтому если вы столкнулись с проблемами при установке пакетов, убедитесь в том, что менеджер пакетов установлен до того, как вы попытаетесь им воспользоваться.

Например, инструкцию `RUN` в Dockerfile можно использовать для установки списка пакетов с помощью `pip`. Если вы так поступаете — объедините все команды в одну инструкцию и разделите её символами разрыва строки с помощью символа `\`. Благодаря такому подходу файлы будут выглядеть аккуратно и это приведёт к добавлению в образ меньшего количества слоёв, чем было бы добавлено при использовании нескольких инструкций `RUN`.

Кроме того, для установки нескольких пакетов можно поступить и по-другому. Их можно перечислить в файле и передать менеджеру пакетов этот файл с помощью `RUN`. Обычно таким файлам дают имя `requirements.txt`.
### Инструкция `WORKDIR`
Инструкция [**`WORKDIR`**](https://docs.docker.com/v17.09/engine/reference/builder/#workdir) позволяет изменить рабочую директорию контейнера. С этой директорией работают инструкции `COPY`, `ADD`, `RUN`, `CMD` и `ENTRYPOINT`, идущие за `WORKDIR`. Вот некоторые особенности, касающиеся этой инструкции:
- Лучше устанавливать с помощью `WORKDIR` абсолютные пути к папкам, а не перемещаться по файловой системе с помощью команд `cd` в Dockerfile.
- Инструкция `WORKDIR` автоматически создаёт директорию в том случае, если она не существует.
- Можно использовать несколько инструкций `WORKDIR`. Если таким инструкциям предоставляются относительные пути, то каждая из них меняет текущую рабочую директорию.
### Инструкция `ARG`
Инструкция [**`ARG`**](https://docs.docker.com/engine/reference/builder/#arg) позволяет задать переменную, значение которой можно передать из командной строки в образ во время его сборки. Значение для переменной по умолчанию можно представить в Dockerfile. Например: `ARG my_var=my_default_value`.

**В отличие от `ENV`-переменных, `ARG`-переменные недоступны во время выполнения контейнера.** Однако `ARG`-переменные можно использовать для задания значений по умолчанию для `ENV`-переменных из командной строки в процессе сборки образа. А `ENV`-переменные уже будут доступны в контейнере во время его выполнения.
### Инструкция `ENTRYPOINT`
Инструкция [**`ENTRYPOINT`**](https://docs.docker.com/engine/reference/builder/#entrypoint) позволяет задавать команду с аргументами, которая должна выполняться при запуске контейнера. Она похожа на команду `CMD`, но параметры, задаваемые в `ENTRYPOINT`, не перезаписываются в том случае, если контейнер запускают с параметрами командной строки.

Вместо этого аргументы командной строки, передаваемые в конструкции вида `docker run my_image_name`, добавляются к аргументам, задаваемым инструкцией `ENTRYPOINT`. Например, после выполнения команды вида `docker run my_image bash` аргумент `bash` добавится в конец списка аргументов, заданных с помощью `ENTRYPOINT`. Готовя Dockerfile, не забудьте об инструкции `CMD` или `ENTRYPOINT`.

В документации к Docker есть несколько рекомендаций, касающихся того, какую инструкцию, `CMD` или `ENTRYPOINT`, стоит выбрать в качестве инструмента для выполнения команд при запуске контейнера:  
- Если при каждом запуске контейнера нужно выполнять одну и ту же команду — используйте `ENTRYPOINT`.
- Если контейнер будет использоваться в роли приложения — используйте `ENTRYPOINT`.
- Если вы знаете, что при запуске контейнера вам понадобится передавать ему аргументы, которые могут перезаписывать аргументы, указанные в Dockerfile, используйте `CMD`.

В нашем примере использование инструкции `ENTRYPOINT ["python", "my_script.py", "my_var"]` приводит к тому, что контейнер, при запуске, запускает Python-скрипт `my_script.py` с аргументом `my_var`. Значение, представленное `my_var`, потом можно использовать в скрипте с помощью [argparse](https://docs.python.org/3/library/argparse.html). Обратите внимание на то, что в Dockerfile переменной `my_var`, до её использования, назначено значение по умолчанию с помощью `ARG`. В результате, если при запуске контейнера ему не передали соответствующее значение, будет применено значение по умолчанию.

Документация Docker рекомендует использовать exec-форму `ENTRYPOINT`: `ENTRYPOINT ["executable", "param1", "param2"]`.
### Инструкция `EXPOSE`
Инструкция [**`EXPOSE`**](https://docs.docker.com/engine/reference/builder/#expose) указывает на то, какие порты планируется открыть для того, чтобы через них можно было бы связаться с работающим контейнером. Эта инструкция не открывает порты. Она, скорее, играет роль документации к образу, средством общения того, кто собирает образ, и того, кто запускает контейнер.

Для того чтобы открыть порт (или порты) и настроить перенаправление портов, нужно выполнить команду `docker run` с ключом `-p`. Если использовать ключ в виде `-P` (с заглавной буквой `P`), то открыты будут все порты, указанные в инструкции `EXPOSE`.
### Инструкция `VOLUME`
Инструкция [**`VOLUME`**](https://docs.docker.com/engine/reference/builder/#volume) позволяет указать место, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами.
# Команды Docker
## Общие сведения о командах Docker
Вот кое-что, о чём полезно знать тем, кто хочет работать с Docker:  
- **Команды интерфейса командной строки Docker, используемые для управления чем-либо, начинаются с ключевого слова `docker`, за которым идёт пробел, затем идёт указание на то, на что именно будет направлена некая команда, потом ещё один пробел, а потом следует сама команда.** Например, именно так построена такая команда: `docker container stop`.
- Если команда направлена на конкретный образ или контейнер, то в ней используется имя или идентификатор такого образа или контейнера.

Например, команда `docker container run my_app` — это команда для создания и запуска контейнера с именем `my_app`. В примерах, которые будут приведены ниже, контейнеры мы будем называть `my_container`, образы — `my_image`, теги — `my_tag`, и так далее.

Сначала мы будем рассматривать саму команду, потом — флаги, которые можно с ней использовать, если такие флаги существуют. Если перед флагом стоит два тире — то это его полная форма, флаг с одним тире — это сокращённый вариант некоего флага. Действуют они одинаково. Например, `-p` — это сокращённая форма флага `--port`.
## Команды для управления контейнерами
Общая схема команд для управления контейнерами выглядит так:  
```shell
docker container my_command
```

Вот команды, которые могут быть подставлены туда, где мы использовали `my_command`:  
- `create` — создание контейнера из образа.
- `start` — запуск существующего контейнера.
- `run` — создание контейнера и его запуск.
- `ls` — вывод списка работающих контейнеров.
- `inspect` — вывод подробной информации о контейнере.
- `logs` — вывод логов.
- `stop` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGTERM`, и, через некоторое время, `SIGKILL`.
- `kill` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала `SIGKILL`.
- `rm` — удаление остановленного контейнера.
## Команды для управления образами
Для управления образами используются команды, которые выглядят так:  
```shell
docker image my_command
```

Вот некоторые из команд этой группы:  
- `build` — сборка образа.
- `push` — отправка образа в удалённый реестр.
- `ls` — вывод списка образов.
- `history` — вывод сведений о слоях образа.
- `inspect` — вывод подробной информации об образе, в том числе — сведений о слоях.
- `rm` — удаление образа.
## Разные команды
- `docker version` — вывод сведений о версиях клиента и сервера Docker.
- `docker login` — вход в реестр Docker.
- `docker system prune` — удаление неиспользуемых контейнеров, сетей и образов, которым не назначено имя и тег.
## Контейнеры
### Начало существования контейнера
На начальном этапе работы с контейнерами используются команды **`create`**, **`start`** и **`run`**. Они применяются, соответственно, для создания контейнера, для его запуска, и для его создания и запуска.

Вот команда для создания контейнера из образа:  
```shell
docker container create my_repo/my_image:my_tag
```

В следующих примерах конструкция `my_repo/my_image:my_tag` будет сокращена до `my_image`.  
Команда `create` принимает множество [флагов](https://docs.docker.com/engine/reference/commandline/container_create/). Например, её можно записать в таком виде:
```shell
docker container create -a STDIN my_image
```

Флаг `-a` представляет собой краткую форму флага `--attach`. Этот флаг позволяет подключить контейнер к `STDIN`, `STDOUT` или `STDERR`.

После того, как контейнер создан, его можно запустить следующей командой:  
```shell
docker container start my_container
```

Обратите внимание на то, что сослаться на контейнер в команде можно либо используя его `ID`, либо имя.  
  
Теперь взглянем на команду, которая позволяет создать и запустить контейнер:  
```shell
docker container run my_image
```

Эта команда тоже способна принимать множество [аргументов](https://docs.docker.com/engine/reference/commandline/container_run/) командной строки. Рассмотрим некоторые из них на примере такой конструкции:  
```shell
docker container run -i -t -p 1000:8000 --rm my_image
```

Флаг `-i` — это сокращение для `--interactive`. Благодаря этому флагу поток `STDIN` поддерживается в открытом состоянии даже если контейнер к `STDIN` не подключён.  

Флаг `-t` — это сокращение для `--tty`. Благодаря этому флагу выделяется псевдотерминал, который соединяет используемый терминал с потоками `STDIN` и `STDOUT` контейнера.  

Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги `-i` и `-t`.  
  
Флаг `-p` представляет собой сокращение для `--port`. Порт — это интерфейс, благодаря которому контейнер взаимодействует с внешним миром. Конструкция `1000:8000` перенаправляет порт Docker `8000` на порт `1000` компьютера, на котором выполняется контейнер. Если в контейнере работает некое приложение, способное выводить что-то в браузер, то, для того, чтобы к нему обратиться, в нашем случае можно перейти в браузере по адресу `localhost:1000`.  
  
Флаг `--rm` автоматически удаляет контейнер после того, как его выполнение завершится.

Рассмотрим ещё некоторые примеры команды `run`:
```shell
docker container run -it my_image my_command
```

В подобной конструкции может применяться команда `sh`, которая создаст сессию терминала в контейнере, с которой можно взаимодействовать через ваш терминал. При работе с образами, основанными на Alpine, лучше ориентироваться на использование `sh` а не `bash`, так как в этих образах, по умолчанию, оболочка `bash` не установлена. Для выхода из интерактивной сессии воспользуйтесь командой `exit`.  
  
Обратите внимание на то, что здесь мы скомбинировали флаги `-i` и `-t` в `-it`.

Вот ещё один пример работы с командой `run`:  
```shell
docker container run -d my_image
```
  
Флаг `-d` — это сокращение для `--detach`. Эта команда запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.
### Проверка состояния контейнера
Если у вас имеются запущенные контейнеры Docker и вы хотите узнать о том, что это за контейнеры, вам понадобится вывести их список. Сделать это можно такой командой:  
```shell
docker container ls
```

Эта команда выводит список выполняющихся контейнеров и снабжает этот список некоторыми полезными сведениями о них. Вот ещё один пример этой команды:  
```shell
docker container ls -a -s
```

Ключ `-a` этой команды — это сокращение для `--all`. Благодаря использованию этого ключа можно вывести сведения обо всех контейнерах, а не только о выполняющихся.  

Ключ `-s` — это сокращение для `--size`. Он позволяет вывести размеры контейнеров.

Вот команда, которая выводит подробные сведения о контейнере:  
```shell
docker container inspect my_container
```

Вот команда, выводящая логи контейнера:  
```shell
docker container logs my_container
```
### Завершение работы контейнера
Иногда работающий контейнер надо остановить. Для этого используется такая команда:  
```shell
docker container stop my_container
```

Она позволяет останавливать работающие контейнеры, позволяя им корректно завершить работу. У контейнера есть, по умолчанию, 10 секунд, на то, чтобы завершить работу.  
  
Если же контейнер нужно остановить быстро, не заботясь о корректном завершении его работы, можно воспользоваться такой командой:  
```shell
docker container kill my_container
```

Команда `kill`, если сравнить работающий контейнер с включенным телевизором, напоминает выключение телевизора путём отключения его от электричества. Поэтому, в большинстве ситуаций, для остановки контейнеров рекомендуется использовать команду `stop`.

Вот команда, которая позволяет быстро остановить все работающие контейнеры:
```shell
docker container kill $(docker ps -q) 
```

Для удаления остановленного контейнера можно воспользоваться такой командой:
```shell
docker container rm my_container
```

Вот команда, которая позволяет удалить все контейнеры, которые на момент вызова этой команды не выполняются:  
```shell
docker container rm $(docker ps -a -q)
```

Подведём итоги этого раздела. **Сначала контейнер создают**, **потом его запускают, или комбинируют эти два шага**, используя команду вида `docker run my_container`. После этого запускается контейнеризированное приложение.  
  
**Потом контейнер останавливают** командой `docker stop my_container`. Для удаления контейнера используется команда `docker rm my_container`.  
  
Поговорим теперь о командах, используемых для работы с образами, с теми самыми шаблонами, из которых создают контейнеры.
## Образы
### Создание образов
Вот команда, которая позволяет собирать образы Docker:  
```shell
docker image build -t my_repo/my_image:my_tag .
```

В данном случае создаётся образ с именем `my_image`, при его сборке используется файл Dockerfile, находящийся по указанному пути или URL.  

Флаг `-t` — это сокращение для `--tag`. Он указывает Docker на то, что создаваемому образу надо назначить предоставленный в команде тег. В данном случае это `my_tag`.  
  
Точка в конце команды указывает на то, что образ надо собрать с использованием файла Dockerfile, находящегося в текущей рабочей директории.  
  
После того, как образ собран, его можно отправить в удалённый реестр. Благодаря этому им смогут воспользоваться другие люди, его можно будет загрузить и запустить на другом компьютере. Предположим, вы хотите использовать [Docker Hub](https://hub.docker.com/). Если так — вам понадобится завести там учётную запись. Пользоваться этим ресурсом можно бесплатно.

После того, как вы зарегистрируетесь на Docker Hub, вам нужно войти в систему. И хотя команда, которая для этого используется, напрямую к командам, предназначенным для работы с образами, не относится, её полезно будет рассмотреть именно здесь. Речь идёт о следующей команде:
```shell
docker login
```

Она позволяет войти в учётную запись на Docker Hub. Для входа в систему вам понадобится ввести имя пользователя и пароль.  
  
После входа в систему можно будет отправлять образы в реестр. Делается это так:  
```shell
docker image push my_repo/my_image:my_tag
```

Теперь, когда у вас наберётся несколько образов, вы можете их исследовать с помощью специальных команд.
### Исследование образов
Вот команда, которая выводит список образов, выводя, в том числе, и сведения об их размере:  
```shell
docker image ls
```

Следующая команда позволяет вывести сведения о промежуточных образах, входящих в состав образа, в частности — данные об их размерах и о том, как они были созданы:  
```shell
docker image history my_image
```

Вот команда, которая выводит подробные сведения об образе, в том числе — данные о слоях, из которых состоит образ:  
```shell
docker image inspect my_image
```

Если вы создадите очень много образов, может случиться так, что некоторые из них понадобится удалить.
### Удаление образов
Вот команда, которая позволяет удалить указанный образ:  
```shell
docker image rm my_image
```

Если образ хранится в удалённом репозитории, он оттуда удалён не будет.

Вот команда, которая позволяет удалить все локальные образы:  
```shell
docker image rm $(docker images -a -q) 
```

Пользоваться этой командой стоит с осторожностью, но надо заметить, что при её использовании образы, хранящиеся в удалённом репозитории, удалены не будут. В этом заключается одно из преимуществ хранения образов в репозиториях.  
  
Мы рассмотрели основные команды, используемые для управления контейнерами и образами. Поговорим теперь ещё о некоторых командах.
## Разные команды
Вот команда, которая выводит сведения о версиях клиента и сервера Docker:  
```shell
docker version
```

Эта, уже известная вам команда, применяется для входа в реестр Docker:  
```shell
docker login
```

Такая команда позволяет удалить неиспользуемые контейнеры, сети и образы, которым не назначено имя и тег: 
```shell
docker system prune
```

Вот пример её использования:  
```shell
docker system prune -a --volumes
```

Ключ `-a` — сокращение для `--all`, позволяет удалить неиспользуемые образы, а не только те, которым не назначено имя и тег.  
  
Ключ `--volumes` позволяет удалить неиспользуемые тома.
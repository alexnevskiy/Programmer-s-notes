Взято с [Yandex Cloud](https://yandex.cloud/ru/docs/glossary/grpc?utm_referrer=https%3A%2F%2Fwww.google.com%2F).
# gRPC
**gRPC** (Google Remote Procedure Calling) — система удаленного вызова процедур, разработанная компанией Google.

**Основное назначение** — реализация взаимодействия между микросервисными архитектурами при разработке приложений.

При реализации решений через микросервисные механизмы, каждая логически значимая часть приложения представляет собой законченный программный продукт. Микросервисы взаимодействуют друг с другом, являясь, с точки зрения пользователя, единой системой.

Относительная независимость каждой составляющей системы позволяет разрабатывать, масштабировать и модернизировать микросервисы без изменения программного приложения в целом. Это обеспечивает преимущество модульности микросервисной архитектуре по сравнению с монолитными решениями. Кроме того, микросервисы могут быть реализованы в различных программных средах, обеспечивая гибкий подход к разработке.

При таком подходе к проектированию необходим быстрый, простой и надёжный механизм обмена данными между всеми составляющими программного решения. Такой механизм взаимодействия и предлагает gRPC.

**gRPC представляет собой логическое развитие протокола RPC, являясь полноценным фреймворком** — программным каркасом, объединяющим различные компоненты программных решений в единое целое.

gRPC обеспечивает клиент-серверную структуру обмена данными. Открытый программный код фреймворка, несколько режимов обмена информацией между сервисами (как одно-, так и двунаправленные) и простота реализации коммуникационных взаимодействий позволяют обеспечить поддержку фреймворка в большинстве популярных систем разработки, включая NodeJS, C#, Go, Java и JavaScript.
# Основные составляющие gRPC
Фреймворк gRPC включает в себя три основных составляющих:
1. **Стандарт сериализации данных Protocol Buffers (Protobuf)**. Сериализация подразумевает преобразование текстовых данных в бинарные (двоичные), оптимизированные под быстрый обмен короткими сообщениями.
2. **Протокол передачи данных HTTP/2**. Протокол является дальнейшим развитием гипертекстового протокола HTTP и оптимизирован для работы с бинарными данными. Он позволяет разбивать передачи на отдельные небольшие пакеты и обеспечивает одновременную поддержку нескольких запросов, включая двунаправленную передачу информации.
3. **Язык описания интерфейса IDL**. Предназначен для упрощенного описания сервисов удалённого вызова процедур с возможностью автоматической генерации кода для выбранной программной среды.
## Protobuf
**Protobuf** или **Protocol Buffers** — буферный протокол сериализации (бинарного преобразования) структурированных данных.

Преобразование данных в двоичный формат не зависит от программной платформы, что позволяет объединять микросервисы, реализованные на разных языках программирования. В отличие от структурированных данных текстовых форматов, таких как XML или JSON, **бинарный формат позволяет эффективно сжимать пакеты сообщений при наличии ограничений на размер пакета** (например, в каналах связи с невысокой пропускной способностью).

Удобную сериализацию данных обеспечивает компилятор, который реализует программный код для целевой платформы на основе созданных с помощью кроссплатформенного языка определения интерфейсов (IDL) текстового proto-файла.
## HTTP/2
Транспортный бинарный протокол **HTTP/2** является развитием протокола SPDY, разработанного корпорацией Google.

HTTP/2 не заменяет, а дополняет протокол передачи данных прикладного уровня HTTP 1.1.

Расширение работы включает:
- способы двоичного кадрирования информации (HTTP 1.1 работает с текстовыми данными);
- обеспечение полного мультиплексирования для распараллеливания запросов;
- возможность работы в полнодуплексном режиме с одновременной отправкой запросов клиента и получением ответов от сервера;
- механизмы потоковой передачи наборов данных как со стороны клиента, так и от сервера;
- приоритизацию сообщений;
- сжатие заголовков передаваемых пакетов данных, уменьшающее трафик в сети.

Все это возможно благодаря бинарной природе протокола HTTP/2 и позволяет микросервисам эффективно обмениваться информацией как в различных симплексных (однонаправленных) режимах, так и используя полноценное дуплексное (двунаправленное) соединение с одновременными приёмом и передачей сообщений.
## IDL
**IDL (Interface Definition Language)** — расширение синтаксиса языка Proto Buffers.

IDL в текстовом формате описывает сервисы для удалённого вызова процедур. Синтаксис описания похож на описание классов в языке C++. Сервисы описываются в служебном файле с расширением `proto`.

На основе описаний из `proto`-файла компилятор создаёт исполняемый код для целевой программной платформы. Код включает описание типизированных объектов, используемых при передаче сообщений.
# Как работает gRPC
gRPC обеспечивает обмен информацией между различными источниками и приемниками (микросервисами). Протокол gRPC подразумевает наличие сервера, определяющего правила обмена данными, и возможные ответы на полученное сообщение клиентских сервисов. Клиенты после получения информационных пакетов могут использовать для работы с ними предоставляемые сервером методы.
## Архитектура gRPC
gRPC, как и большинство распределённых сервисов, организован по принципу **клиент-серверной архитектуры**. Клиенты посылают на сервер информационные запросы, сервер предоставляет ответы и методы их обработки. При этом программная реализация клиента и сервера не имеет особого значения благодаря кроссплатформенности протокола gRPC.
![grpc1](/pictures/grpc1.png)
## Режимы работы gRPC
gRPC предусматривает четыре возможных режима взаимодействия сервера и клиента:
- **Однонаправленное (Unary gRPC)**, когда после каждого запроса клиент ждёт ответа от сервера.
- **Потоковая передача сервера (Server streaming gRPC)**, когда в ответ на запрос клиента сервер предоставляет поток сообщений. Для завершения передачи сервер посылает сообщение о состоянии.
- **Потоковая передача клиента (Client streaming gRPC)**, когда сервер принимает поток сообщений от клиента и отвечает одним подтверждающим сообщением.
- **Двунаправленный обмен (Bidirectional streaming gRPC)** с разделением каналов передачи сервера и клиента. В этом случае потоки сообщений одновременно передаются в обоих направлениях.
![grpc2](/pictures/grpc2.png)
# Сравнение gRPC с другими решениями
## Protobuf vs XML, JSON
| Преимущества                                                                                                                                                                                                                                                                       | Недостатки                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **XML и JSON**                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| XML и JSON используют структурированный формат данных, удобный для обращения к ним в программном коде. Дополнительным достоинством такого представления информации является возможность анализа этих структур человеком без предварительного декодирования.                        | Недостатком подобного представления является постоянная необходимость кодирования (сериализации) данных на сервере перед передачей по каналам связи и последующего их декодирования (или десериализации) на клиенте, т.к. физический уровень протоколов обмена понимает только последовательности двоичных данных. Это приводит к увеличению времени передачи, сложности кадрирования информации и повышению вероятности потери отдельных пакетов данных. |
| **Protobuf**                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| gRPC использует бинарный формат хранения данных Protobuf изначально работает с сериализованными данными, что позволяет эффективно обмениваться информацией по низкоскоростным и слабопроизводительным физическим линиям связи без потерь времени на дополнительные преобразования. | Некоторым недостатком при бинарном представлении данных является невозможность чтения их человеком без использования специализированных средств декодирования, в то время как, например, XML-формат является удобочитаемым в обычном текстовом редакторе.                                                                                                                                                                                                 |
## gRPC vs REST
**REST (Representative State Transfer или Передача репрезентативного состояния)** — клиент-серверная сетевая архитектура взаимодействия, при которой разработчик предоставляет упрощённый доступ клиентским приложениям пользователя к ресурсам сервера. Как правило доступ осуществляется через обмен данными в формате JSON или XML.

**Интерфейс прикладного программирования (Application Programming Interface, API)** соответствует технологии REST (является RESTful), если подчиняется определённым требованиям:
- имеет интуитивно понятный внешний вид и предоставляет клиентам доступ к ресурсам серверного приложения;
- имеет многоуровневую архитектуру с разделением функций представления, обработки и управления данными;
- обладает возможностями кэширования (временного хранения) данных приложения;
- сохраняет информацию о состоянии клиентской части только на стороне клиента (сервер при этом информацию о состоянии клиента не хранит);
- разделяет ресурсы серверной и клиентской частей (клиент не обладает полной информацией о серверных ресурсах, ему известны только URL-адреса необходимых компонентов серверного приложения).
![grpc3](/pictures/grpc3.png)

Для доступа пользователя к ресурсам каждого из компонентов микросервисной архитектуры используют запросы с предопределённым набором команд HTTP: `GET`, `PUT`, `POST` и `DELETE`. В качестве параметров команды передают URL адреса запрашиваемых ресурсов.

**RPC (удаленный вызов процедур, Remote Procedure Calling)** — механизм, исполняющий процедуры на стороне сервера, а не клиента. Клиент, инициировавший вызов процедуры, в результате исполнения получает готовый результат (ответ) заранее определённого формата.
![grpc4](/pictures/grpc4.png)

Сообщения пользователя содержат параметры вызова серверных процедур. RPC интерпретирует пользовательские сообщения и передаёт их в качестве запросов на сервер. Серверная часть исполняет запрос и возвращает пользователю в ответном сообщении результат его выполнения.

gRPC — подвид механизма RPC, использующий все преимущества как RPC-механизмов, так и механизмов сериализации передаваемых данных.

Для создания своего сервиса на платформе gRPC разработчику нужно:
1. Определить формат сообщений для обращения к доступным ресурсам сервиса в текстовом `proto`-файле с помощью IDL.
2. Сгенерировать компилятором на основе `proto`-файла классы доступа для языка программирования, выбранного при разработке клиентского приложения.
3. Добавить сгенерированные классы в клиентское приложение для использования соответствующих им методов и ресурсов, предоставляемых серверной частью.

Фреймворк gRPC предоставляет в свободном доступе компиляторы для большинства популярных языков программирования, включая NodeJS, C#, Go, Java и JavaScript.

|**Характеристика**|**REST**|**gRPC**|
|---|---|---|
|Формат сообщений|Структурированный (JSON, XML и другие)|Бинарный (Protobuf)|
|Производительность|Средняя, данные требуют дополнительной сериализации|Высокая, данные изначально сериализованы|
|Скорость обмена|Средняя, обмен однонаправленный (запрос-ответ)|Высокая, обмен двунаправленный или стриминговый|
|Мультиязыковая поддержка|Средняя, требуются сторонние сервисы для мультиязыковых систем|Высокая, встроенная автоматическая генерация кода для популярных языковых сред|
|Поддержка браузерами|Работает на всех|Некоторыми браузерами не поддерживается|
|Сложность реализации|Низкая, сообщения человекочитаемые|Средняя, сообщения бинарные, требуют описания в шаблоне (`proto`-файла)|

Недостатки gRPC во многом связаны с тем, что это относительно новая технология. Могут возникнуть проблемы с поддержкой браузерами, отсутствием необходимой документации по API и невозможностью читать сообщения без расшифровки. В то же время REST не может использовать полный набор преимуществ HTTP/2 и обеспечивать настолько же высокую производительность.

REST — хороший вариант почти в любой ситуации, когда не требуется решать специфические задачи. Архитектура не требует особой квалификации разработчика и обладает обширной базой информации по всем возможным проблемам.

gRPC — подходящий выбор для межсерверного взаимодействия, особенно, если ресурсы устройств ограничены (интернет вещей, смартфоны). Мультиязыковая поддержка также делает технологию удобной для использования в архитектуре микросервисов.
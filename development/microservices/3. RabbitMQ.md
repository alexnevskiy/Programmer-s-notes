Взято с [Habr](https://habr.com/ru/companies/slurm/articles/703060/), [Systems.Education](https://systems.education/what-is-rabbitmq#showmore), [SkillFactory](https://blog.skillfactory.ru/rabbitmq-chto-eto-takoe-i-kak-rabotaet/), Faang.
# RabbitMQ
**RabbitMQ** — это один из популярных брокеров, который служит посредником для обмена информацией между различными системами. Он осуществляет передачу сообщений посредством очередей.

RabbitMQ основан на протоколе **AMQP** (Advanced Message Queuing Protocol).  
Разумеется, RabbitMQ — не единственный подобный инструмент. Также стоит упомянуть ActiveMQ, IBM MQ и LanvinMQ.
# Основы RabbitMQ
![rabbitmq1](/pictures/rabbitmq1.png)

Пробежимся по названиям слева направо:
- **Publisher/Producer** — публикует (паблишит) сообщения в Rabbit.
- **Exchange** — обменник. Сущность Rabbit, точка входа для публикации всех сообщений.
- **Binding** — связь между Exchange и очередью.
- **Queue** — очередь для хранения сообщений.
- **Messages** — сообщение, атомарная сущность.
- **Consumer** — подписывается на очередь и получает от Rabbit сообщения. 

Также встречаются термины:
- **Publishing** — процесс публикации сообщений в обменник.
- **Consuming** — процесс подписки consumer на очередь и получение им сообщений.
- **Routing Key** — свойство Binding.
- **Persistent** — свойство сохранения данных при перезагрузке сервиса (также известное как стейт).
# Publisher/Producer
![rabbitmq2](/pictures/rabbitmq2.png)

**Publisher/Producer** - внешнее приложение, генерирующее сообщения в RabbitMQ для дальнейшей обработки.

Создаёт соединение (**connection**) по протоколу AMQP, в рамках соединения создаёт канал (**channel**). В рамках одного соединения можно создать несколько каналов, но это не рекомендуется даже официальной документацией RabbitMQ.

**«Флаппинг» каналов**: если Publisher для каждого сообщения создаёт соединение, канал, отправляет сообщение, закрывает канал, закрывает соединение, это очень плохая история. Rabbit становится плохо уже на ~300 таких пересозданий каналов в секунду. Будьте внимательны.

Publisher **может декларировать практически все сущности** — exchanges, queues, bindings и др. На практике лучше подходит стратегия декларирования всех нужных сущностей consumer, но решать нужно для каждого проекта индивидуально.

Publisher **всегда пишет в exchange**. Даже если вы думаете, что он пишет напрямую в очередь, это не так. Он пишет в служебный exchange с routing key, совпадающим с названием очереди.

Publisher **определяет `delivery_mode` для каждого сообщения** — так называемый «признак персистентности». Это значит, что сообщение будет сохранено на диске и не исчезнет в случае перезагрузки Rabbit.
- `delivery_mode=1` — не хранить сообщения, быстрее.
- `delivery_mode=2` — хранить сообщения на диске, медленнее, но надёжнее.

Также publisher **определяет Routing Key для каждого сообщения** — признак, по которому идёт дальнейшая маршрутизация в Rabbit.

Publisher может выставлять **confirm флаг — отправлять указания RabbitMQ через отдельный канал подтверждения об успешной приёмке сообщений.** Например, если у Rabbit закончится место на диске, то некоторое время он ещё будет принимать сообщения от Publisher. Publisher будет думать, что всё в порядке, хотя сообщения с высокой долей вероятности не дойдут до Consumer и не сохранятся в очереди для дальнейшей обработки. Полезная вещь, но ощутимо снижает скорость работы и сложно реализуема в однопоточных языках разработки.

Также есть **флаг mandatory — указание Rabbit** **складировать сообщения, не имеющие маршрута в какую-либо очередь в отдельный Exchange**. Редкий и мало используемый кейс.
# Exchange
![rabbitmq3](/pictures/rabbitmq3.png)

**Exchange** - базовая сущность RabbitMQ. Является точкой входа и маршрутизатором/роутером всех сообщений (как входящих от Publisher, так и перемещающихся от внутренних процессов в Rabbit)

**Неизменяемая сущность**: для изменения параметров Exchange нужно его удалять и декларировать заново.

**Binding**: не являются частью Exchange, можно менять отдельно.

**Рассылает сообщение во все очереди с подходящими binding** (но не более одного сообщения в одну очередь, если есть несколько подходящих binding).

Durable/Transient — признак персистентности Exchange. **Durable означает, что exchange** **сохранится после перезагрузки Rabbit**.

**Exchange не подразумевает хранения!** Это не очередь. Если маршрут для сообщения не будет найден, сообщение сразу будет отброшено без возможности его восстановления.
# Binding
![rabbitmq4](/pictures/rabbitmq4.png)

**Binding** - базовая сущность Rabbit, статический маршрут от Exchange до Queue (от обменника до очереди).

**Неизменяемая сущность**: если нужно изменить binding, его удаляют и декларируют заново.

Bindings между парой exchange-queue может быть несколько, но только с разными параметрами.

Параметры binding — или **routingkey**, или **headers** — в зависимости от типа Exchange.
# Типы Exchange
![rabbitmq5](/pictures/rabbitmq5.png)

Выделяют четыре типа Exchange:
- Fanout;
- Direct;
- Topic;
- Headers.
## Fanout
**Fanout** - Exchange публикует сообщения во все очереди, в которых есть binding, игнорируя любые настройки binding (routing key или заголовки).

Самый простой тип и наименее функциональный. Редко бывает нужен. По скоростям выдает на тестах около 30000mps, но столько же выдает и тип **Direct.**

**Пример работы.**

Слева сообщения, на них написаны Routing Key.
![rabbitmq6](/pictures/rabbitmq6.png)

Все три сообщения попадут во все три очереди.
![rabbitmq7](/pictures/rabbitmq7.png)
## Direct
**Direct** - Exchange публикует сообщения во все очереди, в которых Routing Key binding полностью совпадает с Routing Key Messages.

Наиболее популярный тип, по скорости сравнимый с fanout и при этом обладающий необходимой гибкостью для большинства задач.

**Пример работы.**

На binding мы видим Routing key — согласно им происходит маршрутизация в нужные очереди.
![rabbitmq8](/pictures/rabbitmq8.png)

Ожидаемый результат:
![rabbitmq9](/pictures/rabbitmq9.png)
## Topic
**Topic** - тип Exchange, похожий на Direct, но поддерживающий в качестве параметров binding Wildcard `*` и `#`, где:
- `*` — совпадение одного слова (слова разделяются точкой);
- `#` — любое количество слов.

Производительность топика на тестах показала скорости в три раза ниже fanaut/direct — не более 5000-10000mps

**Пример использования:**
![rabbitmq10](/pictures/rabbitmq10.png)

Результат:
![rabbitmq11](/pictures/rabbitmq11.png)
## Headers
**Headers** - наиболее гибкий, но наименее производительный тип. Скорости очень сильно зависят от сложности условий и поэтому трудно прогнозируемы. Оперирует не Routing key, а заголовками сообщений и binding. В binding указываются ожидаемые заголовки, а также признак **x-match,** где:
- **x-match=all** — необходимы **все совпадения** для попадания сообщения;
- **x-match=any** — необходимо **хотя бы одно совпадение.**

**Пример работы.**

На сообщениях и binding написаны заголовки, не routing key!
![rabbitmq12](/pictures/rabbitmq12.png)

Результат:
![rabbitmq13](/pictures/rabbitmq13.png)
# Queue
![rabbitmq14](/pictures/rabbitmq14.png)

**Queue** - базовая сущность RabbitMQ, представляет из себя последовательное хранилище для необработанных сообщений.

Хранение сообщений на диске (persistent) зависит от флага `delivery_mode`, назначаемым publisher для каждого сообщения.

Durable/Transient — признак персистентности очереди. **Durable значит, что exchange сохранится после перезагрузки Rabbit**.

Важно понимать, что даже если вы отправили сообщения с признаком `delivery_mode=2` (persistent), но очередь задекларирована не как Durable, то при перезагрузке Rabbit очередь и все содержащиеся в ней сообщения будут безвозвратно утрачены.

Есть три типа очередей:
- **Classic** — обычная очередь, используется в большинстве случаев.
- **Quorum** — аналог классической очереди, но с обеспечением гарантий консистентности, достигаемый кворумом в кластере.
- **Stream** — новый вид очередей (начиная с версии RabbiMQ 3.9), пока ещё мало кем используемый, аналог принципов Apache Kafka.
# Message
![rabbitmq15](/pictures/rabbitmq15.png)

**Message** - базовая сущность RabbitMQ — само сообщение, несёт полезную нагрузку (payload), проходит весь путь от Publisher до Consumer.

Важные поля:
- **`payload`** — полезная нагрузка, может быть как `string`, так и `base64`. Можно закидывать туда хоть картинки, но потом не надо удивляться огромным трафикам между сервисами. Теоретический лимит размера одного сообщения — 2Gb, но на практике рекомендуемый размер сообщения 128mb;
- **`routing key`** — ключ маршрутизации, может быть только один для одного сообщения;
- **`delivery_mode`** — признак персистентности;
- **`headers`** — заголовки сообщения. Нужны для работы Exchange типа headers, а также для дополнительных возможностей Rabbit типа TTL.
# Consumer
![rabbitmq16](/pictures/rabbitmq16.png)

Замыкает обработку **Сonsumer** — приложение, получающее сообщения из Queue и выполняющий ту самую логику, ради которой сообщение проделало весь этот путь. Например, отправка уведомления, запись в базу данных, генерация оффлайн отчёта или отправка сообщения в другую Queue.

Так же, как и Publisher, Consumer создаёт соединение (**connection**) по протоколу AMQP. В рамках соединения создаёт канал (**channel**) и уже инициирует consuming в рамках этого канала.

Consumer **может декларировать практически все сущности** — exchanges, queues, bindings и т.д. На практике мы стараемся декларировать все сущности именно Consumer, но решать нужно для каждого проекта индивидуально.

Consumer **подписывается только на одну очередь**. Если вы хотите получать сообщения из разных очередей, правильнее будет корректно смаршрутизировать их потоки в одну очередь, чем городить пулы Consumer внутри приложения.

**Сообщения в Consumer попадают по push-модели** — проталкиваются Rabbit в канал по мере их появления и (или) освобождения Consumer. Никакой периодики, задержки — это жирный плюс.

**Prefetch count** — важный параметр Consumer, обозначающий количество неподтверждённых Consumer сообщений в один момент. По умолчанию во многих библиотеках он равен 0 (по сути отключён). В такой ситуации Rabbit проталкивает все сообщения из очереди в Consumer, а тот во многих случаях при достаточном количестве сообщений просто отъезжает.

Если нет понимания, какое значение ставить, лучше ставить «1» — пока Consumer не обработает одно сообщение, следующее к нему не поступит. Как только Rabbit подтвердит обработку, следующее сообщение будет получено незамедлительно. Когда вы поймёте, что у вас есть многопоточность, и вы можете обрабатывать большие нагрузки, вы поднимете этот параметр, но уже осознанно.

Consumer может подтвердить обработку сообщения — **механизм Acknowledge (ack)**. Или вернуть сообщение в Queue при неудачной обработке — **механизм Negative acknowledge (nack)**.

Механизм nack также срабатывает автоматически при разрушении канала к Consumer. Это удобно использовать: если на горячую выключить Consumer, сообщения, которые он обрабатывал, автоматически вернутся в очередь.

**AutoAck** — флаг автоматического подтверждения всех протакливаемых сообщений (не требует ack от Consumer). Работает быстро, но не даёт никаких гарантий успешной обработки сообщений.
# FIFO очереди
Основу Rabbit представляют собой именно такие очереди: FIFO = first in - first out.
![rabbitmq17](/pictures/rabbitmq17.png)

Попадая в очередь, сообщения выходят из неё в той же последовательности, что и вошли. Последовательность определяется моментом попадания сообщения в очередь, не бывает «одновременных сообщений» в рамках одной очереди, у них всегда есть порядок.
![rabbitmq18](/pictures/rabbitmq18.png)

После выстраивания очереди по порядку мы переходим к «обслуживанию» этой очереди. Для этого подключается Consumer (например, как открытие одного кабинета в очереди к врачу).
![rabbitmq19](/pictures/rabbitmq19.png)

Если мы не укажем `prefetch_count`, его значение будет равным нулю. Это значит, что все сообщения протолкнутся в Consumer — ничего хорошего обычно в таком поведении нет. Аналогия: открылся кабинет, и все люди в очереди ввалились туда решать свои вопросы.
![rabbitmq20](/pictures/rabbitmq20.png)

Поэтому мы явно укажем **`prefetch_count=1`**. Теперь без подтверждения более одного сообщения в Consumer находится не сможет.
![rabbitmq21](/pictures/rabbitmq21.png)

Далее после успешной обработки Consumer выполняет «ack» для данного сообщения:
![rabbitmq22](/pictures/rabbitmq22.png)

Получив ack, Rabbit удалит сообщение из очереди и незамедлительно протолкнёт в Consumer следующее сообщение (и так далее):
![rabbitmq23](/pictures/rabbitmq23.png)

А если мы захотим увеличить скорость обработки? Можем поставить в «кабинете» ещё один «стол с врачом». Для этого укажем `prefetch_count=2`.
![rabbitmq24](/pictures/rabbitmq24.png)

Теперь будет идти обработка сразу двух сообщений. А если мы хотим быстрее? Добавляем ещё один сonsumer-кабинет (например с `prefetch_count=1`)
![rabbitmq25](/pictures/rabbitmq25.png)

Общая концепция горизонтальной масштабируемости выглядит именно так.
# RabbitMQ против Kafka
Крупным компаниям, которым требуются надёжные, масштабируемые и удобные в обслуживании системы, следует оценить доступные очереди сообщений по следующим параметрам:
- Функциональность
- Производительность
- Масштабируемость
- Экосистема

В таблице ниже сравниваются два типичных продукта очереди сообщений: RabbitMQ
и Kafka.

|                                 | RabbitMQ                                                         | Kafka                                                                 |
| ------------------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |
| Написан на                      | Erlang                                                           | Scala, Java                                                           |
| Протокол                        | AMQP                                                             | Двоичный протокол поверх TCP                                          |
| API клиента                     | Java, Ruby, JavaScript, Go, C, Swift, Spring, Elixir, PHP и .NET | Java, Ruby, Python, Node.js                                           |
| Гибкие правила маршрутизации    | Поддержка в компоненте Exchange                                  | Нет                                                                   |
| Потребление сообщений           | push                                                             | pull                                                                  |
| Приоритет сообщений             | Да                                                               | Нет                                                                   |
| Упорядочивание сообщений        | Упорядоченные в очереди                                          | Упорядоченные в топике                                                |
| Удаление сообщений              | Удаление по ACK                                                  | Удаление по истечении периода хранения                                |
| Безопасность                    | Управление доступом через админские инструменты                  | TKS, JAAS                                                             |
| Масштабируемость                | RabbitMQ consistent hash exchange                                | Добавление большого числа партиций к топику                           |
| Отказоустойчивость              | Да                                                               | Да                                                                    |
| Нагрузка от скопления сообщений | Плохо справляется                                                | Предназначен для удержания сообщений                                  |
| Производительность              | Десятки тысяч/сек                                                | Миллионы/сек                                                          |
| Экосистема                      | Не так хороша, как у Kafka                                       | Хорошо поддерживается в области больших данных и потоковых вычислений |
## Как они работают
**RabbitMQ работает как промежуточное ПО для обмена сообщениями** - оно отправляет сообщения потребителям, а затем удаляет их после подтверждения. Это позволяет избежать накопления сообщений, которое RabbitMQ считает проблематичным.

**Kafka изначально был создан для массовой обработки журналов**. Он сохраняет сообщения до истечения срока действия и позволяет потребителям извлекать сообщения в своём собственном темпе.
## Языки и API
RabbitMQ написан на Erlang, что делает изменение основного кода сложным. Однако он предлагает очень богатый клиентский API и поддержку библиотек.

Kafka использует Scala и Java, но также имеет клиентские библиотеки и API для популярных языков, таких как Python, Ruby и Node.js.
## Экосистема
Многие современные приложения для больших данных и потоковой передачи данных интегрируют Kafka по умолчанию. Это делает его естественным для этих вариантов использования.
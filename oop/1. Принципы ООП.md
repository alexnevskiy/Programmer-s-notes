Взято с [ИТМО](https://books.ifmo.ru/file/pdf/2139.pdf), [GitHub](https://github.com/enhorse/java-interview/blob/master/oop.md).
# Абстракция
**Абстракция** – это **процесс выделения основных характеристик объекта, игнорируя несущественные детали**. Она позволяет разработчикам создавать модели объектов, определяя их важные свойства и методы, что упрощает понимание и использование объектов.

Ключевые аспекты абстракции:
- **Сокрытие сложных деталей**: Пользователи объектов взаимодействуют с ними на более высоком уровне, не беспокоясь о реализации.
- **Интерфейсы**: Определение интерфейсов позволяет скрыть сложные реализации и предоставить только необходимые методы.
## Пример
```java
// Abstract class
abstract class Animal {

    // Abstract method (does not have a body)
    public abstract void animalSound();

    // Regular method
    public void sleep() {
        System.out.println("Zzz");
    }
}

// Subclass (inherit from Animal)
class Pig extends Animal {

    public void animalSound() {
        // The body of animalSound() is provided here
        System.out.println("The pig says: wee wee");
    }
}

class MyMainClass {

    public static void main(String[] args) {
        Pig myPig = new Pig(); // Create a Pig object
        myPig.animalSound();
        myPig.sleep();
    }
}
```
# Инкапсуляция
**Инкапсуляция** – это **механизм, который связывает код вместе с обрабатываемыми им данными и сохраняет их в безопасности, как от внешнего влияния, так и от ошибочного использования**. При этом сокращается уровень сложности программного обеспечения за счёт образования вокруг объекта защитной оболочки, предохраняющей код и данные от произвольного доступа из других методов, определённых вне этого объекта. От пользователей классов скрывается информация, не имеющая для него значения, и показывается полезная. Таким образом, **инкапсуляция скрывает реализацию класса, предоставляя внешний интерфейс (набор открытых методов), посредством которого обеспечивается и контролируется доступ к данным и коду внутри капсулы**.

При проектировании классов программист должен определить, какие части объекта должны быть доступны для пользователя, а какие следует изолировать в объекте. Детали класса, остающиеся невидимыми для пользователя, называются **инкапсулированными в классе**.

Ключевые аспекты инкапсуляции:
- **Сокрытие данных**: Внутренние составляющие объекта скрыты от внешнего мира. Пользователи объекта взаимодействуют с ним только через заданные методы, что минимизирует вероятность случайного изменения данных.
- **Модули**: Объекты могут рассматриваться как модули, которые могут быть повторно использованы в различных частях программы.
- **Улучшение безопасности**: Ограничение доступа к внутренним данным защитит их от несанкционированного использования.
## Пример
```java
public class AbstractPhone {

    private int year;
    private String company;
    
    public AbstractPhone (int year, String company) {
        this.year = year;
        this.company = company;
    }
    
    private void openConnection(){
        // findComutator
        // openNewConnection...
    }
    
    public void call() {
        openConnection();
        System.out.println("Вызываю номер");
    }

    public void ring() {
        System.out.println("Дзынь-дзынь");
    }
}
```

Модификатор `private` делает доступными поля и методы класса только внутри данного класса. Это означает, что получить доступ к `private` полям из вне невозможно, как и нет возможности вызвать `private` методы.

Сокрытие доступа к методу `openConnection`, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Для работы с нашим объектом мы оставляем открытыми методы `call` и `ring` с помощью модификатора `public`. Предоставление открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть доступ к объекту – он станет бесполезным.
# Наследование
ООП вводит понятие **наследования**, согласно которому **специализированные объекты могут "наследовать" атрибуты и поведение исходных объектов без добавления кода**. Наследование опирается на инкапсуляцию. Оно позволяет строить на основе базового класса новые, добавляя в классы специальные поля данных и дополнительные методы. Исходный класс называется **суперклассом**, новые классы – его **подклассами**, **потомками**. От потомков-подклассов, в свою очередь, можно наследовать атрибуты и методы, получая потомки-подклассы следующего уровня. Наследование вводит иерархию "общее/частное" между классами, в которой подкласс наследует от одного или нескольких более общих суперклассов их свойства и методы. Класс, стоящий на вершине иерархии, от которого унаследованы все остальные (прямо или косвенно), называется базовым классом иерархии.

Использование наследования способствует уменьшению количества кода, созданного для описания схожих сущностей, а также способствует написанию более эффективного и гибкого кода. Наследование исключительно важно, так как позволяет объектно-ориентированным программам увеличивать сложность линейно, а не геометрически, как в структурированном программировании за счёт лучшей локализации изменений.

Ключевые аспекты наследования:
- **Повторное использование кода**: Определение общих атрибутов и методов в родительском классе и их использование в дочерних классах.
- **Специализация**: Дочерние классы могут расширять или изменять поведение родительского класса, добавляя новые методы или переопределяя существующие.
## Пример
Рассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных батарей, которые имеют определённый ресурс работы в часах. Поэтому добавим это свойство в класс беспроводных телефонов:
```java
public abstract class WirelessPhone extends AbstractPhone {

    private int hour;

    public WirelessPhone(int year, int hour) {
        super(year);
        this.hour = hour;
    }
}
```

Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов `call` и `ring`:
```java
public class CellPhone extends WirelessPhone {

    public CellPhone(int year, int hour) {
        super(year, hour);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Вам звонит абонент " + inputNumber);
    }
}
```

И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность. С помощью кода класс можно описать так:
```java
public class Smartphone extends CellPhone {

    private String operationSystem;

    public Smartphone(int year, int hour, String operationSystem) {
        super(year, hour);
        this.operationSystem = operationSystem;
    }
    
    public void install(String program) {
        System.out.println("Устанавливаю " + program + "для" + operationSystem);
    }

}
```

Как видите, для описания класса `Smartphone` мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование этого принципа ООП java позволяет значительно уменьшить объём кода, а значит, и облегчить работу программисту.
# Полиморфизм
**Полиморфизм** – опирается как на инкапсуляцию, так и на наследование и означает, что **объекты, принадлежащие к одной той же ветви иерархии, получая одно и то же сообщение (то есть, когда им предписывается выполнять один и тот же метод), могут действовать по-разному**. Целью полиморфизма, применительно к ООП, является использование одного имени метода для задания общих для класса действий. При этом выполнение каждого конкретного действия будет определяться типом класса.

Ключевые аспекты полиморфизма:
- **Упрощение кода**: Можно использовать один и тот же интерфейс для работы с различными типами объектов.
- **Гибкость системы**: Позволяет легко расширять и изменять код, добавляя новые классы, которые соответствуют одному и тому же интерфейсу.

При правильном применении полиморфизм, инкапсуляция и наследование комбинируются так, что создают некую среду программирования, которая обеспечивает намного более устойчивые масштабируемые программы. Удачно спроектированная иерархия классов является базисом для повторного используемого кода. Инкапсуляция позволяет реализациям мигрировать из проекта в проект без разрушения кода, который зависит от public-интерфейса классов. Полиморфизм позволяет создавать ясный, хорошо модифицируемый и читабельный код.
## Пример
Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:
```java
public class User {

    private String name;

    public User(String name) {
        this.name = name;
    }

    public void callAnotherUser(int number, AbstractPhone phone) {
		// вот он полиморфизм - использование в коде 
		// абстактного типа AbstractPhone phone!
        phone.call(number);
    }
}
```

Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:
```java
public class ThomasEdisonPhone extends AbstractPhone {

    public ThomasEdisonPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вращайте ручку");
        System.out.println("Сообщите номер абонента, сэр");
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
```

Обычный стационарный телефон:
```java
public class Phone extends AbstractPhone {

    public Phone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер" + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
```

И, наконец, крутой видеотелефон:
```java
public class VideoPhone extends AbstractPhone {

    public VideoPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Подключаю видеоканал для абонента " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("У вас входящий видеовызов..." + inputNumber);
    }
}
```

Создадим объекты в методе `main()` и протестируем метод `callAnotherUser`:
```java
AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
AbstractPhone phone = new Phone(1984);
AbstractPhone videoPhone=new VideoPhone(2018);
User user = new User("Андрей");
user.callAnotherUser(224466, firstPhone);
// Вращайте ручку
// Сообщите номер абонента, сэр
user.callAnotherUser(224466, phone);
// Вызываю номер 224466
user.callAnotherUser(224466, videoPhone);
// Подключаю видеоканал для абонента 224466
```

Используя вызов одного и того же метода объекта `user`, мы получили различные результаты. Выбор конкретной реализации метода `call` внутри метода `callAnotherUser` производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения программы.

В примерах классов телефонов, приведённых выше, мы использовали переопределение методов – приём, при котором изменяется реализация метода, определённая в базовом классе, без изменения сигнатуры метода. По сути, это является заменой метода, и именно новый метод, определённый в подклассе, вызывается при выполнении программы.

Обычно, при переопределении метода, используется аннотация `@Override`, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.
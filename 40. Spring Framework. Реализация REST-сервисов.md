Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 10.

**REST-сервисы (Representational State Transfer — передача состояния представления)** — один из наиболее часто встречающихся способов построения коммуникации между приложениями. REST-сервисы обеспечивают доступ к функциональности сервера через конечные точки, к которым обращается клиент.

REST-сервисы применяют для установления соединения между клиентом и сервером в веб-приложении. Но их также можно использовать для организации обмена данными между мобильным приложением и бэкендом или даже между двумя сервисами бэкенда.
![spring_11.1](/pictures/spring_11.1.png)
# Обмен данными между приложениями посредством REST-сервисов
**Конечные точки REST** — это всего лишь способ организовать коммуникацию между двумя приложениями. Они представляют собой обычное действие контроллера, связанное с HTTP-методом и путём. Приложение вызывает действие контроллера через HTTP. Поскольку таким образом приложение делает сервис доступным через веб-протокол, конечные точки можно назвать **веб-сервисами**.

В итоге **в Spring конечная точка REST** — это тоже действие контроллера, связанное с HTTP-методом и путём. Чтобы предоставить доступ к конечным точкам REST, Spring использует тот же известный вам механизм, что и для других веб-приложений. Однако теперь мы настроим диспетчер сервлетов Spring MVC так, чтобы он не искал представление для REST-сервисов. В диаграмме Spring MVC в случае REST-сервисов пропадает арбитр представлений. В ответ на HTTP-запрос сервер возвращает клиенту ровно то, что он получил от действия контроллера. Эти изменения в процессе Spring MVC показаны ниже.
![spring_11.2](/pictures/spring_11.2.png)

REST-сервисы очень удобны. Одна из причин их популярности — простота, а благодаря Spring создавать REST-сервисы стало и того проще. Но прежде, чем приступить к первому примеру, рассмотрим некоторые проблемы обмена данными, которые могут возникнуть при использовании конечных точек REST:
- если действие контроллера выполняется долго, то HTTP-вызов конечной точки может завершиться и соединение разорвётся;
- при попытке передать большое количество данных за один вызов (один HTTP-запрос) времени вызова может не хватить и соединение разорвётся. Передача за один REST-вызов больше пары мегабайт обычно не лучшее решение;
- слишком много конкурентных обращений к одной конечной точке бэкенда может привести к чрезмерной нагрузке на приложение и вызвать его сбой;
- HTTP-вызовы выполняются за счёт сети, но сеть никогда не бывает абсолютно надёжной. Всегда есть вероятность того, что вызов конечной точки REST завершится неудачно из-за сетевого сбоя.
# Создание конечной точки REST
Научимся создавать конечные точки REST с помощью Spring. Хорошая новость состоит в том, что для этого в Spring используется всё тот же механизм Spring MVC.

Ниже показан класс контроллера, в котором реализовано простое действие. Класс контроллера сопровождается стереотипной аннотацией `@Controller`. Благодаря ей экземпляр такого класса становится бином в контексте Spring, и Spring MVC знает, что это контроллер, методы которого связаны с определёнными путями HTTP. Мы также воспользовались аннотацией `@GetMapping`, чтобы указать путь и HTTP-метод для действия. Единственный новый элемент, который вам встретится в этом листинге, — аннотация **`@ResponseBody`**. Она сообщает диспетчеру сервлетов, что действие контроллера не возвращает имя представления, а передаёт данные непосредственно в HTTP-запрос.
```java
@Controller
public class HelloController { 

	@GetMapping("/hello") 
	@ResponseBody 
	public String hello() { 
		return "Hello!"; 
	}
}
```

А теперь посмотрим, что произойдет, если добавить в контроллер ещё несколько методов, как показано ниже. Постоянное применение аннотации `@ResponseBody` к каждому методу выглядит раздражающе.
```java
@Controller
public class HelloController {

	@GetMapping("/hello")
	@ResponseBody
	public String hello() {
		return "Hello!";
	}
	
	@GetMapping("/ciao")
	@ResponseBody
	public String ciao() {
		return "Ciao!";
	}
}
```

Дублирования кода лучше избегать. Желательно как-нибудь избавиться от повторения `@ResponseBody` для каждого метода. Чтобы решить эту проблему, в Spring есть аннотация **`@RestController`**, которая заменяет сочетание `@Controller` и `@ResponseBody`. С помощью `@RestController` мы сообщаем Spring, что все действия контроллера являются конечными точками REST, поэтому в многократном использовании аннотации `@ResponseBody` нет необходимости.
```java
@RestController
public class HelloController {

	@GetMapping("/hello")
	public String hello() {
		return "Hello!";
	}
	
	@GetMapping("/ciao")
	public String ciao() {
		return "Ciao!";
	}
}
```

Создать пару конечных точек очень легко, не правда ли? Но как проверить, правильно ли они работают? Ниже вы освоите два инструмента, позволяющих обращаться к конечным точкам, которые часто применяются в реальных приложениях:
- **Postman** — имеет приятный GUI и удобен в использовании;
- **cURL** — инструмент командной строки, пригодный в тех случаях, когда нельзя использовать GUI (например, при соединении с виртуальной машиной по SSH или если вы пишете сценарий пакетной обработки).

Начнем с Postman. Вам нужно установить этот инструмент на своем компьютере согласно инструкциям, которые находятся на официальном сайте `https://www.postman.com/`. После установки Postman откройте его. Вы увидите интерфейс, подобный тому, что показан ниже.
![spring_11.3](/pictures/spring_11.3.png)

Когда вы нажмете кнопку `Send`, Postman отправит HTTP-запрос. Когда он будет выполнен, Postman выведет содержимое HTTP-ответа, как показано ниже.
![spring_11.4](/pictures/spring_11.4.png)

Если у вас нет GUI, для вызова конечной точки можно использовать инструмент командной строки. Читая книги и статьи, вы обнаружите, что в них для демонстрации вместо приложений с GUI обычно применяется именно этот способ, поскольку с ним можно показать команды более лаконично.

Если в качестве инструмента командной строки вы решите использовать cURL, то вам, как и в случае с Postman, вначале понадобится установить этот инструмент. Процедура установки cURL зависит от используемой операционной системы и описана на официальном сайте `https://curl.se/`.

После установки и настройки инструмента, можно передавать HTTP-запросы с помощью команды `curl`. В следующей строке кода показана команда, позволяющая отправить HTTP-запрос, чтобы проверить конечную точку `/hello`, созданную в нашем приложении:
```
curl http://localhost:8080/hello
```

Когда HTTP-запрос будет выполнен, в консоль будет выведено только тело HTTP-ответа:
```
Hello!
```

Если в запросе используется HTTP-метод GET, его можно не указывать явно. Если же это какой-либо другой метод или если вы все же хотите четко прописать GET, нужно воспользоваться флагом `-X`:
```
curl -X GET http://localhost:8080/hello
```

Чтобы получить другую информацию о HTTP-ответе, добавьте в команду флаг `-v`:
```
curl -v http://localhost:8080/hello
```

В следующем фрагменте показан результат выполнения этой команды — как видите, он более развернутый. В этом длинном тексте вы найдёте информацию о статусе, количестве отправленных данных и заголовки:
```
Trying ::1:8080...
* Connected to localhost (::1) port 8080 (#0)
> GET /hello HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.73.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 // Статус HTTP-ответа
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 6
< Date: Fri, 25 Dec 2020 23:11:02 GMT
<
{ [6 bytes data]
100 6 100 6 0 0 857 0 --:--:-- --:--:-- --:--:--
1000
Hello! // Тело HTTP-ответа
* Connection #0 to host localhost left intact
```
# Управление HTTP-ответом
**HTTP-ответ** — это тот способ, которым серверная часть приложения возвращает данные клиенту в ответ на его запрос. В HTTP-ответе содержится следующая информация:
- **заголовки ответа** — небольшие фрагменты данных (как правило, не длиннее пары слов);
- **тело ответа** — более крупный объём данных, которые бэкенд должен передать в ответ на запрос клиента;
- **статус ответа** — краткое представление результата запроса.
## Передача объектов в теле HTTP-ответа
Рассмотрим передачу экземпляров объектов в теле HTTP-ответа. Чтобы отправить объект клиенту в HTTP-ответе, нужно всего лишь сделать так, чтобы действие контроллера возвращало этот объект. Мы создадим объект-модель `Country` с атрибутами `name` (название страны) и `population` (число жителей в миллионах человек) и пропишем действие контроллера, которое будет возвращать экземпляр типа `Country`.

Ниже показан класс, определяющий объект `Country`. При использовании объекта (такого как `Country`) в качестве модели данных, передаваемых между двумя приложениями, его принято называть **DTO (data transfer object — объект передачи данных)**. Нашим DTO является объект `Country`, экземпляры которого созданная конечная точка REST будет возвращать в теле HTTP-ответа.
```java
public class Country { 

	private String name; 
	private int population; 
	
	public static Country of(String name, int population) { 
		Country country = new Country(); 
		country.setName(name); 
		country.setPopulation(population); 
		return country; 
	} 
	
	// Геттеры и сеттеры
}
```

Ниже показано, как выглядит действие контроллера, которое возвращает экземпляр типа `Country`.
```java
@RestController
public class CountryController { 

	@GetMapping("/france") 
	public Country france() { 
		Country c = Country.of("France", 67); 
		return c; 
	}
}
```

Что произойдет при вызове конечной точки? Как будет выглядеть объект в теле HTTP-ответа? По умолчанию Spring создаёт строку, представляющую объект, и дает её в формате JSON. **JavaScript Object Notation (JSON)** — это простой способ представления строк в виде пар «атрибут — значение».

При вызове конечной точки `/france` тело ответа выглядит так:
```json
{
	"name": "France",
	"population": 67
}
```

В теле ответа можно также передавать экземпляры, представляющие собой коллекции объектов. Ниже показан новый метод, возвращающий список объектов `Country`.
```java
@RestController
public class CountryController {

	// Остальной код
	
	@GetMapping("/all")
	public List<Country> countries() {
		Country c1 = Country.of("France", 67);
		Country c2 = Country.of("Spain", 47);
		return List.of(c1,c2); // Возвращает коллекцию в теле HTTP-ответа
	}
}
```

При вызове конечной точки тело ответа выглядит так:
```json
[ 
	{ 
		"name": "France", 
		"population": 67 
	}, 
	{ 
		"name": "Spain", 
		"population": 47 
	}
]
```

JSON — наиболее распространённый способ представления объектов при работе с конечными точками REST. Вы не обязаны использовать именно его, но вам едва ли встретится кто-либо, кто применяет что-то другое. При желании вы можете использовать в Spring другие форматы для тела запроса (такие как XML или YAML), подключив к объектам специальный преобразователь. Но вероятность того, что вам это понадобится на практике, столь мала.
## Создание HTTP-ответа со статусом и заголовками
Сосредоточим наше внимание на статусе и заголовках HTTP-ответа. Иногда бывает удобнее передать часть данных в заголовке ответа. **Статус ответа** — это важный признак HTTP-ответа, который сообщает о результате запроса. По умолчанию Spring присваивает ответам следующие основные HTTP-статусы:
- **200 — OK** — при обработке запроса на стороне сервера не возникло никаких исключений;
- **404 — Not Found** — запрошенный ресурс не существует;
- **400 — Bad Reques**t — часть запроса не соответствует тем данным, которые ожидает сервер;
- **500 — Error on server** — при обработке запроса на стороне сервера по какой-то причине возникло исключение. Как правило, с подобным исключением клиент ничего не может сделать. Предполагается, что проблема будет решена на стороне бэкенда.

Но иногда требования, предъявляемые к приложению, вынуждают создать специальный статус. Как это сделать? Самый простой и наиболее распространённый способ изменить HTTP-ответ — применить класс `ResponseEntity`.

**Этот класс Spring позволяет модифицировать тело, статус и заголовки HTTP-ответа.** В листинге ниже действие контроллера вместо объекта, который должен быть помещён непосредственно в тело HTTP-ответа, возвращает экземпляр `ResponseEntity`.
```java
@RestController
public class CountryController { 

	@GetMapping("/france") 
	public ResponseEntity<Country> france() { 
		Country c = Country.of("France", 67); 
		return ResponseEntity 
			.status(HttpStatus.ACCEPTED) 
			.header("continent", "Europe") 
			.header("capital", "Paris") 
			.header("favorite_food", "cheese and wine") 
			.body(c); 
	}
}
```

Класс `ResponseEntity` позволяет определить не только тело HTTP-ответа, но также статус и заголовки. В листинге мы создадим три заголовка и изменим статус HTTP-ответа на 202 — Accepted.
## Управление исключениями на уровне конечной точки
Очень важно продумать, что случится, если действие контроллера выбросит исключение. Мы часто используем исключения, чтобы сообщать о каких-то специфических ситуациях, часть из которых связана с бизнес-логикой приложения. Предположим, мы создали конечную точку, через которую клиенты проводят платежи. Если у пользователя недостаточно денег на счету, приложение может оповестить об этом, выдав исключение. В данном случае вы, очевидно, захотите добавить в HTTP-ответ некоторую информацию, чтобы рассказать клиенту о ситуации подробнее.

Один из способов управления исключениями состоит в том, чтобы перехватывать их в действии контроллера и, используя класс `ResponseEntity` передавать другую конфигурацию ответа в случае возникновения исключения.

В нашем примере мы определим исключение `NotEnoughMoneyException`. Приложение будет выдавать его при невозможности выполнить платёж, когда на счету клиента недостаточно денег. Определение класса исключения выглядит так:
```java
public class NotEnoughMoneyException extends RuntimeException {
}
```

Мы также создадим класс сервиса, в котором будет реализован сценарий использования. В данном примере он просто выдаст исключение. В реальных приложениях такие сервисы выполняют сложную логику электронных платежей. Класс сервиса, используемый в нашем примере, выглядит так:
```java
@Service
public class PaymentService {

	public PaymentDetails processPayment() {
		throw new NotEnoughMoneyException();
	}
}
```

Метод `processPayment()` возвращает значение типа `PaymentDetails`. `PaymentDetails` — это просто класс модели, описывающий тело HTTP-ответа, который действие контроллера будет передавать в случае успешного платежа. Класс `PaymentDetails` выглядит так:
```java
public class PaymentDetails {

	private double amount;
	
	// Геттеры и сеттеры
}
```

Когда в приложении появляется исключение, используется другой класс модели, `ErrorDetails`, который сообщает клиенту о возникшей ситуации. Класс `ErrorDetails` тоже очень простой — он содержит всего один атрибут с уведомлением об ошибке и выглядит так:
```java
public class ErrorDetails {

	private String message;
	
	// Геттеры и сеттеры
}
```

Откуда контроллер знает, какой из объектов нужно вернуть, в зависимости от последовательности проведения операций? Если исключение не возникло (приложение успешно выполнило платеж), нужно вернуть HTTP-ответ со статусом `Accepted` и данными типа `PaymentDetails`. Предположим, при обработке запроса в приложении появилось исключение. В этом случае действие контроллера выдаст HTTP-ответ со статусом `400 Bad Request` и экземпляром `ErrorDetails`, в котором содержится сообщение с описанием проблемы. Ниже наглядно показаны взаимосвязи между компонентами приложения и обязанности этих компонентов.
![spring_11.5](/pictures/spring_11.5.png)

Ниже показана логика, реализованная в методе контроллера.
```java
@RestController
public class PaymentController { 

	private final PaymentService paymentService; 
	
	public PaymentController(PaymentService paymentService) { 
		this.paymentService = paymentService; 
	}
	
	@PostMapping("/payment") 
	public ResponseEntity<?> makePayment() { 
		try { 
			PaymentDetails paymentDetails = paymentService.processPayment(); 
			return ResponseEntity 
				.status(HttpStatus.ACCEPTED) 
				.body(paymentDetails); 
		} catch (NotEnoughMoneyException e) { 
			ErrorDetails errorDetails = new ErrorDetails(); 
			errorDetails.setMessage("Not enough money to make the payment.");
			return ResponseEntity 
				.badRequest() 
				.body(errorDetails); 
		} 
	}
}
```

Запустите приложение и вызовите конечную точку, используя Postman или cURL. Мы заведомо сделали так, чтобы метод сервиса всегда возвращал `NotEnoughMoneyException`, так что ожидаем получить в HTTP-ответе сообщение о статусе `400 Bad Request`, а в теле ответа — сообщение об ошибке.

Это хорошая методика, и многие разработчики ею пользуются для обработки исключений. Но **в более сложных приложениях удобнее отделить управление исключениями от других обязанностей**. Во-первых, иногда одно и то же исключение должно обрабатываться для нескольких конечных точек и, разумеется, мы не хотим, чтобы это привело к дублированию кода. Во-вторых, когда вам придётся разбираться в работе тех или иных исключений, гораздо удобнее знать, что вся логика их обработки размещается в одном месте. Исходя из этих соображений, лучше использовать **совет REST-контроллера** — аспект, который перехватывает исключения, выдаваемые действиями контроллера, и применяет к ним написанную вами логику в зависимости от конкретного случая.

Ниже показано, какие изменения нужно внести в структуру класса.
![spring_11.6](/pictures/spring_11.6.png)

Как видно из листинга ниже, действие контроллера стало гораздо проще благодаря тому, что оно больше не должно обрабатывать исключения.
```java
@RestController
public class PaymentController {

	private final PaymentService paymentService;
	
	public PaymentController(PaymentService paymentService) {
		this.paymentService = paymentService;
	}
	
	@PostMapping("/payment")
	public ResponseEntity<PaymentDetails> makePayment() {
		PaymentDetails paymentDetails = paymentService.processPayment();
		return ResponseEntity
			.status(HttpStatus.ACCEPTED)
			.body(paymentDetails);
	}
}
```

Взамен мы создали отдельный класс `ExceptionControllerAdvice`, в котором выполняется всё, что нужно в случае, если действие контроллера выдаёт исключение `NotEnoughMoneyException`. Класс `ExceptionControllerAdvice` — это **совет REST-контроллера**. Чтобы отметить его как совет, мы воспользовались аннотацией `@RestControllerAdvice`. Метод, определённый в данном классе, называют также **обработчиком исключения**. Чтобы обозначить, какие именно исключения активируют выполнение этого метода, перед ним ставится аннотация `@ExceptionHandler`.

Ниже показано определение класса совета REST-контроллера и метод-обработчик исключения, в котором реализована логика, связанная с исключением `NotEnoughMoneyException`.
```java
@RestControllerAdvice
public class ExceptionControllerAdvice { 

	@ExceptionHandler(NotEnoughMoneyException.class) 
	public ResponseEntity<ErrorDetails> exceptionNotEnoughMoneyHandler() { 
		ErrorDetails errorDetails = new ErrorDetails(); 
		errorDetails.setMessage("Not enough money to make the payment."); 
		return ResponseEntity 
			.badRequest() 
			.body(errorDetails); 
	}
}
```

> На практике вам иногда придётся передавать из действия контроллера в совет дополнительную информацию о возникшем исключении. В таком случае нужно добавить параметр к методу-обработчику исключения в классе совета. Spring догадается, что нужно передать из контроллера в метод-обработчик ссылку на исключение. Затем можно будет использовать в логике совета любую информацию, извлечённую из экземпляра исключения.
# Извлечение данных из тела запроса, полученного от клиента
Поговорим о том, как извлекать данные из тела HTTP-запроса, полученного от клиента. Мы можем передавать данные в HTTP-запросе, используя параметры запроса и переменные пути. Поскольку в основе конечных точек REST лежит всё тот же механизм Spring MVC, синтаксис передачи данных через параметры запроса и переменные пути в этом случае ничем не отличается от уже известного вам. Конечные точки REST создаются точно так же, как и действия контроллера для веб-страниц; в обоих случаях используются одни и те же аннотации.

Но мы не затронули ещё один важный вопрос: у HTTP-запроса есть тело и его можно использовать для передачи данных от клиента серверу. Тело HTTP-запроса часто используется при отправке информации в конечные точки REST. Как отмечается, если нужно передать большой объём данных, следует использовать тело запроса.

Чтобы передать данные в теле запроса, достаточно снабдить параметр действия контроллера аннотацией `@RequestBody`. По умолчанию Spring предполагает, что данные в параметре, сопровождаемом аннотацией, представлены в формате JSON, и пытается преобразовать строку JSON в объект, соответствующий типу параметра. Если фреймворку это не удаётся, приложение возвращает HTTP-ответ со статусом `400 Bad Request`. В контроллере определено действие, связанное с путем `/payment` и HTTP-методом POST. Действие пытается извлечь из тела запроса данные типа `PaymentDetails`. Контроллер выводит в консоль сервера сумму платежа, полученную из объекта `PaymentDetails`, и возвращает этот же объект клиенту в теле HTTP-ответа.
```java
@RestController
public class PaymentController { 
	private static Logger logger = Logger.getLogger(PaymentController.class.getName());
	
	@PostMapping("/payment") 
	public ResponseEntity<PaymentDetails> makePayment(
		@RequestBody PaymentDetails paymentDetails) { 
		logger.info("Received payment " + paymentDetails.getAmount());
		return ResponseEntity 
			.status(HttpStatus.ACCEPTED) 
			.body(paymentDetails); 
	}
}
```

Ниже показано, как вызвать конечную точку `/payment` с телом запроса, используя Postman.
![spring_11.7](/pictures/spring_11.7.png)

Если вы предпочитаете использовать cURL, можете использовать следующую команду:
```
curl -v -X POST http://127.0.0.1:8080/payment -d '{"amount": 1000}' -H "Content-Type: application/json"
```

> **МОЖНО ЛИ ИСПОЛЬЗОВАТЬ ТЕЛО ЗАПРОСА В СЛУЧАЕ HTTP-МЕТОДА GET?**
> 
> Почему применение тела запроса для HTTP-метода GET вызывает сомнения? До 2014 года спецификация HTTP-протокола не допускала использования тела запроса для вызовов HTTP GET. Не существовало реализаций для клиента и сервера, которые бы позволяли осуществить подобное.
> 
> В 2014 году спецификация изменилась, и теперь использовать тело запроса для HTTP-метода GET можно.
> 
> Подробнее об использовании HTTP-метода GET вы можете прочесть в подразделе 4.3.1 спецификации HTTP, RFC 7231: https://tools.ietf.org/html/rfc7231#page-24.
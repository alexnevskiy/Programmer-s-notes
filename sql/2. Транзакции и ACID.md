Взято с [LeftJoin](https://leftjoin.ru/blog/data-engineering/acid-and-databases/), Habr ([1](https://habr.com/ru/companies/simbirsoft/articles/572540/)), ([2](https://habr.com/ru/articles/555920/)), Sql-ex ([1](https://sql-ex.ru/blogs/?/Urovni_izolJacii_tranzakcij.html)), ([2](https://sql-ex.ru/blogs/?/Tranzakcii_SQL_rukovodstvo_dlJa_nachinajuwih.html)), [Wikipedia](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9).
# Транзакция
**Транзакция** — это несколько операций чтения и записи, сгруппированные в одну логически неделимую операцию. Самый наглядный пример — банковский перевод, для которого нужно совершить несколько действий: снять деньги с одного счёта и перекинуть их на другой.

Пример исчерпывающе доносит смысл, но дьявол, как всегда, кроется в деталях, а точнее в деталях реализации. Во-первых, СУБД, поддерживающие транзакции, **должны удовлетворять гарантиям функциональной безопасности ACID**. Во-вторых, есть понятие **уровней изоляции транзакции**, всего существует 4 различных уровня.

Для использования транзакции в SQL нам нужно иметь несколько операторов SQL. Общая схема такова:
![sql_transaction](/pictures/sql_transaction.png)

1. **`BEGIN/START TRANSACTION`**: этот оператор начинает новую транзакцию. Любые операторы SQL, которые следуют за этим оператором, рассматриваются как часть транзакции до тех пор, пока транзакция не будет зафиксирована или выполнен откат.
2. **`COMMIT TRANSACTION`**: этот оператор сохраняет сделанные во время транзакции изменения в базе данных. Если транзакция завершается успешно, эти изменения становятся постоянными (фиксируются).
3. **`ROLLBACK TRANSACTION`**: этот оператор отменяет изменения, сделанные во время транзакции, и восстанавливает базу данных в её предшествующем состоянии (откат).

Представим, что у нас есть две таблицы в базе данных: одна для заказов клиентов и другая для уровня запасов. Когда клиент размещает заказ, нам необходимо обновить обе таблицы, чтобы отразить новый заказ и сокращение уровня запасов для соответствующего товара.  
  
Вот пример того, как мы можем выполнить это с использованием транзакций в SQL:
```mysql
BEGIN TRANSACTION;
-- вставить новый заказ в таблицу orders
INSERT INTO orders (customer_id, product_id, quantity, status)
VALUES (1, 2, 3, 'Pending');

-- обновить уровень запасов для соответствующего товара
UPDATE inventory
SET quantity = quantity - 3
WHERE product_id = 2;

-- проверим, не стал ли уровень запасов отрицательным
IF EXISTS (SELECT * FROM inventory WHERE product_id = 2 AND quantity < 0)
BEGIN
	-- если уровень запасов отрицательный, откатываем транзакцию
	ROLLBACK TRANSACTION;
	PRINT 'Error: inventory level is negative';
END
ELSE
BEGIN
	-- если уровень запасов не отрицательный, фиксируем транзакцию
	COMMIT TRANSACTION;
	PRINT 'Order successfully placed';
END
```
# ACID
1. **Atomicity** - атомарность
2. **Consistency** - согласованность / консистентность
3. **Isolation** - изоляция
4. **Durability** - стойкость / надёжность
## Atomicity / Атомарность
Первая буква «А» — atomicity, то есть атомарность.

**Атомарность** гарантирует, что **каждая транзакция будет выполнена полностью или не будет выполнена совсем**. Не допускаются промежуточные состояния.

В большинстве СУБД для того, чтобы начать транзакцию, необходимо выполнить запрос с выражением `START TRANSACTION`. Все дальнейшие действия будут относиться к начатой транзакции. Чтобы завершить транзакцию, нужно выполнить выражение `COMMIT`, а если вы хотите отменить все действия транзакции, то можно «откатиться», используя выражение `ROLLBACK`.

И именно атомарность гарантирует, что ВСЕ операции между `START TRANSACTION` и `COMMIT` либо выполнятся, либо не выполнятся — промежуточного состояния не будет.

В качестве примера вспомним опять про банковское приложение:

Николай хочет перевести с одного счёта на другой 200 рублей. Для этого сначала с первого счёта будет списано 200 рублей, а уже потом на второй счёт эти деньги будут зачислены. На первом счету у него 400 рублей, на втором — 500.
```mysql
START TRANSACTION
UPDATE bank_acc SET balance = balance + 200
WHERE account_owner LIKE '%Николай%' AND account_id = 1;

UPDATE bank_acc SET balance = balance - 200
WHERE account_owner LIKE '%Николай%' AND account_id = 2;
COMMIT
```
![sql_transaction_atomicity](/pictures/sql_transaction_atomicity.jpg)

Если после первого `UPDATE` питание в здании отключится и сервер базы данных выключится, то на счетах останется 400 и 500 рублей, как будто никакой транзакции и не было.
## Consistency / Согласованность
Вторая буква «C» — consistency, то есть согласованность или консистентность.

**Согласованность** означает, что **если до выполнения транзакции данные в БД находятся в определённом состоянии «good state», то они будут в этом же состоянии и после выполнения транзакции**.

На самом деле ни одна база данных не может гарантировать свойство согласованности. А всё потому, что **поддержание консистентности — это прерогатива приложения, а не БД**. База данных лишь предоставляет инструменты для выполнения данного свойства транзакции, например, уникальные ключи, внешние ключи и т.д.
## Isolation / Изоляция
Третья буква — «I» — isolation, то есть изолированность одной транзакции от любой другой.

Во время выполнения транзакции **параллельные транзакции не должны оказывать влияния на её результат**.

Иногда случается так, что несколько пользователей в рамках своих транзакций норовят изменить одни и те же данные. В таком случае, эти транзакции должны быть изолированы друг от друга.

Чтобы разобраться, чем чревато отсутствие изоляции двух транзакций, достаточно в наш пример добавить Маргариту, которая хочет через банкомат внести на счёт Николая 300 рублей в момент перевода Николая. Если реализовать её действия через механизм считывания текущего баланса счёта, прибавления к нему 300 рублей и его перезаписи, то появляется риск нарушения консистентности.
![sql_transaction_consistency](/pictures/sql_transaction_consistency.jpg)

Последнее действие, выполненное в рамках начисления через банкомат, перезатрёт все изменения от другой транзакции, что вызовет нарушение целостности данных в базе: у Николая на первом счету будет 600 рублей, а на втором 800 рублей, хотя должно быть 600. Эта ситуация называется «потерей обновления».
## Durability / Надёжность
**Надёжность** означает, что **если транзакция выполнена, и даже если в следующий момент произойдет сбой в системе, результат сохранится**.

Тут все просто: все транзакции, которые были успешно «закоммичены», не должны быть потеряны ни при каких сбоях. Если база данных реплицируется (запись идёт на ещё один или несколько работающих БД), то сохраняемость может означать успешную запись в БД на другом сервере. Если база данных не реплицируется, то сохраняемость означает запись на энергонезависимый носитель информации (например, жёсткий диск).
# Уровни изоляции транзакции
Уровни изоляции транзакций:
1. READ UNCOMMITTED
2. READ COMMITTED
3. REPEATABLE READ
4. SERIALIZABLE
![sql_transaction_isolation_level1](/pictures/sql_transaction_isolation_level1.png)
## Проблемы параллельного доступа с использованием транзакций
При параллельном выполнении транзакций возможны следующие аномалии (проблемы):
- **Потерянное обновление** (lost update);
- **«Грязное» чтение** (dirty read);
- **Неповторяющееся чтение** (non-repeatable read);
- **Фантомное чтение** (phantom reads).
### Потерянное обновление
**Потерянное обновление** - это ситуация, когда при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется.

Предположим, имеются две транзакции, выполняемые одновременно:

|Транзакция 1|Транзакция 2|
| --- | --- |
|`UPDATE tbl1 SET f2=f2+20 WHERE f1=1;`|`UPDATE tbl1 SET f2=f2+25 WHERE f1=1;`|

В обеих транзакциях изменяется значение поля `f2`, по их завершении значение поля должно быть увеличено на 45. В действительности может возникнуть следующая последовательность действий:
1. Обе транзакции одновременно читают текущее состояние поля. Точная физическая одновременность здесь не обязательна, достаточно, чтобы вторая по порядку операция чтения выполнилась до того, как другая транзакция запишет свой результат.
2. Обе транзакции вычисляют новое значение поля, прибавляя, соответственно, 20 и 25 к ранее прочитанному значению.
3. Транзакции пытаются записать результат вычислений обратно в поле `f2`. Поскольку физически одновременно две записи выполнить невозможно, в реальности одна из операций записи будет выполнена раньше, другая позже. При этом вторая операция записи перезапишет результат первой.

В результате значение поля `f2` по завершении обеих транзакций может увеличиться не на 45, а на 20 или 25, то есть одна из изменяющих данные транзакций «пропадёт».
### «Грязное» чтение
**«Грязное» чтение** - это чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится).

Предположим, имеются две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

| Транзакция 1                          | Транзакция 2                      |
| ------------------------------------- | --------------------------------- |
| `UPDATE tbl1 SET f2=f2+1 WHERE f1=1;` |                                   |
|                                       | `SELECT f2 FROM tbl1 WHERE f1=1;` |
| `ROLLBACK;`                           |                                   |

В транзакции 1 изменяется значение поля `f2`, а затем в транзакции 2 выбирается значение этого поля. После этого происходит откат транзакции 1. В результате значение, полученное второй транзакцией, будет отличаться от значения, хранимого в базе данных.
### Неповторяющееся чтение
**Неповторяющееся чтение** - это ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.

Предположим, имеются две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

|Транзакция 1|Транзакция 2|
|---|---|
||`SELECT f2 FROM tbl1 WHERE f1=1;`|
|`UPDATE tbl1 SET f2=f2+3 WHERE f1=1;`||
|`COMMIT;`||
||`SELECT f2 FROM tbl1 WHERE f1=1;`|

В транзакции 2 выбирается значение поля `f2`, затем в транзакции 1 изменяется значение поля `f2`. При повторной попытке выбора значения из поля `f2` в транзакции 2 будет получен другой результат. Эта ситуация особенно неприемлема, когда данные считываются с целью их частичного изменения и обратной записи в базу данных.
### Фантомное чтение
**Фантомное чтение** - это ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка даёт разные множества строк.

Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

|Транзакция 1|Транзакция 2|
|---|---|
||`SELECT SUM(f2) FROM tbl1;`|
|`INSERT INTO tbl1 (f1,f2) VALUES (15,20);`||
|`COMMIT;`||
||`SELECT SUM(f2) FROM tbl1;`|

В транзакции 2 выполняется SQL-оператор, использующий все значения поля `f2`. Затем в транзакции 1 выполняется вставка новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. Такая ситуация называется чтением фантома (фантомным чтением). **От неповторяющегося чтения оно отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.**
## READ UNCOMMITED
**READ UNCOMMITTED**: означает, что **транзакция в пределах текущей сессии может читать данные, которые модифицируются или удаляются другой транзакцией, но ещё не зафиксированы**. Этот уровень изоляции накладывает наименьшие ограничения, поскольку ядро базы данных не накладывает никаких разделяемых блокировок. В результате весьма вероятно, что транзакция прочитает данные, которые были вставлены, обновлены или удалены, но не будут зафиксированы в базе данных.
## READ COMMITTED
**READ COMMITTED**: Это установка по умолчанию для большинства СУБД. Она определяет, что **транзакция в текущем сеансе не может читать данные, которые были модифицированы другой транзакцией**. Тем самым при этой установке предотвращается грязное чтение.
## REPEATABLE READ
**REPEATABLE READ**: С этой установкой **транзакция не только может читать данные, которые зафиксированы другой модифицирующей транзакцией, но также накладывает ограничение, чтобы никакая другая транзакция не могла модифицировать данные, которые читаются, пока первая транзакция не завершит работу**. Это устраняет проблему неповторяющихся чтений.
## SERIALIZABLE
**SERIALIZABLE**: Этим уровнем изоляции устанавливается множество свойств. Этот уровень изоляции является наиболее ограничительным по сравнению с другими, в результате чего могут возникнуть некоторые проблемы с производительностью при установке этого уровня. Вот упомянутые **свойства**:  
1. Текущая транзакция может читать только зафиксированные данные, модифицированные другой транзакцией данные.
2. Другие транзакции ставятся в очередь ожидания пока первая транзакция не завершит выполнение.
3. Никаким транзакциям не разрешается вставлять данные, которые отвечают условию текущей транзакции.
# Порядок выполнения SQL запроса
1. `FROM`
2. `WHERE`
3. `GROUP BY`
4. `HAVING`
5. `SELECT`
6. `ORDER BY`

То есть порядок выполнения в реальном запросе будет следующий:
```sql
5 SELECT list of columns/window functions
1 FROM table/joint tables/subquery
2 WHERE filtering clause
3 GROUP BY list of columns
4 HAVING aggregation filtering clause
6 ORDER BY list of columns/window functions
```
# Основные операторы 
## `SELECT DISTINCT`
Оператор **`SELECT DISTINCT`** используется для возврата только различных значений.
```sql
SELECT DISTINCT column1, column2, ...
FROM table_name;
```

Примеры:
```sql
-- Запрос выбирает только значения DISTINCT из столбца «Country» в таблице «Customers»:
SELECT DISTINCT Country FROM Customers;

-- Запрос перечисляет количество различных (отдельных) стран клиентов:
SELECT COUNT(DISTINCT Country) FROM Customers;

-- Тот же самый запрос, что и выше, только переписан для тех БД, которые не поддерживают COUNT(DISTINCT column_name):
SELECT Count(*) AS DistinctCountries
FROM (SELECT DISTINCT Country FROM Customers);
```
## `SELECT TOP`
Оператор **`SELECT TOP`** используется для указания количества возвращаемых записей.

Оператор `SELECT TOP` полезен для больших таблиц с тысячами записей. Возврат большого количества записей может повлиять на производительность.

SQL Server / MS Access Syntax:
```sql
SELECT TOP number|percent column_name(s)
FROM table_name
WHERE condition;
```

MySQL Syntax:
```sql
SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;
```

Примеры:
```sql
-- Запрос выбирает первые три записи из таблицы «Customers»:
SELECT TOP 3 * FROM Customers;

SELECT * FROM Customers
LIMIT 3;

-- Запрос выбирает первые 50% записей из таблицы «Customers»:
SELECT TOP 50 PERCENT * FROM Customers;

-- Запрос выбирает первые три записи из таблицы «Customers», где страной является «Германия»:
SELECT TOP 3 * FROM Customers
WHERE Country='Germany';

SELECT * FROM Customers
WHERE Country='Germany'
LIMIT 3;
```
## `GROUP BY`
Оператор **`GROUP BY`** группирует строки с одинаковыми значениями в сводные строки, например «найти количество клиентов в каждой стране».

Оператор `GROUP BY` часто используется с агрегатными функциями (`COUNT()`, `MAX()`, `MIN()`, `SUM()`, `AVG()`) для группировки набора результатов по одному или нескольким столбцам.
```sql
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s);
```

Примеры:
```sql
-- Запрос перечисляет количество клиентов в каждой стране:
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country;

-- Запрос перечисляет количество клиентов в каждой стране, отсортированных по возрастанию:
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
ORDER BY COUNT(CustomerID) DESC;

-- Запрос перечисляет количество заказов, отправленных каждым грузоотправителем:
SELECT Shippers.ShipperName, COUNT(Orders.OrderID) AS NumberOfOrders 
FROM Orders
LEFT JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID
GROUP BY ShipperName;
```
## `HAVING`
Оператор **`HAVING`** был добавлен в SQL, поскольку ключевое слово `WHERE` нельзя использовать с агрегатными функциями.
```sql
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);
```

Примеры:
```sql
-- В запросе указано количество клиентов в каждой стране. Включать только страны с более чем 5 клиентами:
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5;

-- В запросе указано количество клиентов в каждой стране, отсортированное по возрастанию (включаются только страны с более чем 5 клиентами):
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5
ORDER BY COUNT(CustomerID) DESC;

-- Следующий запрос перечисляет сотрудников, которые зарегистрировали более 10 заказов:
SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders
FROM (Orders
INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID)
GROUP BY LastName
HAVING COUNT(Orders.OrderID) > 10;

-- В запросе указано, зарегистрировали ли сотрудники «Davolio» или «Fuller» более 25 заказов:
SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders
FROM Orders
INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
WHERE LastName = 'Davolio' OR LastName = 'Fuller'
GROUP BY LastName
HAVING COUNT(Orders.OrderID) > 25;
```
## `ORDER BY`
Ключевое слово **`ORDER BY`** используется для сортировки набора результатов в порядке возрастания или убывания.

Ключевое слово `ORDER BY` по умолчанию сортирует записи в порядке возрастания (`ASC`). Чтобы отсортировать записи в порядке убывания, используется ключевое слово `DESC`.
```sql
SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;
```

Примеры:
```sql
-- Запрос выбирает всех клиентов из таблицы «Customers», отсортированных по столбцу «Country»:
SELECT * FROM Customers
ORDER BY Country;

-- Запрос выбирает всех клиентов из таблицы «Customers», отсортированных в порядке убывания по столбцу «Country»:
SELECT * FROM Customers
ORDER BY Country DESC;

-- Запрос выбирает всех клиентов из таблицы «Customers», отсортированных по столбцу «Country» и «CustomerName». Это означает, что он упорядочивает по стране, но если некоторые строки имеют одну и ту же страну, он упорядочивает их по имени клиента:
SELECT * FROM Customers
ORDER BY Country, CustomerName;

-- Запрос выбирает всех клиентов из таблицы «Customers», отсортированных по возрастанию по «Country» и по убыванию по столбцу «CustomerName»:
SELECT * FROM Customers
ORDER BY Country ASC, CustomerName DESC;
```
# Объединение данных
## `JOIN`
Оператор **`JOIN`** используется для объединения строк из двух или более таблиц на основе
связанного столбца между ними.
### `INNER JOIN`
Ключевое слово **`INNER JOIN`** выбирает записи, которые имеют совпадающие значения в обеих таблицах.
![sql_inner_join](/pictures/sql_inner_join.png)
```sql
SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;
```

Примеры:
`Authors` — содержит в себе информацию об авторах книг:

| AuthorID | AuthorName       |
| -------- | ---------------- |
| 1        | Bruce Eckel      |
| 2        | Robert Lafore    |
| 3        | Andrew Tanenbaum |

`Books` — содержит в себе информацию о названии книг:

| BookID | BookName                |
| ------ | ----------------------- |
| 3      | Modern Operating System |
| 1      | Thinking in Java        |
| 3      | Computer Architecture   |
| 4      | Programming in Scala    |

В таблице `Books` поле `BookID` являются внешним ключом и ссылаются на таблицу `Authors`.

Выведем на экран, какими авторами были написаны какие из книг. В данном запросе оператора SQL `INNER JOIN` условие сравнения — это равенство полей `AuthorID` и `BookID`. В результирующую таблицу не попадет книга под названием `Programming in Scala`, так как значение её `BookID` не найдёт равенства ни с одной строкой `AuthorID`:
```sql
SELECT *
FROM Authors 
INNER JOIN Books
ON Authors.AuthorID = Books.BookID
```

| Authors.AuthorID | Authors.AuthorName | Books.BookID | Books.BookName          |
| ---------------- | ------------------ | ------------ | ----------------------- |
| 3                | Andrew Tanenbaum   | 3            | Modern Operating System |
| 1                | Bruce Eckel        | 1            | Thinking in Java        |
| 3                | Andrew Tanenbaum   | 3            | Computer Architecture   |

Следующая запрос SQL выбирает все заказы с информацией о клиенте и грузоотправителе:
```sql
SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName
FROM ((Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID)
INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);
```
### `LEFT JOIN`
Ключевое слово **`LEFT JOIN`** возвращает все записи из левой таблицы (таблица 1) и
соответствующие записи из правой таблицы (таблица 2). Результат — 0 записей с правой
стороны, если совпадений нет.
![sql_left_join](/pictures/sql_left_join.png)
```sql
SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;
```

Примеры:
`Authors` — содержит в себе информацию об авторах книг:

| AuthorID | AuthorName       |
| -------- | ---------------- |
| 1        | Bruce Eckel      |
| 2        | Robert Lafore    |
| 3        | Andrew Tanenbaum |
`Books` — содержит в себе информацию о названии книг:

| BookID | BookName                |
| ------ | ----------------------- |
| 3      | Modern Operating System |
| 1      | Thinking in Java        |
| 3      | Computer Architecture   |
| 4      | Programming in Scala    |

В таблице `Books` поле `BookID` являются внешним ключом и ссылаются на таблицу `Authors`.

Выведем, какие книги написали все авторы. Как можно заметить, записи о книгах автора `Robert Lafore` отсутствуют в базе и поля `Books.BookID` и `Books.BookName` дополняются значениями `NULL`:
```sql
SELECT *
FROM Authors
LEFT JOIN Books
ON Authors.AuthorID = Books.BookID
```

| Authors.AuthorID | Authors.AuthorName | Books.BookID | Books.BookName          |
| ---------------- | ------------------ | ------------ | ----------------------- |
| 1                | Bruce Eckel        | 1            | Thinking in Java        |
| 2                | Robert Lafore      | NULL         | NULL                    |
| 3                | Andrew Tanenbaum   | 3            | Modern Operating System |
| 3                | Andrew Tanenbaum   | 3            | Computer Architecture   |
### `RIGHT JOIN`
Ключевое слово **`RIGHT JOIN`** возвращает все записи из правой таблицы (таблица 2) и соответствующие записи из левой таблицы (таблица 1). Результат — 0 записей с левой  стороны, если совпадений нет.
![sql_right_join](/pictures/sql_right_join.png)
```sql
SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;
```

Примеры:
`Authors` — содержит в себе информацию об авторах книг:

| AuthorID | AuthorName       |
| -------- | ---------------- |
| 1        | Bruce Eckel      |
| 2        | Robert Lafore    |
| 3        | Andrew Tanenbaum |
`Books` — содержит в себе информацию о названии книг:

| BookID | BookName                |
| ------ | ----------------------- |
| 3      | Modern Operating System |
| 1      | Thinking in Java        |
| 3      | Computer Architecture   |
| 4      | Programming in Scala    |

В таблице `Books` поле `BookID` являются внешним ключом и ссылаются на таблицу `Authors`.

Выведем, какие книги написали все авторы. Информация об авторе книги `Programming in Scala` отсутствует в таблице `Authors`, поэтому соответствующие значения заменены `NULL`:
```sql
SELECT *
FROM Authors
RIGHT JOIN Books
ON Authors.AuthorID = Books.BookID
```

| Authors.AuthorID | Authors.AuthorName | Books.BookID | Books.BookName          |
| ---------------- | ------------------ | ------------ | ----------------------- |
| 3                | Andrew Tanenbaum   | 3            | Modern Operating System |
| 1                | Bruce Eckel        | 1            | Thinking in Java        |
| 3                | Andrew Tanenbaum   | 3            | Computer Architecture   |
| NULL             | NULL               | 4            | Programming in Scala    |
### `FULL JOIN`
Ключевое слово **`FULL JOIN`** возвращает все записи, если есть совпадение в левой (таблица 1) или правой (таблица 2) записях таблицы.
![sql_full_join](/pictures/sql_full_join.png)
```sql
SELECT column_name(s)
FROM table1
FULL JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;
```

Примеры:
`Authors` — содержит в себе информацию об авторах книг:

| AuthorID | AuthorName       |
| -------- | ---------------- |
| 1        | Bruce Eckel      |
| 2        | Robert Lafore    |
| 3        | Andrew Tanenbaum |
`Books` — содержит в себе информацию о названии книг:

| BookID | BookName                |
| ------ | ----------------------- |
| 3      | Modern Operating System |
| 1      | Thinking in Java        |
| 3      | Computer Architecture   |
| 4      | Programming in Scala    |

В таблице `Books` поле `BookID` являются внешним ключом и ссылаются на таблицу `Authors`.

Выведем авторов всех книг и книги всех авторов:
```sql
SELECT *
FROM Authors 
FULL JOIN Books
ON Authors.AuthorID = Books.BookID
```

| Authors.AuthorID | Authors.AuthorName | Books.BookID | Books.BookName          |
| ---------------- | ------------------ | ------------ | ----------------------- |
| 1                | Bruce Eckel        | 1            | Thinking in Java        |
| 2                | Robert Lafore      | NULL         | NULL                    |
| 3                | Andrew Tanenbaum   | 3            | Modern Operating System |
| 3                | Andrew Tanenbaum   | 3            | Computer Architecture   |
| NULL             | NULL               | 4            | Programming in Scala    |
### `CROSS JOIN`
Оператор SQL **`CROSS JOIN`** формирует таблицу перекрёстным соединением (декартовым произведением) двух таблиц. При использовании оператора SQL `CROSS JOIN` каждая строка левой таблицы сцепляется с каждой строкой правой таблицы. В результате получается таблица со всеми возможными сочетаниями строк обеих таблиц.
```sql
SELECT column_name(s)
FROM table1
CROSS JOIN table2
```

Примеры:
`Authors` — содержит в себе информацию об авторах книг:

| AuthorID | AuthorName       |
| -------- | ---------------- |
| 1        | Bruce Eckel      |
| 2        | Robert Lafore    |
| 3        | Andrew Tanenbaum |
`Books` — содержит в себе информацию о названии книг:

| BookID | BookName                |
| ------ | ----------------------- |
| 3      | Modern Operating System |
| 1      | Thinking in Java        |
| 3      | Computer Architecture   |
| 4      | Programming in Scala    |

В таблице `Books` поле `BookID` являются внешним ключом и ссылаются на таблицу `Authors`.

Произвести декартово произведение обеих таблиц с помощью оператора SQL `CROSS JOIN`:
```sql
SELECT *
FROM Authors 
CROSS JOIN Books
```

| Authors.AuthorID | Authors.AuthorName | Books.BookID | Books.BookName          |
| ---------------- | ------------------ | ------------ | ----------------------- |
| 1                | Bruce Eckel        | 3            | Modern Operating System |
| 1                | Bruce Eckel        | 1            | Thinking in Java        |
| 1                | Bruce Eckel        | 3            | Computer Architecture   |
| 1                | Bruce Eckel        | 4            | Programming in Scala    |
| 2                | Robert Lafore      | 3            | Modern Operating System |
| 2                | Robert Lafore      | 1            | Thinking in Java        |
| 2                | Robert Lafore      | 3            | Computer Architecture   |
| 2                | Robert Lafore      | 4            | Programming in Scala    |
| 3                | Andrew Tanenbaum   | 3            | Modern Operating System |
| 3                | Andrew Tanenbaum   | 1            | Thinking in Java        |
| 3                | Andrew Tanenbaum   | 3            | Computer Architecture   |
| 3                | Andrew Tanenbaum   | 4            | Programming in Scala    |
### `SELF JOIN`
**`SELF JOIN`** - это обычный `JOIN`, но таблица объединяется сама с собой.
```sql
SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;
```

`T1` и `T2` — разные псевдонимы одной и той же таблицы.

Примеры:
```sql
-- Следующий запрос SQL сопоставляет клиентов из одного и того же города:
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City
ORDER BY A.City;
```
## `UNION`
Оператор **`UNION`** используется для объединения набора результатов двух или более операторов `SELECT`.
- Каждый оператор `SELECT` в `UNION` должен иметь одинаковое количество столбцов.
- Столбцы также должны иметь похожие типы данных.
- Столбцы в каждом операторе `SELECT` также должны быть в том же порядке.
```sql
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
```

Оператор `UNION` по умолчанию выбирает только отдельные значения. Чтобы разрешить
повторяющиеся значения, используйте `UNION ALL`:
```sql
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
```

Примеры:
```sql
-- Запрос возвращает города (только отдельные значения) из таблиц «Customers» и «Suppliers». Если у некоторых клиентов или поставщиков один и тот же город, каждый город будет указан только один раз, потому что UNION выбирает только разные значения:
SELECT City FROM Customers
UNION
SELECT City FROM Suppliers
ORDER BY City;

-- Запрос возвращает города (также повторяющиеся значения) как из таблицы «Customers», так и из таблицы «Suppliers»:
SELECT City FROM Customers
UNION ALL
SELECT City FROM Suppliers
ORDER BY City;

-- Запрос возвращает города Германии (только отдельные значения) из таблиц «Customers» и «Suppliers»:
SELECT City, Country FROM Customers
WHERE Country = 'Germany'
UNION
SELECT City, Country FROM Suppliers
WHERE Country = 'Germany'
ORDER BY City;

-- Запрос возвращает города Германии (также повторяющиеся значения) из таблиц «Customers» и «Suppliers»:
SELECT City, Country FROM Customers
WHERE Country = 'Germany'
UNION ALL
SELECT City, Country FROM Suppliers
WHERE Country = 'Germany'
ORDER BY City;

-- Запрос перечисляет всех клиентов и поставщиков:
SELECT 'Customer' AS Type, ContactName, City, Country
FROM Customers
UNION
SELECT 'Supplier', ContactName, City, Country
FROM Suppliers;
```
# Логические операторы
## `IN`
Оператор **`IN`** позволяет указать несколько значений в предложении `WHERE`.

Оператор `IN` является сокращением для множественных условий `OR`.
```sql
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);

SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT STATEMENT);
```

Примеры:
```sql
-- Запрос выбирает всех клиентов, которые находятся в «Германии», «Франции» или «Великобритании»:
SELECT * FROM Customers
WHERE Country IN ('Germany', 'France', 'UK');

-- Запрос выбирает всех клиентов, которые не находятся в «Германии», «Франции» или «Великобритании»:
SELECT * FROM Customers
WHERE Country NOT IN ('Germany', 'France', 'UK');

-- Запрос выбирает всех клиентов из тех же стран, что и поставщики:
SELECT * FROM Customers
WHERE Country IN (SELECT Country FROM Suppliers);
```
## `EXISTS`
Оператор **`EXISTS`** используется для проверки существования любой записи в подзапросе.

Оператор `EXISTS` возвращает `TRUE`, если подзапрос возвращает одну или несколько записей.
```sql
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
```

Примеры:
```sql
-- Запрос возвращает TRUE и перечисляет поставщиков с ценой продукта меньше 20:
SELECT SupplierName
FROM Suppliers
WHERE EXISTS (SELECT ProductName FROM Products WHERE Products.SupplierID =
Suppliers.supplierID AND Price < 20);

-- Запрос возвращает TRUE и перечисляет поставщиков с ценой продукта, равной 22:
SELECT SupplierName
FROM Suppliers
WHERE EXISTS (SELECT ProductName FROM Products WHERE Products.SupplierID =
Suppliers.supplierID AND Price = 22);
```
## `ANY`, `ALL`
Операторы **`ANY`** и **`ALL`** позволяют выполнять сравнение между значением одного столбца и
диапазоном других значений.
### `ANY`
Оператор **`ANY`**:
- в результате возвращает логическое значение;
- возвращает `TRUE`, если ЛЮБОЕ из значений подзапроса удовлетворяет условию.

`ANY` означает, что условие будет истинным, если операция верна для любого из значений в
диапазоне.
```sql
SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
	(SELECT column_name
	FROM table_name
	WHERE condition);
```

Оператор должен быть стандартным оператором сравнения (`=`, `<>`, `!=`, `>`, `>=`, `<`, `<=`).

Примеры:
```sql
-- Запрос перечисляет ProductName, если он находит, что ЛЮБЫЕ записи в таблице OrderDetails имеют количество, равное 10 (это вернет TRUE, поскольку столбец Quantity имеет некоторые значения 10):
SELECT ProductName
FROM Products
WHERE ProductID = ANY
	(SELECT ProductID
	FROM OrderDetails
	WHERE Quantity = 10);

-- Запрос перечисляет ProductName, если он обнаруживает, что ЛЮБЫЕ записи в таблице OrderDetails имеют количество больше 99 (это вернет TRUE, поскольку в столбце Quantity некоторые значения больше 99):
SELECT ProductName
FROM Products
WHERE ProductID = ANY
	(SELECT ProductID
	FROM OrderDetails
	WHERE Quantity > 99);

-- Запрос перечисляет ProductName, если он обнаруживает, что ЛЮБЫЕ записи в таблице OrderDetails имеют количество больше 1000 (это вернет FALSE, поскольку в столбце Quantity нет значений больше 1000):
SELECT ProductName
FROM Products
WHERE ProductID = ANY
	(SELECT ProductID
	FROM OrderDetails
	WHERE Quantity > 1000);
```
### `ALL`
Оператор **`ALL`**:
- в результате возвращает логическое значение;
- возвращает `TRUE`, если ВСЕ значения подзапроса соответствуют условию;
- используется с операторами `SELECT`, `WHERE` и `HAVING`.

`ALL` означает, что условие будет истинным только в том случае, если операция истинна для всех значений в диапазоне.
```sql
SELECT ALL column_name(s)
FROM table_name
WHERE condition;

SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
	(SELECT column_name
	FROM table_name
	WHERE condition);
```

Оператор должен быть стандартным оператором сравнения (`=`, `<>`, `!=`, `>`, `>=`, `<`, `<=`).

Примеры:
```sql
-- В следующем запросе перечислены ВСЕ названия продуктов:
SELECT ALL ProductName
FROM Products
WHERE TRUE;

-- Запрос перечисляет ProductName, если ВСЕ записи в таблице OrderDetails имеют количество, равное 10. Это, конечно, вернет FALSE, потому что столбец Quantity имеет много разных значений (не только значение 10):
SELECT ProductName
FROM Products
WHERE ProductID = ALL
	(SELECT ProductID
	FROM OrderDetails
	WHERE Quantity = 10);
```
## `LIKE`
Оператор **`LIKE`** используется в предложении `WHERE` для поиска заданного шаблона в столбце.

В сочетании с оператором `LIKE` часто используются два подстановочных знака:
- Знак процента (`%`) представляет ноль, один или несколько символов.
- Знак подчеркивания (`_`) представляет один единственный символ.
```sql
SELECT column1, column2, ...
FROM table_name
WHERE columnN LIKE pattern;
```

Примеры:
```sql
-- Запрос выбирает всех клиентов с именем CustomerName, начинающимся с «a»:
SELECT * FROM Customers
WHERE CustomerName LIKE 'a%';

-- Запрос выбирает всех клиентов с CustomerName, оканчивающимся на «a»:
SELECT * FROM Customers
WHERE CustomerName LIKE '%a';

-- Запрос выбирает всех клиентов с CustomerName, у которых 'r' стоит во второй позиции:
SELECT * FROM Customers
WHERE CustomerName LIKE '_r%';
```
# Условные операторы
## `CASE`
Выражение **`CASE`** проходит через условия и возвращает значение при выполнении первого условия (как оператор if-then-else). Итак, как только условие истинно, оно прекращает чтение и возвращает результат. Если ни одно из условий не выполняется, возвращается значение в предложении `ELSE`.

Если нет части `ELSE` и никакие условия не верны, возвращается `NULL`.
```mysql
CASE
	WHEN condition1 THEN result1
	WHEN condition2 THEN result2
	WHEN conditionN THEN resultN
	ELSE result
END;
```

Примеры:
```mysql
-- Запрос выполняет условия и возвращает значение при выполнении первого условия:
SELECT OrderID, Quantity,
CASE
	WHEN Quantity > 30 THEN 'The quantity is greater than 30'
	WHEN Quantity = 30 THEN 'The quantity is 30'
	ELSE 'The quantity is under 30'
END AS QuantityText
FROM OrderDetails;

-- Запрос упорядочит клиентов по городам. Однако, если City имеет значение NULL, то порядок по Country:
SELECT CustomerName, City, Country
FROM Customers
ORDER BY
(CASE
	WHEN City IS NULL THEN Country
	ELSE City
END);
```
# Wildcards
**Подстановочный знак** используется для замены одного или нескольких символов в строке.

Подстановочные знаки используются с оператором `LIKE`. Оператор `LIKE` используется в
предложении `WHERE` для поиска заданного шаблона в столбце.

| Символ | Описание                                                  | Пример                                          |
| ------ | --------------------------------------------------------- | ----------------------------------------------- |
| `%`    | Представляет ноль или более символов                      | `bl%` находит `bl`, `black`, `blue`, `blob`     |
| `_`    | Представляет один символ                                  | `h_t` находит `hot`, `hat`, `hit`               |
| `[]`   | Представляет любой одиночный символ в квадратных скобках  | `h[oa]t` находит `hot` и `hat`,<br>но не `hit`  |
| `^`    | Представляет любой символ, не указанный в скобках         | `h[^oa]t` находит `hit`, но не<br>`hot` и `hat` |
| `-`    | Представляет любой одиночный символ в указанном диапазоне | `c[a-b]t` находит `cat` и `cbt`                 |
# Операторы для работы с данными
## `INSERT INTO`
Оператор **`INSERT INTO`** используется для вставки новых записей в таблицу.

Оператор `INSERT INTO` можно написать двумя способами:
1. Укажите как имена столбцов, так и значения для вставки:
```sql
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```
2. Если вы добавляете значения для всех столбцов таблицы, вам не нужно указывать имена столбцов в SQL-запросе. Однако убедитесь, что порядок значений соответствует порядку столбцов в таблице. Здесь синтаксис `INSERT INTO` будет следующим:
```sql
INSERT INTO table_name
VALUES (value1, value2, value3, ...);
```

Примеры:
```sql
-- Запрос вставляет новую запись в таблицу «Customers»:
INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');

-- Запрос вставит новую запись, но вставит данные только в столбцы «CustomerName», «City» и «Country» (CustomerID будет обновлен автоматически):
INSERT INTO Customers (CustomerName, City, Country)
VALUES ('Cardinal', 'Stavanger', 'Norway');
```
## `UPDATE`
Оператор **`UPDATE`** используется для изменения существующих записей в таблице.
```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

Примеры:
```sql
-- Запрос обновляет первого клиента (CustomerID = 1) новым контактным лицом и новым городом:
UPDATE Customers
SET ContactName = 'Alfred Schmidt', City = 'Frankfurt'
WHERE CustomerID = 1;

-- Запрос обновит ContactName до «Juan» для всех записей, где страна — «Mexico»:
UPDATE Customers
SET ContactName = 'Juan'
WHERE Country = 'Mexico';
```
## `DELETE`
Оператор **`DELETE`** используется для удаления существующих записей в таблице.
```sql
DELETE FROM table_name WHERE condition;
```

Примеры:
```sql
-- Запрос удаляет клиента «Alfreds Futterkiste» из таблицы «Customers»:
DELETE FROM Customers WHERE CustomerName = 'Alfreds Futterkiste';

-- Запрос удаляет все строки в таблице «Customers», не удаляя саму таблицу:
DELETE FROM Customers;
```
# Оконные функции
Взято с [Habr](https://habr.com/ru/articles/664000/).

Синтаксис оконных функций вне зависимости от их класса будет так или иначе состоять из
идентичных команд.
![sql_window_function1](/pictures/sql_window_function1.png)

Оконные функции можно прописывать как под командой `SELECT`, так и в отдельном ключевом слове `WINDOW`, где окну дается alias (псевдоним), к которому можно обращаться в `SELECT` выборке.
![sql_window_function2](/pictures/sql_window_function2.png)

Множество оконных функций можно разделять на 3 класса:
- **Агрегирующие** (Aggregate);
- **Ранжирующие** (Ranking);
- **Функции смещения** (Value).

| Aggregate | Ranking        | Value           |
| --------- | -------------- | --------------- |
| `AVG()`   | `DENSE_RANK()` | `FIRST_VALUE()` |
| `COUNT()` | `NTILE()`      | `LAST_VALUE()`  |
| `MAX()`   | `RANK()`       | `LAG()`         |
| `MIN()`   | `ROW_NUMBER()` | `LEAD()`        |
| `SUM()`   | `CUME_DIST()`  | `NTH_VALUE()`   |
## Агрегирующие
Можно применять любую из агрегирующих функций - `SUM`, `AVG`, `COUNT`, `MIN`, `MAX`:
```mysql
select name, subject, grade,
sum(grade) over (partition by name) as sum_grade,
avg(grade) over (partition by name) as avg_grade,
count(grade) over (partition by name) as count_grade,
min(grade) over (partition by name) as min_grade,
max(grade) over (partition by name) as max_grade
from student_grades;
```
![sql_window_function3](/pictures/sql_window_function3.png)
## Ранжирующие
В ранжирующих функциях под ключевым словом `OVER` обязательным идёт указание условия `ORDER BY`, по которому будет происходить сортировка ранжирования.

**`ROW_NUMBER()`** - функция вычисляет последовательность ранг (порядковый номер) строк внутри партиции, НЕЗАВИСИМО от того, есть ли в строках повторяющиеся значения или нет.

**`RANK()`** - функция вычисляет ранг каждой строки внутри партиции. Если есть повторяющиеся значения, функция возвращает одинаковый ранг для таких строчек, пропуская при этом следующий числовой ранг.

**`DENSE_RANK()`** - то же самое что и `RANK`, только в случае одинаковых значений `DENSE_RANK` не пропускает следующий числовой ранг, а идёт последовательно.
```mysql
select name, subject, grade,
row_number() over (partition by name order by grade desc),
rank() over (partition by name order by grade desc),
dense_rank() over (partition by name order by grade desc)
from student_grades;
```
![sql_window_function4](/pictures/sql_window_function4.png)

**`NTILE()`** - распределяет строки упорядоченной секции в заданное количество групп. Группы нумеруются, начиная с единицы. Для каждой строки функция `NTILE` возвращает номер группы, которой принадлежит строка.
```sql
NTILE (integer_expression) OVER ( [ <partition_by_clause> ] < order_by_clause > )
```

- **`integer_expression`**. Это положительное целое выражение, указывающее число групп, на которые необходимо разделить каждую секцию. `integer_expression` может иметь тип `int` или `bigint`.
- **`<partition_by_clause>`**. Делит результирующий набор, полученный с помощью предложения `FROM`, на секции, к которым применяется функция.
- **`<order_by_clause>`**. Определяет порядок назначения значений функции `NTILE` строкам секции. Целое значение не может представлять столбец при использовании `<order_by_clause>` в ранжирующей функции.

**`CUME_DIST()`** - эта функция вычисляет интегральное распределение значений в группе значений. Другими словами, `CUME_DIST` вычисляет относительное положение указанного значения в группе значений. Исходя из восходящего порядка сортировки, `CUME_DIST` значения для строки `r` — это число строк со значениями, меньшими или равными значению `r`, делённое на число строк, полученных в секции или результирующем наборе запроса.
```sql
CUME_DIST( ) OVER ( [ partition_by_clause ] order_by_clause )
```

- **`partition_by_clause`** делит результирующий набор, полученный с помощью предложения `FROM`, на секции, к которым применяется функция. Если аргумент `partition_by_clause` не указан, функция `CUME_DIST` обрабатывает все строки результирующего набора запроса как одну группу. Аргумент `order_by_clause` определяет логический порядок, в котором выполняется операция. Для функции `CUME_DIST` аргумент `order_by_clause` является обязательным.
## Функции смещения
Это функции, которые позволяют перемещаясь по выделенной партиции таблицы обращаться к предыдущему значению строки или крайним значениям строк в партиции.

**`LAG()`** - функция, возвращающая предыдущее значение столбца по порядку сортировки.

**`LEAD()`** - функция, возвращающая следующее значение столбца по порядку сортировки.
```mysql
select name, quartal, subject, grade,
lag(grade) over (order by quartal) as previous_grade,
lead(grade) over (order by quartal) as next_grade
from grades_quartal;
```
![sql_window_function5](/pictures/sql_window_function5.png)

Немного подробнее о `LAG()` и `LEAD()`:
```mysql
LAG (scalar_expression [,offset] [,default]) 
	OVER ( [ partition_by_clause ] order_by_clause )
```

- **`scalar_expression`**. Возвращаемое значение основано на указанном смещении. Это выражение любого типа, возвращающее единичное (скалярное) значение. `scalar_expression` не может быть аналитической функцией.
- **`offset`**. Количество строк до строки перед текущей строкой, из которой необходимо получить значение. Если значение аргумента не указано, то по умолчанию принимается 1. `offset` может быть столбцом, вложенным запросом или другим выражением, с помощью которого вычисляется целая положительная величина, или другим типом, который может быть неявно преобразован в `bigint`. `offset` не может быть отрицательным значением или аналитической функцией.
- **`default`**. Возвращаемое значение, когда `offset` находится за пределами секции. Если значение по умолчанию не задано, то возвращается `NULL`. `default` может быть столбцом, вложенным запросом или другим выражением, но не может быть аналитической функцией. Аргумент `default` должен быть совместим по типу с аргументом `scalar_expression`.

**`FIRST_VALUE()`**/**`LAST_VALUE()`** - функции возвращающие первое или последнее значение столбца в указанной партиции. В качестве аргумента указывает столбец, значение которого нужно вернуть. В оконной функции под словом `OVER` обязательное указание `ORDER BY` условия.

**`NTH_VALUE()`** - возвращает n-ное значение указанного столбца `nth_value(expr, offset)`, где `expr` - столбец, а `offset` - значение, которое хотим вернуть.
# `WITH`
Задаётся временно именованный результирующий набор, называемый **обобщённым табличным выражением (ОТВ)**. Он получается при выполнении простого запроса и определяется в области выполнения одиночной инструкции `SELECT`, `INSERT`, `UPDATE`, `DELETE` или `MERGE`.

Проще говоря, предложение `WITH` является необязательным префиксом для `SELECT`:
```mysql
WITH query_name (column_name1, ...) AS
	(SELECT ...)
SELECT ...
```

`WITH` не является отдельной командой, такой как `CREATE VIEW`: за ней должен следовать `SELECT`. Этот запрос (и содержащиеся в нём подзапросы) может ссылаться на только что определённое имя запроса в своём предложении `FROM`.

Одно предложение `WITH` может вводить несколько имён запросов, разделяя их запятой
(ключевое слово `WITH` не повторяется). Каждый из этих запросов может ссылаться на имена
запросов, ранее определённые в том же пункте `WITH`:
```mysql
WITH query_name1 AS (
	SELECT ...
	)
	, query_name2 AS (
		SELECT ...
		FROM query_name1
		...
	)
SELECT ...
```

Примеры:
```mysql
WITH Aeroflot_trips AS
	(SELECT TRIP.* FROM Company
		INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")
		
SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;

WITH Aeroflot_trips (aeroflot_plane, town_from, town_to) AS
	(SELECT plane, town_from, town_to FROM Company
		INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")
		
SELECT * FROM Aeroflot_trips;
```
# `INDEX`
Создаёт **реляционный индекс** для таблицы или представления. Он также называется индексом `rowstore`, так как является **кластеризованным** или **некластеризованным** индексом сбалансированного дерева. Индекс `rowstore` можно создать до заполнения таблицы данными. Индекс `rowstore` позволяет повысить производительность запросов, особенно в том случае, если запросы выбирают определённые столбцы или им требуются значения, которые должны быть отсортированы в определённом порядке.
```mysql
CREATE [ UNIQUE ] [ CLUSTERED | NONCLUSTERED ] INDEX index_name
ON table_name (column1, column2, ...);
```

Примеры:

В следующем примере создаётся некластеризованный индекс для столбца `VendorID` таблицы `Purchasing.ProductVendor`:
```mysql
CREATE INDEX IX_VendorID ON ProductVendor (VendorID);
CREATE INDEX IX_VendorID ON dbo.ProductVendor (VendorID DESC, Name ASC, Address DESC);
CREATE INDEX IX_VendorID ON Purchasing..ProductVendor (VendorID);
```

В следующем примере создаётся некластеризованный составной индекс в столбцах `SalesQuota` и `SalesYTD` таблицы `Sales.SalesPerson`:
```mysql
CREATE NONCLUSTERED INDEX IX_SalesPerson_SalesQuota_SalesYTD 
ON Sales.SalesPerson (SalesQuota, SalesYTD);
```

В следующем примере создаётся кластеризованный индекс для столбца `VendorID` таблицы `ProductVendor` в базе данных `Purchasing`:
```mysql
CREATE CLUSTERED INDEX IX_ProductVendor_VendorID 
ON Purchasing.ProductVendor (VendorID);
```

В следующем примере создаётся индекс `IX_FF` с двумя столбцами из таблицы `dbo.FactFinance`. Следующая инструкция перестраивает индекс с ещё одним столбцом и сохраняет существующее имя:
```mysql
CREATE INDEX IX_FF ON dbo.FactFinance (FinanceKey ASC, DateKey ASC);

-- Rebuild and add the OrganizationKey
CREATE INDEX IX_FF ON dbo.FactFinance (FinanceKey, DateKey, OrganizationKey DESC)
	WITH (DROP_EXISTING = ON);
```

В следующем примере создаётся уникальный некластеризованный индекс в столбце `Name` таблицы `Production.UnitMeasure`. Индекс требует уникальности данных, вставляемых в столбец `Name`:
```mysql
CREATE UNIQUE INDEX AK_UnitMeasure_Name
ON Production.UnitMeasure(Name);
```
# Функции
## `CAST`
Функция **`CAST()`** преобразует значение (любого типа) в указанный тип данных.
```sql
CAST(expression AS datatype(length))
```

Примеры:
```sql
SELECT CAST(25.65 AS varchar);

SELECT CAST('2017-08-25' AS datetime);
```
## `COALESCE`
Функция **`COALESCE()`** возвращает первое ненулевое значение в списке.
```mysql
COALESCE(val1, val2, ...., val_n)
```

Примеры:
```mysql
SELECT COALESCE(NULL, 1, 2, 'W3Schools.com');
```
# Операторы Transact-SQL
## `INTERSECT`
**`INTERSECT`** (пересечение) – это оператор Transact-SQL, который выводит одинаковые строки из первого, второго и последующих наборов данных. Другими словами, он выведет только те строки, которые есть как в первом результирующем наборе, так и во втором (третьем и так далее), т.е. происходит пересечение этих строк.

Данный оператор очень полезен, например, тогда, когда необходимо узнать какие строки есть и в первой таблице и во второй (к примеру, повтор данных).

Как и у оператора `UNION`, у `INTERSECT` есть правила, например, то, что количество полей во
всех результирующих наборах должно быть одинаковым, также как и их тип данных.
```sql
SELECT column_name(s)
FROM table1
INTERSECT
SELECT column_name(s)
FROM table2
```

Примеры:

Таблица `Solnyshko`:

| Prod_ID | ProdName | Maker | Quantity |
| ------- | -------- | ----- | -------- |
| 1       | хлеб     | AB    | 100      |
| 2       | молоко   | CD    | 65       |
| 3       | мясо     | EF    | 75       |
| 4       | рыба     | GH    | 60       |
| 5       | сахар    | IJ    | 45       |

Таблица `Veterok`:

| Prod_ID | ProdName | Maker | Quantity |
| ------- | -------- | ----- | -------- |
| 1       | хлеб     | QW    | 85       |
| 2       | молоко   | LD    | 70       |
| 3       | сыр      | MV    | 45       |
| 4       | масло    | DG    | 62       |
| 5       | рыба     | LN    | 55       |

Вывести список продуктов, которые имеются и в магазине `Solnyshko`, и в магазине `Veterok`:
```sql
SELECT ProdName
FROM Solnyshko
INTERSECT
SELECT ProdName
FROM Veterok
```

Результат:

| ProdName |
| -------- |
| хлеб     |
| молоко   |
| рыба     |
## `EXCEPT`
**`EXCEPT`** (разность) — это оператор Transact-SQL, который выводит только те данные из первого набора строк, которых нет во втором наборе.

Здесь те же правила, что и у оператора `INTERSECT`, т.е. количество столбцов (и их тип) должно быть одинаковым.

`EXCEPT` полезен тогда, когда необходимо сравнить две таблицы и вывести только те строки первой таблице, которых нет в другой таблице.
```sql
SELECT column_name(s)
FROM table1
EXCEPT
SELECT column_name(s)
FROM table2
```

Примеры:

Таблица `Solnyshko`:

| Prod_ID | ProdName | Maker | Quantity |
| ------- | -------- | ----- | -------- |
| 1       | хлеб     | AB    | 100      |
| 2       | молоко   | CD    | 65       |
| 3       | мясо     | EF    | 75       |
| 4       | рыба     | GH    | 60       |
| 5       | сахар    | IJ    | 45       |

Таблица `Veterok`:

| Prod_ID | ProdName | Maker | Quantity |
| ------- | -------- | ----- | -------- |
| 1       | хлеб     | QW    | 85       |
| 2       | молоко   | LD    | 70       |
| 3       | сыр      | MV    | 45       |
| 4       | масло    | DG    | 62       |
| 5       | рыба     | LN    | 55       |

Вывести список продуктов, которые имеются в магазине `Solnyshko`, и отсутствуют в магазине `Veterok`:
```sql
SELECT ProdName
FROM Solnyshko
EXCEPT
SELECT ProdName
FROM Veterok
```

Результат:

| ProdName |
| -------- |
| мясо     |
| сахар    |

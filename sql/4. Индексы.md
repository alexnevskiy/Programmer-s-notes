Взято с [TimeWeb](https://timeweb.cloud/tutorials/sql/indeksy-v-sql-sozdanie-vidy-i-kak-rabotayut), sql-eq ([1](https://sql-ex.ru/blogs/?/Ponimanie_indeksa_SQL_kljuch_k_bystromu_vypolneniju_zaprosov.html)), ([2](https://sql-ex.ru/blogs/?/Vse,_chto_vam_nuZhno_znat_ob_indekse_v_SQL_Server.html)), [Habr](https://habr.com/ru/companies/ruvds/articles/724066/).
# Принцип работы индексов
**Индекс** — это объект, который создаётся для одного или более столбцов в таблицах базы данных с целью повышения производительности, а именно для ускорения поиска и извлечения требуемых данных из базы данных.

Индекс представляет собой **структуру, которая хранится на диске и предназначена для столбцов таблицы, а также для объектов типа представления (Views)**.

Индекс состоит из **ключей**. **Ключи построены из одного или более столбцов в таблице**. Сами ключи хранятся в виде структуры сбалансированного дерева (древовидная структура, предназначенная для быстрого доступа к данным). Данная структура берёт свое начало с корневого узла на вершине иерархии и далее продолжается в виде конечных узлов, которые располагаются в нижней части сбалансированного дерева.

Главная особенность индексов заключается в скорости поиска данных, которая достигается за счёт того, что индекс состоит из структуры (структуры сбалансированного дерева), которая оптимизирована под поиск.

Также стоит отметить, что **при добавлении (вставке) новых данных или при удалении старых данных, древовидная структура индекса будет пересчитываться каждый раз**. Отсюда можно сделать вывод: **чем больше данных и индексов хранится в базе данных, тем больше деревьев индекса будет пересчитываться**. Предположим, у нас есть таблица с пятью индексами, в которых суммарно содержатся 10000 записей. При каждом новом добавлении данных заново будут пересчитаны все пять индексов с 10000 записей.
# Типы индексов
## Кластеризованный индекс
**Кластеризованный индекс** — индекс, который сортирует строки с данными в таблице. Кластеризованный индекс хранит данные в листьях индекса. **Главная особенность кластеризованного индекса заключается в том, что все значения отсортированы в определённом порядке либо по возрастанию, либо по убыванию.** Следует отметить, что данные в таблице хранятся в отсортированном виде только в том случае, когда у этой таблицы создан кластеризованный индекс. 

При использовании кластерного индекса данные упорядочены физически (т.е. хранятся, например, на жёстком диске). Благодаря этому существенно возрастает скорость поиска данных (при условии последовательного доступа к данным). Однако операция, связанная с изменением порядка данных, может быть затратной и требовать перестроения. В отличие от обычных индексов, кластеризованный индекс создаётся на всю таблицу сразу, а не на один или более столбцов. **В таблице может присутствовать только один кластеризованный индекс, и он часто создаётся (автоматически) на столбце первичного ключа.**

**Ключевые моменты**:  
- Каждая таблица может иметь только один кластеризованный индекс.
- При создании первичного ключа в таблице автоматически создаётся кластеризованный индекс.
- Столбцы в кластеризованном индексе располагаются в порядке, указанном при создании индекса.
- Вы не можете использовать ключевое слово `INCLUDE`, чтобы добавить больше полей.

Пример синтаксиса:  
```mysql
CREATE CLUSTERED INDEX cix_your_table_id
ON your_table(id);
```
## Некластеризованный индекс
**Некластеризованный индекс** — индекс, который используется для применения индексов к неключевым столбцам. Главное отличие от кластеризованного индекса заключается в том, что **некластеризованный индекс не упорядочивает данные физически**. Некластеризованный индекс хранит данные и индексы в разных местах. **Листья некластеризованного индекса содержат только те столбцы таблицы, по которым определён данный индекс.** Это означает, что системе запросов необходима дополнительная операция для извлечения требуемых данных. 

Некластеризованные индексы нельзя отсортировать, в отличие от кластеризованных, однако **существует возможность создания более одного некластеризованного индекса**. Также при использовании некластеризованного индекса можно добавить уникальный ключ для таблицы.

**Ключевые моменты**:  
- Для таблицы может существовать множество некластеризованных индексов.
- Некластеризованный индекс не влияет на физический порядок данных в таблице.
- Каждый некластеризованный индекс содержит список указателей на соответствующие строки данных.
- Вы можете добавить `INCLUDE` с другими полями или несколькими полями в одном и том же индексе.

Пример синтаксиса:  
```mysql
CREATE NONCLUSTERED INDEX ncix_your_table_date 
ON your_table(date ASC);

CREATE NONCLUSTERED INDEX ncix_your_table_date 
ON your_table(date DESC);
```

Пример синтаксиса с несколькими столбцами:  
```mysql
CREATE NONCLUSTERED INDEX ncix_your_table_name_date
ON your_table(name, date);
```

- Если ваш запрос использует `name` и `date` в предложении `WHERE` или `ORDER BY`, то полезно с точки зрения производительности добавить эти поля в индекс.
- Если запросам требуются только столбцы `name` и `date`, данный индекс может обслуживать такие запросы без необходимости обращаться к индексируемой таблице.

Пример синтаксиса с `INCLUDE`:  
```mysql
CREATE NONCLUSTERED INDEX ncix_your_table_name_include 
ON your_table(name)
INCLUDE (phone);
```

- Вместо создания индекса для каждого столбца вы можете добавить `INCLUDE` с полями, которые находятся в предложении `SELECT`.
- Так как столбцы `name` и `phone` находятся в индексе, запросы могут обслуживаться непосредственно индексом, избегая необходимости доступа к индексируемой таблице.
- Если запросы требуют комбинированную информацию из столбца `name` со столбцом `phone`, данный индекс может оптимизировать производительность таких запросов.
## Уникальный индекс
**Уникальный индекс** обеспечивает соблюдение уникальности значений в столбце. Он часто используется на столбцах, представляющих первичные ключи или другие уникальные идентификаторы. Он гарантирует, что **никакие две строки не будут иметь одинаковые значения в проиндексированном столбце**.  
```mysql
CREATE UNIQUE INDEX имя_индекса
ON имя_столбца (столбец1, столбец2, ...);
```
## Фильтрованный / частичный индекс
Когда мы создаём индекс на подмножестве строк таблицы или строк с заданным условием, то он называется **фильтрованным индексом**. В некоторых базах данных фильтрованный индекс и частичный индекс имеют один и тот же смысл, но некоторые проводят незначительное отличие.  
```mysql
CREATE INDEX имя_индекса
ON имя таблицы (столбец1, столбец2, ...)
WHERE условие_фильтрации;
```
## Покрывающий индекс
Когда индекс включает все столбцы, необходимые для выполнения запроса, он называется **покрывающим индексом**. Например, мы создали некластеризованный индекс на 3 столбцах, и мы запрашиваем только эти столбцы, тогда этот некластеризованный индекс называется покрывающим индексом. **Покрывающий индекс делает ненужным доступ к индексируемой таблице**.
## Поколоночный индекс
**Поколоночный индекс** используется в системе с поколоночным хранением данных. Как правило, он используется для запросов к большим таблицам в хранилищах данных. Этот индекс использует поколоночное хранение данных, а не построчное.
```mysql
CREATE [ CLUSTERED | NONCLUSTERED ] COLUMNSTORE INDEX имя_индекса
ON имя_таблицы;
```
## Пространственный индекс
**Пространственный индекс** позволяет проиндексировать пространственный столбец. **Пространственный столбец** - это столбец таблицы, который содержит данные пространственного типа, подобные фигуре или местности, географии.  
```mysql
CREATE SPATIAL INDEX имя_индекса
ON имя_таблицы (столбец_геометрии)
USING GEOMETRY_AUTO_GRID;
```
# Фрагментация индексов
Обслуживание индекса начинается с понимания **фрагментации**. Когда мы создаём индекс, его фрагментация начинается с 0%, но по мере использования фрагментация растёт, что приводит к потере производительности.  
- **Фрагментацию вызывают операции CRUD, где наибольший урон наносит INSERT.**

Для проверки уровня фрагментации используйте следующий запрос:
```mysql
SELECT
    OBJECT_NAME(B.object_id) AS TableName,
    B.name AS IndexName,
    A.index_type_desc AS IndexType,
    A.avg_fragmentation_in_percent
FROM
    sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED')  A
    INNER JOIN sys.indexes B WITH(NOLOCK) ON B.object_id = A.object_id AND B.index_id = A.index_id
WHERE
    OBJECT_NAME(B.object_id) NOT LIKE '[_]%'
    AND A.index_type_desc != 'HEAP'
ORDER BY
    A.avg_fragmentation_in_percent DESC
```

Результат:
![sql_index_fragmentation1](/pictures/sql_index_fragmentation1.webp)

Вставим 10000 строк:
```mysql
DECLARE @RowCount INT = 100000;
DECLARE @Counter INT = 1;
WHILE @Counter <= @RowCount
BEGIN
    INSERT INTO [your_table] ([date], [name], [phone])
    VALUES 
    (
        DATEADD(DAY, -ABS(CHECKSUM(NEWID())) % 365, GETDATE()), -
        'Name' + CAST(@Counter AS VARCHAR(5)), 
        '(' + CAST(ABS(CHECKSUM(NEWID())) % 9000000000 + 1000000000 AS VARCHAR(14)) + ')'
    );
    SET @Counter = @Counter + 1;
END;
```

Теперь обратим внимание на фрагментацию:
![sql_index_fragmentation2](/pictures/sql_index_fragmentation2.webp)
## Внутренняя и внешняя фрагментация
Фрагментация может быть как **внутренней**, так и **внешней**, эти два типа относятся к распределению данных в структурах хранения. Т.е. к тому, как они организованы.

**Внутренняя фрагментация**:
- Имеет место, когда **возникает неиспользованное пространство на странице хранения**.
- Результат распределения места в фиксированных блоках, приводящее к неиспользуемому пространству при неполном заполнении блока.
- Приводит к избыточному пространству и увеличению физического размера, занятого данными.
- Пример: В системе управления файлами, которая выделяет пространство блоками по 4Кб, если файлы занимают 2,5Кб, то внутренняя фрагментация составит 1,5Кб неиспользованного пространства.

**Внешняя фрагментация**:  
- Имеет место, когда **пространство с данными распределено по разбросанным блокам, а не по непрерывным**. Когда логический порядок страниц отличается от их физической организации в файлах данных.
- Является результатом вставок, удалений или обновлений данных, которые оставляют зазоры.
- Может вызывать трудности в эффективном размещении новых данных, даже если свободного пространства достаточно в принципе.
- Пример: Если множество записей удаляется из таблицы базы данных, создавая зазоры, это может вызывать внешнюю фрагментацию.
## Перестройка и реорганизация
Именно в этот момент требуется техническое обслуживание, **`REBUILD`** и **`REORGANIZE`** - это операции обслуживания индексов в реляционных базах данных. Эти операции призваны оптимизировать производительность и эффективность индексов.
### `REBUILD`  
**Когда использовать**:
- Когда внутренняя или внешняя фрагментация достигла критического уровня (может использоваться в примере выше).
- После основных операций обслуживания, таких как массовая загрузка данных (или `bulk insert`).
- Когда происходят изменения в структуре индекса, например, добавление или удаление столбцов.
  
**Какое действие оказывает**:
- Полностью устраняет фрагментацию.
- Пересоздаёт индекс, приводя к появлению нового физического индекса.
- Может потребоваться больше ресурсов (ЦП, место на диске) и вызвать блокировку операций с индексом во время процесса. (Выполняйте это в часы минимальной нагрузки).

Пример:
```mysql
ALTER INDEX cix_your_table_id ON [your_table] REBUILD; -- CLUSTERED
ALTER INDEX ncix_your_table_name_date ON [your_table] REBUILD; -- NONCLUSTERED
```

### `REORGANIZE` 
**Когда использовать**:
- При небольшой или умеренной фрагментации.
- Может выполняться после некоторых заданий ETL, когда происходит массовая загрузка данных.
- Это менее агрессивный вариант, чем `REBUILD`, и годится для поддержания индекса в "хорошем" состоянии".

**Какое действие оказывает**:
- Реогранизует страницы индекса, но не перестраивает индекс полностью.
- Обычно более эффективно использует ресурсы и позволяет индексу оставаться доступным для запросов во время реорганизации.

Пример:
```mysql
ALTER INDEX cix_your_table_id ON [your_table] REORGANIZE; -- CLUSTERED
ALTER INDEX ncix_your_table_name_date ON [your_table] REORGANIZE; -- NONCLUSTERED
```
### Сравнение
Пример использования `REORGANIZE`:
![sql_index_fragmentation3](/pictures/sql_index_fragmentation3.webp)

Во многих случаях такого сильного сокращения не будет. Однако `REORGANIZE` является лучшим выбором для обслуживания по расписанию. `REBUILD` может заблокировать вашу базу данных в зависимости от размера таблицы.

Перед тестированием `REBUILD` снова вставим строки:
![sql_index_fragmentation4](/pictures/sql_index_fragmentation4.webp)

И выполним `REBUILD`:
![sql_index_fragmentation5](/pictures/sql_index_fragmentation5.webp)

Сокращение больше, чем в случае `REORGANIZE`.
# Особенности использования индексов
При работе с индексами важно быть осторожным и принимать обоснованные решения, чтобы избежать потенциальных рисков и обеспечить оптимальную производительность базы данных.  
  
Имейте в виду следующие важные факторы:  
- **Не создавайте слишком много индексов:** Переиндексированная таблица может увеличить требования к хранилищу, замедлить операции модификации данных и усложнить обслуживание индексов. Создавайте индексы, если только они необходимы для увеличения производительности запросов.
- **Обслуживайте индексы:** Следует регулярно мониторить и обслуживать индексы, чтобы избежать фрагментации, которая со временем может снизить производительность. Если индексы фрагментированы, рассмотрите необходимость их перестройки или реорганизации.
- **Статистика индекса:** Поддерживайте актуальность статистики индексов, чтобы оптимизатор запросов мог принять точное решение относительно выбора плана выполнения.
- **Неиспользуемый индекс:** Регулярно пересматривайте использование индексов. Если индекс не используется никаким запросом, лучше его удалить.

Хотя индексы являются полезным инструментом для улучшения производительности запросов, при некоторых обстоятельствах может быть лучше избегать их или использовать в редких случаях. Вот некоторые ситуации, когда, возможно, лучше избегать их или использовать минимально:  
- **Часто обновляемая таблица:** Индексы могут вызвать значительную нагрузку при частом выполнении операций вставки, обновления или удаления в таблице. Обслуживание индексов требуется для каждой операции модификации, что может ухудшить производительность записи.
- **Небольшие таблицы:** Для таких таблиц не требуется индекс, поскольку ядро базы данных может быстро их сканировать.
- **Столбцы с низким кардинальным числом:** Проиндексированные столбцы с незначительным числом различных значений могут не обеспечить значительный прирост производительности и будут фактически увеличивать стоимость хранения и обслуживания.
- **Пакетная загрузка данных:** Часто более эффективным оказывается удаление индексов перед загрузкой большого количества данных в пакете с последующим их воссозданием. Обслуживание индекса при загрузке данных может вызвать задержку выполнения.
# Алгоритмы индексирования
Индексирование базы данных обычно выполняется при помощи алгоритма, определяющего, как должен создаваться и храниться индекс. Конкретный процесс создания индекса может варьироваться в зависимости от типа используемой системы базы данных, однако в целом общие этапы выглядят так:  
1. **Определение столбца или столбцов в таблице базы данных, которые нужно индексировать.** Обычно они определяются по тому, какие столбцы чаще всего используются в запросах или поисках.
2. **Выбор алгоритма индексирования, подходящего для типа индексируемых данных.** Например, индексы в виде B-деревьев обычно используются для индексирования строковых или числовых данных, а полнотекстовые индексы — для индексирования текстовых данных.
3. **Применение алгоритма индексирования к выбранным столбцам**, что создаёт структуру данных, сопоставляющую значения в столбцах с местоположениями соответствующих записей таблицы.
4. **Сохранение индекса в отдельной структуре данных**, обычно в другой части диска или в памяти, чтобы доступ к ней был более эффективным, чем к соответствующим табличным данным.
5. **Обновление индекса** в случае добавления новых записей, удаления или изменения записей в таблице.
  
Создание индекса может существенно улучшить производительность запросов к базе данных и операций поиска, поскольку оно позволяет системе базы данных находить соответствующие записи быстрее и эффективнее. Однако индексирование также может обладать и недостатками, например, увеличение требований к объёму хранилища и замедление выполнения операций вставки и обновления, поэтому перед созданием индекса следует взвесить плюсы и минусы.
## B-дерево
**B-дерево** — это структура данных самобалансирующегося дерева, которая часто используется в качестве алгоритма индексирования в базах данных. Каждый узел дерева состоит из набора ключей и указателей на дочерние узлы; хранение данных осуществляется в иерархической структуре. Деревья B-узлов упорядочены таким образом, что позволяют быстро выполнять поиск, вставку и удаление данных.
![sql_index_b_tree](/pictures/sql_index_b_tree.jpeg)

**Самое большое преимущество алгоритма B-дерева заключается в минимизации количества дисковых операций ввода-вывода, необходимых для доступа к данным**, потому что в B-дереве все узлы-листья находятся на одном уровне, а каждый узел может хранить множество ключей и указателей. Количество ключей и указателей, которое может храниться в узле, определяется параметром, называемым **«порядок» дерева**.

**Алгоритм B-дерева** работает следующим образом:  
1. **Инициализация**: при создании B-дерева создаётся пустой корневой узел. Параметр, задающий максимальное количество ключей («порядок»), которые могут храниться в каждом узле, управляет B-порядком дерева.
2. **Вставка**: при добавлении нового узла в B-дерево алгоритм сначала подыскивает подходящий узел-лист, в который нужно вставить ключ. B-дерево разделяет заполненный узел-лист на два новых узла и перемещает медианный ключ в родительский узел. Пока не достигнут корневой узел, процесс разделения может распространяться по дереву. Благодаря этой процедуре дерево остаётся сбалансированным, а узлы-листья находятся на одинаковой высоте.
3. **Удаление**: когда ключ удаляется из B-дерева, алгоритм ищет узел, который изначально хранил ключ. Если узел-лист хранил ключ, то ключ извлекается и узел может нуждаться в перебалансировке. Алгоритм удаляет предшествующий или последующий лист после листа-узла, удалив ключ с ним, если ключ обнаружен не в узле-листе.
4. **Поиск**: в процессе поиска ключа в B-дереве алгоритм начинает с корневого узла и рекурсивно движется к веткам, пока не найдёт нужный узел-лист. Метод поиска сравнивает искомый ключ с ключами, содержащимися в каждом узле, а затем использует соответствующий указатель для перехода к дочернему узлу, в котором может находиться ключ. Этот процесс продолжается, пока не будет найден искомый ключ или пока не будет определено, что он отсутствует в дереве.

Однако B-деревья обладают некоторыми **недостатками**:  
- **Излишняя трата ресурсов**: B-деревья задействуют большой объём излишнего пространства, поскольку каждый узел в B-дереве содержит указатель на родительский и дочерний узлы.
- **Сложность**: алгоритмы, используемые для вставки, удаления и поиска данных в B-дереве, сложнее по сравнению с другими структурами данных. Это усложняет реализацию и поддержку B-деревьев.
- **Медленные обновления**: обновление данных в B-дереве может быть относительно медленным по сравнению с другими структурами данных. Каждая операция обновления требует множества операций доступа к диску, и этот процесс может быть медленным для больших B-деревьев.
## Bitmap-индексирование
**Bitmap-индексирование** — это методика индексирования данных, использующая битовые карты (bitmap) для обозначения наличия или отсутствия значения в таблице. Это успешная техника индексирования для таблиц с низкой кардинальностью, где количество уникальных значений в столбце довольно мало по сравнению с общим количеством строк.
![sql_index_bitmap](/pictures/sql_index_bitmap.jpeg)

Bitmap-индексирование может быть очень эффективным для столбцов с низкой кардинальностью, поскольку битовые карты крайне компактны и их можно быстро сканировать для извлечения данных. **Bitmap-индексы очень удобны для применения в хранилищах данных, где необходимо быстро сканировать огромные объёмы данных.** Кроме того, они полезны для баз данных, в которых много операций чтения, но мало обновлений или вставок.

**Алгоритм bitmap** работает следующим образом:
- Для создания bitmap-индекса столбца для каждого уникального значения столбца создаётся отдельный bitmap. Каждый bitmap имеет длину, равную количеству строк в таблице.
- Если значение присутствует в строке, соответствующему биту в bitmap присваивается значение 1, а если оно отсутствует, то присваивается значение 0. (Представьте таблицу, где столбец «Gender» имеет два уникальных значения, например, «Male» и «Female». Если этот столбец имеет bitmap-индекс, можно создать два bitmap, длина каждого из которых равна количеству строк в таблице. Когда в строке встречается «Male» или «Female», соответствующий бит в bitmap «Male» или «Female» получает значение 1, и наоборот. В случае отсутствия значения «Male» или «Female» соответствующему биту присваивается значение 0.)
- Чтобы выполнить запрос при помощи bitmap-индекса, соответствующие в запросе значения bitmap комбинируются при помощи побитовых операторов AND, OR и NOT. (например, если мы хотим найти все строки, где «Gender» равно «Male» И «Age» больше 30, нам сначала нужно получить bitmap «Male» и bitmap «Age > 30» из соответствующих индексов. Затем мы комбинируем эти два bitmap при помощи побитового оператора AND и получаем окончательный bitmap только с единицами в тех позициях, где оба условия истинны. Затем окончательный bitmap используется для получения из таблицы строк, удовлетворяющих запросу.)

Bitmap-индексы имеют множество **недостатков**, и в том числе:  
- **Большой размер**: Bitmap-индексы могут быть большими, особенно при работе с крупными датасетами. Из-за этого они могут оказаться менее эффективными, чем другие методики индексирования.
- **Столбцы с высокой кардинальностью**: Bitmap-индексы неэффективны для столбцов с высокой кардинальностью, где количество уникальных значений очень высоко. В таких случаях bitmap-индексы могут становиться очень большими и не помещаться в памяти.
- **Смещённое распределение данных**: если данные смещены, у нескольких значений может быть гораздо более высокая частота, чем у других, и bitmap-индексы окажутся неэффективными. Это вызвано тем, что bitmap для наиболее частых значений становятся очень большими и могут доминировать в индексе.
## Хэш-индекс
**Хэш-индекс** — это разновидность методики индексирования баз данных, использующая хэш-функцию для сопоставления ключей индекса с местоположениями соответствующих записей данных. Это быстрый метод индексирования для запросов точного соответствия в одном столбце.
![sql_index_hash](/pictures/sql_index_hash.jpeg)

Сопоставление ключей индекса с местоположениями соответствующих записей данных позволяет выполнять быстрый поиск и вставки за постоянное время O(1). Однако этот метод плохо работает с запросами диапазонов или частичными совпадениями и может страдать от коллизий, с которыми можно справляться при помощи различных техник разрешения коллизий.

Чтобы объяснить, как работает хэш-индекс, давайте рассмотрим пример. Допустим, у нас есть таблица базы данных, содержащая информацию о сотрудниках, в том числе, номера их пользовательских ID. Мы хотим создать хэш-индекс столбца пользовательских ID, чтобы получить возможность быстрого поиска данных пользователей на основании номера их ID.
1. Мы создадим хэш-функцию, получающую на входе пользовательский ID и генерирующую на выходе уникальный хэш-код. Хэш-функция должна быть спроектирована таким образом, чтобы генерировать равномерно распределённое множество хэш-кодов для равномерного распределения записей по корзинам в файле индекса. На практике хэш-функция может использовать для генерации хэш-кода различные методики, например, модульную арифметику или побитовые операции.
2. Мы создаём файл хэш-индекса, содержащий набор корзин (bucket), каждая из которых соответствует уникальному хэш-коду сгенерированному хэш-функцией. Каждая корзина содержит указатель на файл базы данных, содержащий записи для этого хэш-кода.
3. При выполнении запроса к значению запроса применяется хэш-функция для генерации хэш-кода. Затем хэш-код используется для нахождения соответствующей корзины в файле хэш-индекса. Записи с одинаковым хэш-кодом хранятся в одной корзине, поэтому мы можем просто просканировать записи в этой корзине и найти совпадающую запись/записи. Если присутствуют коллизии (то есть несколько записей с одинаковым хэш-кодом), то для их разрешения можно использовать техники наподобие создания цепочек или открытой адресации.
4. Чтобы вставить новую запись в хэш-индекс, мы применяем к значению ключа записи хэш-функцию, чтобы сгенерировать его хэш-код, а затем вставляем запись в соответствующую корзину в файле хэш-индекса. Если коллизии отсутствуют, вставку можно выполнить за постоянное время O(1), так как нам нужно всего лишь вычислить хэш-код и вставить запись в корзину. Если коллизии есть, нам может потребоваться проделать дополнительные операции, например, вставку записи в связанный список в корзине или проверку других корзин, пока не будет найден свободный слот.

Хэш-индексы также имеют множество **недостатков**, в том числе:
- **Ограниченные возможности поиска**: хэш-индексы предназначены для обработки только поисков равенства (например, «найти все записи, где столбец A равен значению»). Они плохо подходят для запросов диапазонов или сортировки.
- **Коллизии**: хэш-индексы могут иметь коллизии, при которых несколько ключей соответствуют одному хэш-значению. Это может привести к снижению производительности, поскольку базе данных нужно будет выполнять дополнительные операции для разрешения коллизий.
- **Непредсказуемые требования к размеру хранилища**: размер хэш-индекса невозможно предугадать, так как он зависит от количества уникальных значений в индексируемом столбце. Это усложняет планирование требований к размеру хранилища.
## GiST
**GiST (Generalized Search Tree, обобщённое поисковое дерево)** — это техника индексирования баз данных, которая может использоваться для индексирования сложных типов данных, например, геометрических объектов, текста или массивов. Это сбалансированная древовидная структура, состоящая из узлов с множественными дочерними узлами. Каждый узел описывает диапазон или множество значений и связан с предикативной функцией, проверяющей, принадлежит ли значение диапазону или множеству. Предикативная функция зависит от типа индексируемых данных и может быть подстроена под разные типы данных.

Чтобы проиллюстрировать принцип работы индекса GiST, рассмотрим пример индексирования пространственных данных. Допустим, у нас есть таблица базы данных, содержащая информацию о городах, в том числе их названия и координаты в формате широты и долготы.  
1. Зададим множество предикатов и функций преобразования, специфичных для индексируемого типа пространственных данных. В данном случае мы должны задать предикат, проверяющий, находится ли заданная точка в ограничивающем прямоугольнике, описанном узлом в индексе, и функцию преобразования, преобразующую точку в набор ключей на основании её позиции в ограничивающем прямоугольнике.
2. Создаём файл индекса GiST, состоящий из множества узлов, каждый из которых описывает ограничивающий прямоугольник, охватывающий диапазон координат. 
   
   Корневой узел описывает весь диапазон координат в таблице базы данных, а каждый дочерний узел описывает подмножество этого диапазона. 
   
   Каждый узел связывается с предикативной функцией и функцией преобразования, специфичными для индексируемого типа пространственных данных.
3. При выполнении запроса значение в запросе преобразуется при помощи функции преобразования в набор ключей.  
   
   Затем ключи сравниваются с предикатами, связанными с каждым узлом индекса, начиная с корневого узла. 
   
   Поиск продолжается вниз по дереву и выбирает дочерний узел, содержащий значение из запроса. 
   
   Процесс повторяется, пока не будет достигнут узел-лист, содержащий элементы индекса, соответствующие значению в запросе.
4. Для вставки в индекс нового города координаты города сначала при помощи функции преобразования преобразуются в набор ключей. 
   
   Затем ключи вставляются в соответствующие узлы индекса, начиная с корневого узла. 
   
   Если узел заполнен, выполняется операция разделения для создания двух новых узлов и ключи распределяются между узлами.

GiST имеет несколько **недостатков**, которые нужно учитывать:
1. **Сниженная скорость вставок и обновлений**: структуры индексирования GiST могут быть сложнее, чем традиционные структуры индексирования, что может привести к снижению скорости операций вставки и обновления.
2. **Больше дискового пространства**: структуры индексирования GiST могут требовать больше дискового пространства, чем другие методики индексирования, поскольку хранят дополнительную информацию для поддержки различных типов поиска.
3. **Подходит не для всех типов данных**: GiST оптимизирован под индексирование сложных типов данных, например, пространственных данных, однако может быть не лучшим выбором для индексирования более простых типов данных, например, целочисленных значений или строк.
4. **Повышенные затраты на поддержку**: из-за сложности реализации индексы GiST требуют больше обслуживания по сравнению с традиционными индексами.
## Полнотекстовый индекс
**Полнотекстовое индексирование** — это методика индексирования баз данных, используемая для повышения эффективности поиска текстовых запросов. Это особый вид индекса, спроектированный для работы с текстовыми данными. В отличие от традиционных индексов, хранящих значения отдельных столбцов, полнотекстовый индекс хранит текстовое содержимое одного или нескольких столбцов как множества слов или токенов. Эти слова или токены используются при выполнении поискового запроса для быстрого нахождения релевантных строк.
![sql_index_text](/pictures/sql_index_text.jpeg)

Полнотекстовое индексирование способно существенно улучшить производительность текстовых поисковых запросов, особенно при работе с большими объёмами текстовых данных. Однако оно требует дополнительного дискового пространства и вычислительных ресурсов, а также тщательной настройки параметров индексирования для обеспечения оптимальной производительности.

**Процесс полнотекстового индексирования** состоит из нескольких этапов:
1. **Токенизация**: текстовое содержимое индексируемого столбца разбивается на отдельные слова или токены, которые затем сохраняются в индекс. При создании полнотекстового индекса система базы данных сначала анализирует текстовое содержимое индексируемых столбцов, а затем разбивает его на отдельные слова или токены. Этот процесс называется токенизацией, он может включать в себя фильтрацию игнорируемых слов (например, «the», «and», «or») и выделение корней (редуцирование слов до их базовой формы).
2. **Индексирование**: затем токены индексируются при помощи специальной структуры данных, например, B-дерева или инвертированного индекса. Структура индекса обеспечивает возможность эффективного поиска и извлечения строк, содержащих указанные токены.
3. **Построение и выполнение запросов**: система базы данных использует полнотекстовый индекс для поиска строк, содержащих релевантные токены. В процессе поиска токены запроса сопоставляются с индексированными токенами и извлекаются строки, соответствующие запросу. Результаты поиска можно ранжировать на основании их релевантности запросу, который вычисляется при помощи алгоритмов наподобие TF-IDF (term frequency-inverse document frequency).

Полнотекстовое индексирование имеет некоторые **недостатки**:
1. **Сниженная скорость индексирования и поиска**: полнотекстовое индексирование может быть более сложным, чем другие техники индексирования, что может приводить к снижению скорости индексирования и поиска, особенно в больших базах данных со множеством текстовых полей.
2. **Подходит не для всех типов данных**: полнотекстовое индексирование лучше всего подходит для баз данных, содержащих большие объёмы текстовых данных. Оно может и не быть наиболее эффективной техникой для баз данных, по большей мере, для содержащих числовую или другую нетекстовую информацию.
3. **Зависимость от языка**: полнотекстовое индексирование может быть не очень эффективно для многоязычных баз данных, поскольку требует отдельных индексов для каждого языка и может оказаться неспособным справиться с нюансами различных языков и систем письменности.
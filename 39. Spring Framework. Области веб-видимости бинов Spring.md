Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 9.

В любом Spring-приложении можно объявить бин, относящийся к одной из следующих областей видимости:
- **одиночный бин** — область видимости бинов в Spring по умолчанию. Фреймворк однозначно идентифицирует каждый такой экземпляр в контексте по его имени;
- **прототип** — область видимости бина в Spring, в случае которой фреймворк управляет только типом объектов и создаёт новый экземпляр класса для каждого запроса (сразу из контекста либо посредством монтажа или автомонтажа).

В веб-приложениях можно использовать и другие области видимости, относящиеся только к веб-приложениям, — **области веб-видимости бинов**. Они бывают следующих типов:
- **область видимости в рамках запроса** — Spring создаёт отдельный экземпляр класса бина для каждого HTTP-запроса. Конкретный экземпляр существует только для конкретного HTTP-запроса;
- **область видимости в рамках сессии** — Spring создаёт экземпляр и хранит его в памяти сервера в течение всей HTTP-сессии. Фреймворк связывает этот экземпляр в контексте с сессией данного клиента;
- **область видимости в рамках приложения** — экземпляр является уникальным в контексте приложения и доступен всё время работы приложения.
# Использование бинов с областью видимости в рамках запроса
Основная работа веб-приложений состоит в обработке HTTP-запросов и передаче ответов на них. Поэтому возможность создавать бины с жизненным циклом, привязанным к HTTP-запросу, значительно упрощает выполнение некоторых функций веб-приложений.

**Бин с областью видимости в рамках запроса** — это объект, управляемый Spring, для которого фреймворк создаёт новый экземпляр в рамках каждого HTTP-запроса. Приложение может использовать такой экземпляр только для того запроса, для которого он был создан. Для каждого следующего HTTP-запроса (от того же или другого клиента) создаётся и используется новый экземпляр аналогичного класса.
![spring_10.1](/pictures/spring_10.1.png)

Продемонстрируем использование бина с областью видимости в рамках запроса на примере. Мы создадим веб-приложение с функцией аутентификации и воспользуемся бином с областью видимости в рамках запроса для управления учётными данными пользователей, предоставляемыми для входа.

> **ГЛАВНЫЕ ОСОБЕННОСТИ БИНОВ С ОБЛАСТЬЮ ВИДИМОСТИ В РАМКАХ ЗАПРОСА**
> 
> Прежде чем углубиться в создание Spring-приложения на основе бинов с областью видимости в рамках запроса, необходимо кратко перечислить главные особенности их использования. Знание их специфики поможет вам выбирать нужную область видимости при разработке реальных приложений.
> 
> Принимая такие решения, учитывайте наиболее важные аспекты — они перечислены в следующей таблице.

| Факты                                                                               | Следствия                                                                                                                                                                  | Что учесть                                                                                                                                                                                                                                                        | Чего избегать                                                                                                                                                                                                                                                                                                        |
| ----------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Spring создаёт новый экземпляр бина для каждого HTTP-запроса от каждого клиента     | В процессе выполнения приложения Spring создаёт в его памяти множество экземпляров этого бина                                                                              | Как правило, количество экземпляров не является большой проблемой, так как время их жизни невелико. Они нужны приложению не дольше, чем выполняется HTTP-запрос. После завершения HTTP-запроса приложение уничтожает эти экземпляры и их подбирает сборщик мусора | Главное — проследить, чтобы в таких запросах не выполнялась затратная по времени логика, обычно необходимая Spring для создания экземпляров (такая как получение данных из базы данных или вызов функции по сети). Старайтесь не писать логику в конструкторах таких бинов или методах с аннотацией `@PostConstruct` |
| Экземпляр бина с областью видимости в рамках запроса доступен только одному запросу | Экземпляры бинов с областью видимости в рамках запроса не годятся для многопоточных задач, так как доступны только для одного потока (того, к которому принадлежит запрос) | В атрибутах такого экземпляра можно сохранять данные, используемые в запросе                                                                                                                                                                                      | Не используйте методы синхронизации для атрибутов таких бинов. Эти методы не сработают и лишь снизят производительность приложения                                                                                                                                                                                   |

Для простоты будем считать, что учётные данные всех пользователей встроены в приложение. На практике эта информация находится в базе данных; к тому же пароли хранятся в зашифрованном виде.

Создадим проект Spring Boot и внедрим необходимые зависимости. В данном примере мы будем использовать веб-зависимость и Thymeleaf в качестве шаблонизатора. Зависимости, которые нужно разместить в *pom.xml*, показаны в следующем фрагменте кода:
```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

Мы создадим страницу с формой аутентификации, в которой нужно ввести имя пользователя и пароль. Приложение будет сравнивать их с набором имеющихся у него учётных данных. Если предоставленные учётные данные правильные (соответствуют тем, которые есть в приложении), на странице под формой аутентификации появится сообщение `You are now logged in` (Вы вошли). Если же они неверны, то в сообщении будет сказано `Login failed` (Вход не выполнен).

Нам нужно создать страницу (соответствующую представлению) и класс контроллера. Контроллер будет передавать сообщение о результатах аутентификации, которое нужно вывести в представлении.
![spring_10.2](/pictures/spring_10.2.png)

Ниже представлена HTML-страница для аутентификации пользователя, которая является представлением приложения. Её нужно сохранить в папке *resources/templates* проекта Spring Boot. Назовем эту страницу *login.html*. Для вывода сообщения по результатам выполнения логики нам нужно передавать параметр из контроллера в приложение. Как видно из следующего листинга, этот параметр имеет имя `message` и использовался синтаксис `${message}`, чтобы под формой аутентификации появился нужный текст.
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head> 
	<meta charset="UTF-8"> 
	<title>Login</title>
</head>
<body> 
	<form action="/" method="post"> 
		Username: <input type="text" name="username" /><br /> 
		Password: <input type="password" name="password" /><br /> 
		<button type="submit">Log in</button> 
	</form> 
	
	<p th:text="${message}"></p>
</body>
</html>
```

Действию контроллера должен поступить HTTP-запрос (от диспетчера сервлетов), так что создадим контроллер и действие, которое получает запрос от страницы. Определение класса контроллера представлено ниже. Мы связали действие контроллера с корневым путём приложения (`/`).
```java
@Controller
public class LoginController { 

	@GetMapping("/") 
	public String loginGet() { 
		return "login.html"; 
	}
}
```

Теперь у нас есть страница входа — можно писать логику аутентификации. Когда пользователь нажимает кнопку `Submit`, страница должна размещать под формой соответствующее сообщение: если введенные учётные данные правильные, то `You are now logged in`, если нет — то `Login failed`.
![spring_10.3](/pictures/spring_10.3.png)

Для обработки HTTP-запроса типа POST, создаваемого HTML-формой, когда пользователь нажимает `Submit`, нужно добавить в `LoginController` ещё одно действие. Данное действие принимает параметры запроса клиента (имя пользователя и пароль) и передаёт в представление сообщение о результатах аутентификации. Ниже представлено определение действия контроллера. Мы свяжем его с HTTP-запросом аутентификации типа POST.
```java
@Controller
public class LoginController { 

	@GetMapping("/") 
	public String loginGet() { 
	return "login.html"; 
	} 
	
	@PostMapping("/") 
	public String loginPost(@RequestParam String username, 
		@RequestParam String password, 
		Model model) { 
		boolean loggedIn = false; 
		
		if (loggedIn) { 
			model.addAttribute("message", "You are now logged in."); 
		} else { 
			model.addAttribute("message", "Login failed!"); 
		} 
		
		return "login.html"; 
	}
}
```

На рисунке ниже наглядно представлена связь между созданным нами классом контроллера и представлением.
![spring_10.4](/pictures/spring_10.4.png)

Теперь у нас есть контроллер и представление, но где здесь область видимости запроса? Единственный написанный нами класс — `LoginController`, и это одиночный бин, что относится к области видимости Spring по умолчанию. Нам не нужно изменять область видимости `LoginController`, так как в его атрибутах не хранятся никакие данные. Но необходимо ещё написать логику аутентификации. Логика аутентификации зависит от учётных данных пользователя, и относительно этих данных необходимо принять во внимание два момента.
1. Учётные данные пользователя — конфиденциальная информация. Её нельзя хранить в памяти приложения дольше, чем обрабатывается запрос на аутентификацию.
2. Возможна ситуация, когда сразу несколько пользователей захотят аутентифицироваться, каждый со своими учётными данными.

Учитывая эти особенности, нам нужно гарантировать, что при использовании бина для построения логики аутентификации у каждого HTTP-запроса будет свой уникальный экземпляр. Нам нужен бин с областью видимости в рамках запроса. Мы дополним приложение, добавив бин `LoginProcessor` с областью видимости в рамках запроса. Этот бин извлекает учётные данные из запроса и проверяет их.
![spring_10.5](/pictures/spring_10.5.png)

Реализация класса `LoginProcessor` представлена ниже. **Чтобы изменить область видимости бина, мы воспользовались аннотацией `@RequestScoped`.** Разумеется, нам всё равно нужно создать бин этого класса в контексте Spring с помощью аннотации `@Bean` в классе конфигурации либо с помощью стереотипной аннотации.
```java
@Component
@RequestScope
public class LoginProcessor { 

	private String username; 
	private String password; 
	
	public boolean login() { 
		String username = this.getUsername(); 
		String password = this.getPassword(); 
		
		if ("natalie".equals(username) && "password".equals(password)) {
			return true; 
		} else { 
			return false; 
		} 
	} 
	
	// геттеры и сеттеры
}
```

Теперь можно запустить приложение, введя в адресной строке браузера адрес `localhost:8080`. Ниже показано поведение приложения после того, как пользователь откроет эту страницу и введёт корректные и некорректные учётные данные.
![spring_10.6](/pictures/spring_10.6.png)
# Использование области видимости в рамках сессии
Рассмотрим бины с областью видимости в рамках сессии. Открыв веб-приложение и войдя в учетную запись, пользователь ожидает, что, пока он будет просматривать страницы приложения, оно будет помнить, что данный пользователь аутентифицирован. **Бин с областью видимости в рамках сессии** — это управляемый Spring объект, для которого фреймворк создаёт экземпляр, привязанный к текущей HTTP-сессии. Когда клиент посылает запрос на сервер, сервер выделяет в памяти место для этого запроса на всё время сессии, к которой данный запрос относится. Spring создаёт экземпляр бина с областью видимости в рамках сессии в начале HTTP-сессии для данного клиента. Этот экземпляр может многократно использоваться одним и тем же клиентом, пока HTTP-сессия остаётся активной. Данные в атрибутах бина с областью видимости в рамках сессии доступны для всех запросов клиента в рамках сессии. Такой способ хранения данных позволяет не потерять информацию о том, что делает пользователь, пока переходит по страницам приложения.

**При всех запросах, передаваемых в рамках одной HTTP-сессии, клиент получает доступ к одному и тому же экземпляру бина.** У каждого пользователя есть своя сессия, поэтому они получают доступ к собственным бинам, имеющим область видимости в рамках сессии.

Потратим некоторое время на анализ рисунка ниже, на котором представлен бин с областью видимости в рамках сессии, и рисунка выше, где показан бин с областью видимости в рамках запроса. На втором рисунке ниже показан итог сравнения этих двух вариантов. Если в случае бина с областью видимости в рамках запроса Spring создаёт новый экземпляр для каждого HTTP-запроса, то во втором случае фреймворк выделяет единственный экземпляр для всей HTTP-сессии. Бины с областью видимости в рамках сессии позволяют хранить данные, используемые несколькими запросами одного и того же клиента.
![spring_10.7](/pictures/spring_10.7.png)
![spring_10.8](/pictures/spring_10.8.png)

Бины с областью видимости в рамках сессии позволяют реализовать, в частности, такие функции, как:
- **аутентификация**. В бине сохраняются данные об аутентифицированном пользователе в течение всего времени, пока он посещает различные страницы приложения и отправляет запросы;
- **корзина интернет-магазина**. Пользователь посещает разные страницы приложения в поисках товаров, которые он хочет добавить в корзину. Корзина запоминает все наименования, которые в неё поместил клиент.

> **ОСНОВНЫЕ СВОЙСТВА БИНОВ С ОБЛАСТЬЮ ВИДИМОСТИ В РАМКАХ СЕССИИ**
> 
> Как и в случае бинов с областью видимости в рамках запроса, проанализируем главные характеристики бинов с областью видимости в рамках сессии — те, которые необходимо учитывать при использовании таких бинов в реальных приложениях.

| Факты                                                                                                                                            | Следствия                                                                                                                                                            | Что учесть                                                                                                                                                                                                                                                                                                                                                                                                                       | Чего избегать                                                                                                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Экземпляры бинов с областью видимости в рамках сессии сохраняются в течение всей HTTP-сессии                                                     | Время жизни таких бинов дольше, чем у бинов с областью видимости в рамках запроса, и они не так часто попадают в сборку мусора                                       | Данные, сохранённые в бинах с областью видимости в рамках сессии, приложение помнит дольше                                                                                                                                                                                                                                                                                                                                       | Не стоит хранить в сессии слишком много данных — это может привести к проблемам с производительностью. И тем более не следует помещать в атрибуты бинов с областью видимости в рамках сессии конфиденциальную информацию, такую как пароли, частные ключи и др. |
| Один экземпляр бина с областью видимости в рамках сессии может быть доступен нескольким запросам                                                 | Если один и тот же клиент сделает несколько конкурентных запросов, изменяющих данные в таком экземпляре, возможны проблемы многопоточности, например состояние гонки | Возможно, чтобы избежать конкурентности, стоит воспользоваться механизмами синхронизации. Но обычно рекомендуют подумать, можно ли не допускать появления такой проблемы и оставить синхронизацию на самый крайний случай                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                 |
| Бины с областью видимости в рамках сессии — это способ сделать данные доступными для нескольких запросов, сохраняя эти данные на стороне сервера | Реализуемая вами логика может потребовать запросов, зависящих друг от друга                                                                                          | Когда данные о состоянии хранятся в памяти приложения, клиенты становятся зависимыми от этого конкретного объекта приложения. Принимая решение о реализации какого-либо функционала посредством бина с областью видимости в рамках сессии, рассмотрите другие варианты хранения данных, которые вы хотите сделать общедоступными, например, не в сессии, а в базе данных, чтобы HTTP-запросы остались независимыми друг от друга |                                                                                                                                                                                                                                                                 |

Продолжим создавать бин с областью видимости в рамках сессии, чтобы приложение помнило о вошедшем пользователе и признавало его аутентифицированным на разных страницах.

Внесём изменения в код приложения и добавим в него страницу, которая открывается только для аутентифицированных пользователей. После того как пользователь аутентифицируется, приложение перенаправляет его на эту страницу. На ней будет выводиться приветствие с указанием имени пользователя и предложение выйти из приложения, перейдя по ссылке.

Для реализации этих изменений нужно выполнить следующие действия.
1. Создать бин с областью видимости в рамках сессии, чтобы хранить в нём данные об аутентифицированном пользователе.
2. Создать страницу, на которую пользователь может попасть только после аутентификации.
3. Проследить, чтобы пользователь не мог открыть страницу, созданную в пункте 2, предварительно не аутентифицировавшись.
4. После успешной аутентификации перенаправлять пользователя со страницы с формой на главную страницу.
![spring_10.9](/pictures/spring_10.9.png)

К счастью, в Spring, чтобы создать бин с областью видимости в рамках сессии, достаточно добавить к классу бина аннотацию `@SessionScope`. Создадим новый класс `LoggedUserManagementService` с областью видимости в рамках сессии, как показано в следующем листинге.
```java
@Service
@SessionScope
public class LoggedUserManagementService { 

	private String username; 
	
	// геттеры и сеттеры
}
```

После каждой успешной аутентификации имя пользователя сохраняется в атрибуте бина `username`. Бин `LoggedUserManagementService` автомонтируется к классу `LoginProcessor`, отвечающему за логику аутентификации, как показано в следующем листинге.
```java
@Component
@RequestScope
public class LoginProcessor { 

	private final LoggedUserManagementService loggedUserManagementService;
	 
	private String username; 
	private String password; 
	
	public LoginProcessor(LoggedUserManagementService loggedUserManagementService) { 
		this.loggedUserManagementService = loggedUserManagementService; 
	} 
	
	public boolean login() {
		String username = this.getUsername(); 
		String password = this.getPassword(); 
		
		boolean loginResult = false; 
		if ("natalie".equals(username) && "password".equals(password)) {
			loginResult = true; 
			loggedUserManagementService.setUsername(username); 
		} 
		return loginResult; 
	} 
	
	// геттеры и сеттеры
}
```

Обратите внимание: бин `LoginProcessor` по-прежнему имеет область видимости в рамках запроса. Spring продолжает создавать для нового запроса свой экземпляр этого бина. Просто теперь для выполнения логики аутентификации каждый раз нужно получать значения атрибутов `username` и `password`.

Поскольку бин `LoggedUserManagementService` имеет область видимости в рамках сессии, значение его атрибута `username` доступно на протяжении всей HTTP-сессии. Мы можем использовать это значение, чтобы определить, есть ли на сайте сейчас аутентифицированные пользователи и кто именно. Нам не приходится беспокоиться о том, что пользователей может быть несколько: фреймворк приложения обеспечит соединение каждого HTTP-запроса с соответствующей сессией. Процедура аутентификации наглядно показана ниже.
![spring_10.10](/pictures/spring_10.10.png)

Теперь создадим новую страницу и проследим, чтобы она была доступна только для аутентифицированных пользователей. Для этой страницы мы разработаем новый контроллер (который назовем `MainController`), где определим действие и свяжем его с путём `/main`. Чтобы пользователь получал доступ к странице, расположенной по этому пути, только после успешной аутентификации, мы будем проверять, хранится ли в `LoggedUserManagementService` имя пользователя, и, если нет, будем перенаправлять пользователя на страницу аутентификации. Для реализации этого функционала действие контроллера должно возвращать строку `redirect`: и путь, по которому это действие перенаправляет пользователя. Логика вывода главной страницы наглядно представлена ниже.
![spring_10.11](/pictures/spring_10.11.png)

Класс `MainController` представлен ниже.
```java
@Controller
public class MainController { 

	private final LoggedUserManagementService loggedUserManagementService; 
	
	public MainController(LoggedUserManagementService loggedUserManagementService) { 
		this.loggedUserManagementService = loggedUserManagementService; 
	}
	
	@GetMapping("/main") 
	public String home() { 
		String username = loggedUserManagementService.getUsername(); 
		if (username == null) { 
			return "redirect:/"; 
		} 
		return "main.html"; 
	}
}
```

Теперь нужно создать в папке *resources/templates* проекта Spring Boot файл *main.html*, определяющий представление главной страницы. Её содержимое показано ниже.
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Welcome</title>
</head>
<body>
	<h1>Welcome</h1>
</body>
</html>
```

Дать пользователю возможность выйти из приложения также легко. Для этого нужно просто присвоить атрибуту `username` бина сессии `LoggedUserManagementService` значение `null`. Создадим на странице ссылку для выхода из приложения, а также добавим имя аутентифицированного пользователя в сообщение приветствия. Соответствующие изменения в файле *main.html*, описывающем представление, показаны ниже.
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head> 
	<meta charset="UTF-8"> 
	<title>Login</title>
</head><
body> 
	<h1>Welcome, <span th:text="${username}"></span></h1> 
	<a href="/main?Logout">Log out</a>
</body>
</html>
```

Чтобы нужный нам функционал заработал, потребуется кое-что изменить не только на странице *main.html*, но и в контроллере. Ниже показано, как действие контроллера получает параметр запроса о выходе из приложения и передаёт в представление имя пользователя, где оно будет выведено на веб-странице.
```java
@Controller
public class MainController { 

	// Остальной код 
	
	@GetMapping("/main") 
	public String home(@RequestParam(required = false) String Logout, Model model) { 
		if (Logout != null) { 
			loggedUserManagementService.setUsername(null); 
		} 
		
		String username = loggedUserManagementService.getUsername(); 
		
		if (username == null) { 
			return "redirect:/"; 
		} 
		
		model.addAttribute("username" , username); 
		return "main.html"; 
	}
}
```

И в завершение работы над приложением внесем коррективы в `LoginController`, чтобы перенаправлять пользователей на главную страницу после аутентификации. Для этого нам нужно изменить действие `LoginController`, как показано ниже.
```java
@Controller 
public class LoginController { 

	// Остальной код 
	
	@PostMapping("/") 
	public String loginPost(@RequestParam String username, 
		@RequestParam String password, 
		Model model) {
		loginProcessor.setUsername(username); 
		loginProcessor.setPassword(password); 
		boolean loggedIn = loginProcessor.login(); 
		
		if (loggedIn) { 
			return "redirect:/main"; 
		} 
		
		model.addAttribute("message", "Login failed!"); 
		return "login.html";
	}
}
```

Теперь можно запустить приложение и проверить, как работает аутентификация. Если ввести правильные учетные данные, приложение перенаправит вас на главную страницу. Если щёлкнуть на ссылке `Log out`, приложение вернёт на страницу аутентификации. Если попытаться открыть главную страницу без аутентификации, приложение отправит вас на страницу с формой входа.
![spring_10.12](/pictures/spring_10.12.png)
# Использование области видимости в рамках всего веб-приложения
**Бин с областью видимости в рамках приложения** доступен для всех запросов от всех клиентов. Он похож на одиночный бин. Различие состоит в том, что в данном случае нельзя создать в контексте несколько экземпляров. Кроме того, когда мы говорим о жизненном цикле бинов с областью видимости в веб-приложениях (включая область видимости в рамках всего веб-приложения), отправной точкой всегда являются HTTP-запросы. В случае бинов с областью видимости в рамках приложения возникают те же проблемы конкурентности, что и для одиночных бинов. Желательно, чтобы атрибуты одиночных бинов были неизменяемыми. Тот же совет касается и бинов с областью видимости в рамках приложения. Но если сделать атрибуты неизменяемыми, вместо бина с областью видимости в рамках приложения можно просто использовать одиночный бин.
![spring_10.13](/pictures/spring_10.13.png)

Обычно рекомендуется разработчикам по возможности не применять бины с областью видимости в рамках приложения. Лучше напрямую использовать уровень хранения данных, например базу данных.

Для лучшего понимания чего-либо всегда лучше рассмотреть это на примере. Дополним приложение, с которым мы работали в данной главе, счётчиком попыток аутентификации.

Поскольку нам нужно подсчитать все попытки аутентификации от всех пользователей, мы будем хранить счётчик в бине с областью видимости в рамках приложения. Создадим такой бин `LoginCountService` и разместим счётчик в его атрибуте. Определение этого класса показано ниже.
```java
@Service
@ApplicationScope
public class LoginCountService { 

	private int count; 
	
	public void increment() { 
		count++; 
	} 
	
	public int getCount() { 
		return count; 
	}
}
```

Этот бин может автомонтироваться в бин `LoginProcessor`, который может вызывать метод `increment()` при каждой попытке аутентификации, как показано ниже.
```java
@Component
@RequestScope
public class LoginProcessor { 

	private final LoggedUserManagementService loggedUserManagementService;
	private final LoginCountService loginCountService; 
	
	private String username;
	private String password; 
	
	public LoginProcessor(LoggedUserManagementService loggedUserManagementService, 
		LoginCountService loginCountService) { 
		this.loggedUserManagementService = loggedUserManagementService; 
		this.loginCountService = loginCountService; 
	} 
	
	public boolean login() { 
		loginCountService.increment(); 
		
		String username = this.getUsername(); 
		String password = this.getPassword(); 
		
		boolean loginResult = false; 
		if ("natalie".equals(username) && "password".equals(password)) { 
			loginResult = true; 
			loggedUserManagementService.setUsername(username); 
		}
		
		return loginResult; 
	} 
	
	// Остальной код
}
```

Наконец, нам осталось последнее: вывести это значение на экран. Как вы уже знаете из рассмотренных ранее примеров, чтобы передать в представление значение счетчика, нужно использовать параметр `Model` в действии контроллера. Затем можно вывести это значение в представлении с помощью Thymeleaf. Ниже показано, как отправить значение из контроллера в представление.
```java
@Controller
public class MainController { 

	// Остальной код 
	
	@GetMapping("/main") 
	public String home(@RequestParam(required = false) String Logout, Model model) { 
		if (Logout != null) { 
			loggedUserManagementService.setUsername(null); 
		} 
		
		String username = loggedUserManagementService.getUsername(); 
		int count = loginCountService.getCount(); 
		
		if (username == null) { 
			return "redirect:/"; 
		} 
		
		model.addAttribute("username" , username); 
		model.addAttribute("loginCount", count); 
		
		return "main.html"; 
	}
}
```

Ниже показано, как вывести значение счетчика на странице.
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Login</title>
</head>
<body>
	<h1>Welcome, <span th:text="${username}"></span>!</h1>
	<h2>
		Your login number is
		<span th:text="${loginCount}"></span>
	</h2>
	<a href="/main?Logout">Log out</a>
</body>
</html>
```

При запуске приложения вы обнаружите, что на главной странице появилась запись с общим количеством попыток аутентификации.
![spring_10.14](/pictures/spring_10.14.png)
Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 8.
# Создание веб-приложений с динамическими представлениями
Предположим, нам нужно создать страницу корзины для интернет-магазина. Эта страница не может показывать одну и ту же информацию всем покупателям. И даже один и тот же посетитель не будет видеть там одно и то же. На странице должны каждый раз выводиться только товары, которые данный пользователь добавил в корзину в этот раз. Ниже показан пример **динамического представления** — это корзина покупок на сайте Manning. Посмотрите, как по запросу к `Manning.com/cart` каждый раз выводятся разные данные: страница одна и та же, а информация на ней всякий раз другая. Все дело в том, что у неё динамическое содержимое!
![spring_9.1](/pictures/spring_9.1.png)

Далее мы создадим веб-приложение с динамическим представлением. Большинство современных приложений предоставляют пользователю динамические данные. В этом случае, получив запрос пользователя, выраженный в форме переданного браузером HTTP-запроса, веб-приложение получает некие данные, обрабатывает их и возвращает HTTP-ответ, который браузер выводит на экран.
![spring_9.2](/pictures/spring_9.2.png)

Процесс обработки запросов Spring MVC выглядит следующим образом:
1. Клиент отправляет на сервер HTTP-запрос.
2. Диспетчер сервлетов с помощью карты обработчиков находит нужный контроллер и действие, которое необходимо выполнить.
3. Диспетчер вызывает это действие.
4. После того как действие будет выполнено, контроллер возвращает имя представления, которое диспетчер сервлетов должен преобразовать в HTTP-ответ.
5. HTTP-ответ возвращается клиенту.
![spring_9.3](/pictures/spring_9.3.png)

Здесь нужно внести изменения в пункт 4. Мы хотим, чтобы контроллер не только возвращал имя представления, но и каким-то образом передавал в представление данные для их вставки в HTTP-ответ. Таким образом, если сервер предоставит список с одним товаром, на странице, отображающей данный перечень, будет выведена только эта позиция. Но если потом контроллер передаст для этого же представления два товара, данные на экране изменятся — количество продуктов в корзине удвоится.

Предположим, мы хотим передать имя и выделить его определённым цветом. На практике часто приходится отображать на странице имя пользователя. Как это сделать? Как получить данные, которые могут различаться для разных запросов, и вывести их?

Создадим проект Spring Boot и добавим шаблонизатор в раздел зависимостей файла *pom.xml*. Мы будем использовать шаблонизатор, который называется Thymeleaf, — это зависимость, позволяющая легко передавать данные из контроллера в представление и выводить их определённым образом. Шаблоны Thymeleaf — это просто статические HTML-файлы. В следующем фрагменте кода показано, какую зависимость нужно добавить в pom.xml:
```xml
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency><dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

Ниже представлено определение контроллера. Метод, связывающий действие с путём запроса, сопровождается аннотацией `@RequestMapping`. Теперь мы определим для этого метода параметр типа `Model`, где хранятся данные, которые контроллер будет передавать в представление. В экземпляр `Model` мы добавим значения, которые также должны отправиться в представление. Каждое из них будет иметь уникальное имя (ещё называемое **ключом**). Чтобы добавить новое значение, которое контроллер будет передавать в представление, мы будем вызывать метод `addAttribute()`. Первым параметром метода `addAttribute()` является ключ, вторым — значение для представления.
```java
@Controller
public class MainController { 

	@RequestMapping("/home") 
	public String home(Model page) { 
		page.addAttribute("username", "Katy"); 
		page.addAttribute("color", "red"); 
		return "home.html"; 
	}
}
```

Чтобы определить представление, нужно поместить в папку *resources/templates* проекта Spring Boot файл *home.html*. Обратите внимание на небольшое различие: ранее мы отправили HTML-файл в папку *resources/static*, так как создавали статическое представление. Теперь, поскольку мы используем шаблонизатор и работаем над динамическим представлением, нам нужно разместить HTML-файл в папке *resources/templates*.

Содержимое файла *home.html* представлено ниже. Первый важный момент, на который нужно обратить внимание, — это тег `<html>`, с которого начинается содержимое файла и в который добавлен атрибут `xmlns:th="http://www.thymeleaf.org"`. Данное определение эквивалентно импорту в Java. Впоследствии оно позволит нам обозначать префиксом `th` все специальные свойства представления, полученные благодаря Thymeleaf. Немного дальше вам встретится два фрагмента, где отмечены префиксом `th` данные, передаваемые в приложение контроллером. Используя синтаксис `${attribute_key}`, можно обозначить любые атрибуты, отправленные из контроллера через экземпляр `Model`. Например, используется конструкцию `${username}`, чтобы получить значение атрибута `username`, и `${color}` — для атрибута `color`.
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"> 

	<head> 
		<meta charset="UTF-8"> 
		<title>Home Page</title> 
	</head> 
	
	<body> 
		<h1>Welcome 
		<span th:style="'color:' + ${color}" 
		th:text="${username}"></span>!</h1> 
	</body>

</html>
```

Чтобы убедиться, что всё это работает, запустим приложение и откроем веб-страницу в браузере. Она будет выглядеть примерно так, как на рисунке ниже.
![spring_9.4](/pictures/spring_9.4.png)

Теперь в представлении используются все данные, передаваемые контроллером.
## Получение данных из HTTP-запроса
Обсудим, как клиент передаёт данные серверу посредством HTTP-запросов. В приложениях часто клиенту нужна такая возможность. Полученные сервером данные обрабатываются и затем выводятся в представлении. Вот несколько сценариев использования, где клиенту необходимо передавать данные серверу:
- реализация заказов в интернет-магазине: клиент должен передать на сервер список товаров, заказанных пользователем. Затем сервер обрабатывает заказ;
- веб-форум, на котором пользователи могут создавать и редактировать посты: клиент передаёт на сервер сведения о посте. Сервер сохраняет эту информацию в базе данных или изменяет уже имеющуюся там;
- регистрация в приложении. Пользователи вводят свои учетные данные, которые затем нужно валидировать. Клиент передаёт информацию на сервер, а сервер её верифицирует;
- страница контактных данных, где размещена форма, в которой пользователь может написать тему и текст сообщения, а затем отослать его по определенному адресу электронной почты. Клиент передает эти значения на сервер, сервер обрабатывает их и отправляет электронное письмо по заданному пути.

В большинстве случаев данные передаются посредством HTTP-запроса одним из следующих способов:
- **в виде параметра HTTP-запроса** — это простой способ передачи значений от клиента к серверу в формате пары «ключ — значение». Параметры добавляются в URI как выражения запроса. Поэтому их также называют **параметрами запроса**. Этот метод следует использовать только для передачи небольших объемов данных;
- **в виде параметров заголовка HTTP-запроса**. Как и параметры запроса, параметры заголовка передаются в заголовке HTTP-запроса. Главное различие между ними — **параметры заголовка не попадают в URI**. Этот способ также не подходит для больших объёмов данных;
- **переменная пути передаёт данные через сам путь запроса**. Как и в случаях выше, переменные пути используются для небольших объёмов данных. Но данный вариант передачи следует применять, если данные являются обязательными;
- **в теле HTTP-запроса**. Этот метод обычно применяется в случаях, когда нужно передать много данных (строки, но иногда и двоичные данные, такие как файлы).
## Передача данных от клиента к серверу посредством параметров запроса
Ниже мы выполним пример, демонстрирующий использование параметров HTTP-запроса — простой способ передачи данных от клиента бэкенду. Этот приём часто встречается в реальных приложениях. Параметры запроса применяют в следующих случаях:
- **объём данных не очень велик**. Параметры запроса задаются посредством переменных запроса (как будет показано далее). Этот метод позволяет отправить максимум около 2000 символов;
- **нужно передать необязательные данные**. Параметры запроса — простой способ выслать значения, которые клиент не обязан передавать. Сервер будет готов не получить значения определённых параметров запроса.

Типичный случай использования параметров запроса — определение критериев поиска и фильтрации. Предположим, приложение выводит товары и их свойства в виде таблицы. У каждого есть наименование, цена и бренд. Мы хотим, чтобы пользователь мог найти товар по любому из этих критериев: цене, наименованию, бренду или по сочетанию данных характеристик. Здесь было бы правильно использовать параметры запроса. Приложение отправляет значения (наименование, цену, бренд) в виде необязательных параметров. Клиенту нужно передать только те из них, по которым пользователь решил выполнить поиск.
![spring_9.5](/pictures/spring_9.5.png)

Модифицируем пример, рассмотренный в начале, использовав параметры запроса для передачи цвета, которым выводится имя, полученное от клиента. Ниже показано, что нужно сделать с классом контроллера, чтобы можно было получить значение цвета, переданное клиентом в качестве параметра запроса. Чтобы извлечь значение из параметра запроса, нужно добавить в метод действия контроллера ещё один параметр и снабдить его аннотацией **`@RequestParam`**. Она сообщает Spring, что нужно извлечь значение из параметра HTTP-запроса, причём имя этого параметра совпадает с именем параметра метода.
```java
@Controller
public class MainController { 

	@RequestMapping("/home") 
	public String home(@RequestParam String color, Model page) { 
		page.addAttribute("username", "Katy"); 
		page.addAttribute("color", color); 
		return "home.html"; 
	}
}
```

Ниже показано, как значение параметра `color` передаётся от клиента в действие контроллера в бэкенде, чтобы затем быть использованным в представлении.
![spring_9.6](/pictures/spring_9.6.png)

Теперь запустим приложение и введём в браузере путь `/home`. Чтобы присвоить значение параметру запроса, используем следующий синтаксис:
```
http://localhost:8080/home?color=blue
```

Дабы присвоить значения параметрам HTTP-запроса, нужно поставить в конце пути вопросительный знак (**`?`**), после которого перечислить параметры пар в виде «ключ — значение», разделенных символом **`&`**. Например, для передачи имени в качестве параметра запроса напишем следующее:
```
http://localhost:8080/home?color=blue&name=Jane
```

Для получения этого параметра также нужно добавить новый параметр в действие контроллера.
```java
@Controller
public class MainController { 

	@RequestMapping("/home") 
	public String home(
		@RequestParam(required = false) String name, 
		@RequestParam(required = false) String color,
		Model page) { 
		page.addAttribute("username", name); 
		page.addAttribute("color", color); 
		return "home.html"; 
	}
}
```

В группе «ключ — значение» (такой как `color=blue`) **ключ** — это имя параметра запроса, а **значение** — то, что стоит сразу после знака равенства (`=`).

Синтаксис параметров запроса наглядно представлен ниже.
![spring_9.7](/pictures/spring_9.7.png)

> По умолчанию параметр запроса является обязательным. Если клиент не передает значение для него, сервер возвращает HTTP-статус 400 Bad Request. Чтобы значение перестало быть обязательным, нужно явно прописать это в аннотации с помощью дополнительного атрибута: `@RequestParam(optional=true)`.
## Передача данных от клиента серверу с помощью переменных пути
Теперь рассмотрим передачу данных от клиента серверу с помощью переменных пути и сравним этот способ с тем, что мы изучили выше. Использование **переменных пути** — ещё один вариант отправки данных от клиента серверу. Однако, в отличие от параметров HTTP-запроса, в этом случае мы явно вставляем переменные в путь, как показано далее.

Параметры запроса:
```
http://localhost:8080/home?color=blue
```

Переменные пути:
```
http://localhost:8080/home/blue
```

Теперь не приходится указывать ключ для значения. Достаточно вставить значение в определённое место пути — и на стороне сервера оно будет извлечено из этой позиции. В пути может быть несколько значений как переменных пути, но **обычно рекомендуется использовать одно-два**. Вы сами убедитесь, что с большим количеством переменных путь становится трудно читать. Если значений больше двух, вместо переменных пути лучше использовать параметры запроса. Не следует также применять переменные пути для опциональных значений. Лучше их использовать только для обязательных параметров. Для необязательных лучше подойдут параметры запроса. В таблице приводится сравнение параметров запроса и переменных пути.

| Параметры запроса                                                                                                                             | Переменные пути                                                                                                                                                                                                                          |
| --------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. Могут использоваться для необязательных значений                                                                                           | 1. Не могут использоваться для необязательных значений                                                                                                                                                                                   |
| 1. Не рекомендуется использовать много таких параметров. Если их больше трёх, лучше поместить их в тело запроса — хотя бы для удобства чтения | 1. Не стоит передавать более трёх переменных пути. Лучше даже ограничиться максимум двумя                                                                                                                                                |
| 3. По мнению некоторых разработчиков, выражения запроса труднее читать, чем выражения пути                                                    | 3. Переменные пути легче читать, чем переменные запроса. В случае общедоступных веб-сайтов страницы с переменными пути легче индексируются поисковыми системами (такими как Google), благодаря чему веб-сайт проще найти через поисковик |

Если создаваемая вами страница зависит всего лишь от одного или двух значений, определяющих её итоговый вид, лучше вставить их непосредственно в путь, чтобы запрос было проще читать. Кроме того, подобный URL будет проще найти, если сохранить его в браузере в виде закладки и он будет легче индексироваться поисковыми системами (если это важно для вашего приложения).

Для отправки переменной пути в действие контроллера достаточно добавить в путь имя этой переменной, заключённое в фигурные скобки. Затем с помощью аннотации `@PathVariable` мы отметим параметр действия контроллера, в котором будет передаваться значение переменной пути. Ниже показано, как нужно изменить действие контроллера, чтобы получить значение цвета из переменной пути.
```java
@Controller
public class MainController { 

	@RequestMapping("/home/{color}") 
	public String home(@PathVariable String color, Model page) { 
		page.addAttribute("username", "Katy"); 
		page.addAttribute("color", color); 
		return "home.html"; 
	}
}
```

Запустим приложение и откроем в браузере страницу с разными значениями цвета:
```
http://localhost:8080/home/blue
http://localhost:8080/home/red
http://localhost:8080/home/green
```

В каждом запросе имя выводится на странице своим цветом. Ниже показано, как связаны код и путь запроса.
![spring_9.8](/pictures/spring_9.8.png)
# Использование HTTP-методов GET и POST
Далее мы рассмотрим HTTP-методы и то, как с их помощью клиент может сообщить, что именно он хочет сделать с запрошенным ресурсом (создать, изменить, получить, удалить). HTTP-запрос состоит из пути и этого действия. До сих пор мы говорили только о пути и, сами того не осознавая, использовали HTTP-метод GET. **Назначение HTTP-метода** — определить действие, которое запрашивает клиент. Например, метод GET показывает лишь желание извлечь данные. Применяя его, клиент сообщает серверу, что он хочет что-то получить, но никакие данные при этом не должны быть изменены. Однако иногда этого мало. В приложении также часто возникает потребность что-то изменять, создавать и удалять.

> Будьте внимательны! Вы можете использовать HTTP-метод не по его прямому назначению, но так делать некорректно. Например, с помощью метода GET все же можно реализовать функционал, который будет изменять данные. Технически это возможно, но это очень, очень плохое решение. Никогда не используйте HTTP-метод не по назначению.

До сих пор, чтобы обратиться к определённому методу контроллера, мы использовали путь запроса. Но в более сложных случаях **один и тот же путь может быть связан с несколькими действиями контроллера, поскольку используются разные HTTP-методы**. Рассмотрим такой вариант на примере.

HTTP-метод определяется ключевым словом, соответствующим намерению клиента. Если запрос клиента требует только получения данных, мы создаём конечную точку, используя HTTP-метод GET. Если же при этом данные на сервере как-то изменяются, для точного описания действий клиента нужно использовать другое ключевое слово.

В таблице ниже представлены основные HTTP-методы, которые применяются в приложениях и о которых вам следует знать.

| HTTP-метод | Описание                                                                          |
| ---------- | --------------------------------------------------------------------------------- |
| GET        | Клиентский запрос лишь получает данные                                            |
| POST       | Клиентский запрос передаёт новые данные, которые должны быть сохранены на сервере |
| PUT        | Клиентский запрос изменяет данные, хранящиеся на сервере                          |
| PATCH      | Клиентский запрос требует частичного изменения данных, хранящихся на сервере      |
| DELETE     | Клиентский запрос удаляет данные на сервере                                       |

Чтобы вам было проще запомнить назначение этих методов, они наглядно представлены на рисунке ниже.
![spring_9.9](/pictures/spring_9.9.png)

> Несмотря на то что хорошим тоном программирования считается различать полное (PUT) и частичное (PATCH) изменение данных, при разработке реальных приложений различия между этими HTTP-методами часто не делают.

Теперь рассмотрим пример, в котором, помимо GET, будут использоваться другие HTTP-методы. Предположим, нам нужно создать приложение, которое сохраняет список товаров. У каждого продукта есть наименование и цена. Веб-приложение выводит перечень всех товаров, и пользователь может добавить туда один или несколько продуктов посредством HTML-формы.

Обратите внимание на два сценария использования, описанные в данной задаче. Пользователю нужно дать возможность сделать следующее:
- просмотреть список всех товаров; здесь мы по-прежнему будем использовать HTTP-метод GET;
- добавить товары в список: здесь мы будем использовать HTTP-метод POST.

Создадим новый проект с зависимостями (в файле *pom.xml*) для веб-приложений и Thymeleaf:
```xml
<dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency><dependency> 
	<groupId>org.springframework.boot</groupId> 
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

В этом проекте мы создадим класс `Product`, в котором описывается товар, с атрибутами для наименования и цены. Класс `Product` — это класс модели, так что мы поместим его в пакет `model`.
```java
public class Product {

	private String name;
	private double price;
	
	// геттеры и сеттеры
}
```

Теперь, когда у нас есть способ описания товаров, создадим список, где приложение будет их сохранять. Веб-приложение будет выводить перечень продуктов, и пользователь сможет добавлять в него новые наименования. Мы реализуем два сценария использования (получение списка товаров для отображения на экране и добавление нового товара) в виде метода класса сервиса. Создадим класс сервиса `ProductService` и поместим его в пакет `service`.

Ниже представлен класс сервиса, который формирует список товаров и в котором определены два метода — для добавления нового товара и для получения списка товаров.
```java
@Service
public class ProductService {

	private List<Product> products = new ArrayList<>();
	
	public void addProduct(Product p) {
		products.add(p);
	}
	
	public List<Product> findAll() {
		return products;
	}
}
```

> Это упрощённая структура, позволяющая сосредоточиться на HTTP-методах. **По умолчанию бины Spring имеют одиночную область определения, а веб-приложение создаёт несколько потоков (по одному для каждого запроса).** В реальном приложении, когда сразу несколько клиентов будут добавлять новые товары, изменение списка, определённого как атрибут бина, приведёт к состоянию гонки. Но пока что используем этот вариант. Тем не менее вам следует помнить, что это порочная практика и не следует использовать подобный подход в реальных приложениях. При наличии потоков одиночные бины небезопасны!

Контроллер будет вызывать сценарии использования, реализованные в сервисе. Он получает от клиента данные о новом товаре и добавляет товар в список, вызывая сервис. Контроллер также получает перечень продуктов и передаёт его в представление. Прежде всего создадим класс `ProductController`, поместим его в пакет `controllers` и разрешим контроллеру внедрять бин сервиса.
```java
@Controller
public class ProductsController { 

	private final ProductService productService; 
	
	public ProductsController(ProductService productService) { 
		this.productService = productService; 
	}
}
```

Теперь мы реализуем первый сценарий использования: выведем список товаров на веб-страницу. Это простая функциональность. Для передачи данных из контроллера в представление мы воспользуемся параметром типа `Model`.
```java
@Controller
public class ProductsController { 

	private final ProductService productService; 
	
	public ProductsController(ProductService productService) { 
		this.productService = productService; 
	}

	@RequestMapping("/products") 
	public String viewProducts(Model model) { 
		var products = productService.findAll();
		model.addAttribute("products", products); 
		
		return "products.html"; 
	}
}
```

Чтобы представление выводило на экран список товаров, создадим в папке проекта *resources/templates* файл *products.html*. Содержимое *products.html*, который получает переданный контроллером список товаров и выводит его в виде HTML-таблицы, показано ниже.
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"> 
	<head> 
		<meta charset="UTF-8"> 
		<title>Home Page</title> 
	</head> 
	<body> 
		<h1>Products</h1> 
		
		<h2>View products</h2> 
		
		<table> 
			<tr> 
				<th>PRODUCT NAME</th> 
				<th>PRODUCT PRICE</th> 
			</tr> 
			<tr th:each="p: ${products}" > 
				<td th:text="${p.name}"></td> 
				<td th:text="${p.price}"></td> 
			</tr> 
		</table> 
	</body>
</html>
```

Ниже показана диаграмма Spring MVC для процесса обработки пути `/products` с HTTP-методом GET:
1. Клиент отправляет HTTP-запрос для пути `/products`.
2. Диспетчер сервлетов с помощью карты обработчиков находит действие контроллера, которое нужно вызвать для пути `/products`.
3. Диспетчер вызывает это действие.
4. Контроллер запрашивает у сервиса список товаров и передаёт его для формирования представления.
5. Представление формируется в виде HTTP-ответа.
6. HTTP-ответ передаётся клиенту.
![spring_9.10](/pictures/spring_9.10.png)

Но прежде, чем протестировать функционал приложения, мы всё ещё должны реализовать второй сценарий использования. Не имея возможности включить товар в список, мы увидим только пустую таблицу. Впишем в контроллер ещё одно действие, позволяющее добавлять товары в список.
```java
@Controller
public class ProductsController { 

	private final ProductService productService; 
	
	public ProductsController(ProductService productService) { 
		this.productService = productService; 
	}

	@RequestMapping("/products") 
	public String viewProducts(Model model) { 
		var products = productService.findAll();
		model.addAttribute("products", products); 
		
		return "products.html"; 
	}

	@RequestMapping(path = "/products", method = RequestMethod.POST)
	public String addProduct(
		@RequestParam String name, 
		@RequestParam double price, 
		Model model) { 
		Product p = new Product(); 
		p.setName(name); 
		p.setPrice(price); 
		productService.addProduct(p); 
		
		var products = productService.findAll(); 
		model.addAttribute("products", products); 
		
		return "products.html"; 
	}
}
```

Для определения HTTP-метода мы использовали атрибут аннотации `@RequestMapping`. Если не указать в ней метод, `@RequestMapping` по умолчанию использует GET. Но поскольку для любого HTTP-вызова необходимо знать и путь, и метод, лучше всегда прописывать и то и другое. Поэтому вместо `@RequestMapping` разработчики обычно используют специальные аннотации для каждого HTTP-метода. В приложениях для связи GET-запросов с действиями вам часто будут встречаться аннотации **`@GetMapping`**, для POST-запросов — **`@PostMapping`** и т. д. Мы тоже изменим наш пример, чтобы использовать специализированные аннотации.
```java
@Controller
public class ProductsController { 

	private final ProductService productService; 
	
	public ProductsController(ProductService productService) { 
		this.productService = productService; 
	}

	@GetMapping("/products") 
	public String viewProducts(Model model) { 
		var products = productService.findAll();
		model.addAttribute("products", products); 
		
		return "products.html"; 
	}

	@PostMapping(path = "/products")
	public String addProduct(
		@RequestParam String name, 
		@RequestParam double price, 
		Model model) { 
		Product p = new Product(); 
		p.setName(name); 
		p.setPrice(price); 
		productService.addProduct(p); 
		
		var products = productService.findAll(); 
		model.addAttribute("products", products); 
		
		return "products.html"; 
	}
}
```

Мы также изменим представление, чтобы пользователь мог вызывать действие контроллера для HTTP-метода POST и добавлять товары в список. Для формирования этого запроса мы создадим HTML-форму.
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"> 
	<head> 
		<meta charset="UTF-8"> 
		<title>Home Page</title>
	</head> 
	<body> 
	
	<!-- Остальной код --> 
	
	<h2>Add a product</h2> 
	<form action="/products" method="POST"> 
		Name: <input 
			type="text" 
			name="name"><br /> 
		Price: <input 
			type="number" 
			step="any" 
			name="price"><br /> 
		<button type="submit">Add product</button> 
	</form> 
	</body>
</html>
```

Теперь запустим приложение и проверим, как оно функционирует. При открытии страницы приложения по адресу `http://localhost:8080/products` у нас должна появиться возможность добавлять новые товары и просматривать список уже включённых продуктов.
![spring_9.11](/pictures/spring_9.11.png)

В примере использовалась уже знакомая аннотация `@RequestParameter`, чтобы показать, как именно клиент передаёт данные. Но иногда Spring позволяет не писать этот код. Например, можно передать параметр типа `Product` непосредственно в действие контроллера, как показано ниже. **Поскольку имена параметров запроса совпадают с именами атрибутов класса `Product`, Spring знает, какие параметры каким атрибутам соответствуют, и автоматически создаёт объект.** Для тех, кто уже хорошо знаком со Spring, это отличная новость, ведь тогда не придётся писать лишние строки кода. Но начинающие могут запутаться во всех этих деталях. Предположим, вам попадётся статья с примером, в котором используется подобный синтаксис. Вам может показаться непонятным, откуда там взялся экземпляр `Product`. Если вы, едва начав изучать Spring, окажетесь в подобной ситуации, лучше вспомнить: **синтаксис Spring построен таким образом, чтобы скрыть как можно больше кода**. Если где-то вам встретится не вполне понятная конструкция, поищите разъяснения в спецификации фреймворка.
```java
@Controller
public class ProductsController { 

	// остальной код 
	
	@PostMapping("/products") 
	public String addProduct(Product p, Model model) { 
		productService.addProduct(p); 
		
		var products = productService.findAll(); 
		model.addAttribute("products", products); 
		
		return "products.html"; 
	}
}
```
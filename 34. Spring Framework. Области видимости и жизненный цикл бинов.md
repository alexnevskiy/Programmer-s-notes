Взято из книги "Spring быстро" автора Лауренциу Спилкэ, глава 5.

В Spring предусмотрено несколько вариантов создания бинов и управления их жизненным циклом — в мире фреймворка эти способы называются **областями видимости (scopes)**.
# Использование одиночной области видимости
**Одиночная область видимости бина (одиночка)** — вариант, выбираемый Spring по умолчанию для управления бинами в контексте. Именно она будет встречаться чаще всего в реальных приложениях.
## Что такое одиночный бин
Spring создаёт одиночные бины при загрузке контекста и присваивает им имена (иначе, ID бина). **Эта область видимости называется одиночной, поскольку при обращении к конкретному бину мы всегда получаем один и тот же экземпляр.** В контексте Spring может существовать несколько экземпляров одного типа, но с разными именами.

Однако если синглтон как шаблон проектирования вам всё же знаком, одиночная область видимости бинов в Spring может показаться вам странной, ведь одиночный шаблон предполагает наличие единственного экземпляра данного типа в приложении. **В Spring таких экземпляров может быть несколько, а само понятие «одиночный» означает уникальность имени, но не уникальность наличия в пределах приложения.**
![spring_5.1](/pictures/spring_5.1.png)
*Говоря об одиночном классе в приложении, мы имеем в виду, что есть только один экземпляр в классе и класс управляет созданием этого экземпляра. Но в Spring одиночная область видимости не означает, что в контексте есть только один экземпляр данного типа. Это значит лишь, что **конкретному экземпляру присвоено имя и при обращении по этому имени всегда будет возвращаться один и тот же экземпляр**.*

### Объявление бинов с одиночной областью видимости с помощью аннотации `@Bean`
Рассмотрим поведение бина с одиночной областью видимости на примере. Мы добавим экземпляр в контекст Spring с помощью аннотации `@Bean`, а затем просто обратимся к нему несколько раз из класса `Main`. Таким образом мы докажем, что при каждой отсылке к бину мы всегда получаем один и тот же экземпляр.

Ниже визуально представлена связь между контекстом и кодом, определяющим конфигурацию этого контекста. Кофейное зерно на рисунке олицетворяет экземпляр, который Spring добавляет в контекст. Обратите внимание, что **в контексте есть только один экземпляр (одно кофейное зерно) с присвоенным именем**. При добавлении бина в контекст с помощью аннотации `@Bean` именем бина становится имя метода, сопровождаемого данной аннотацией.
![spring_5.2](/pictures/spring_5.2.png)

Нам нужно определить пустой класс `CommentService`, как показано в следующем фрагменте кода, а затем написать класс конфигурации и класс `Main`.
```java
public class CommentService {
}
```

Ниже представлено определение класса конфигурации, в котором для добавления экземпляра типа `CommentService` в контекст Spring использован метод с аннотацией `@Bean`.
```java
@Configuration
public class ProjectConfig {

	@Bean
	public CommentService commentService() {
		return new CommentService();
	}
}
```

Ниже представлен класс `Main`, с помощью которого мы тестируем поведение Spring в случае одиночного бина. Мы дважды получаем ссылку на бин `CommentService` и рассчитываем, что каждый раз ссылка будет одна и та же.
```java
public class Main {

	public static void main(String[] args) { 
		var c = new AnnotationConfigApplicationContext(ProjectConfig.class); 
		
		var cs1 = c.getBean("commentService", CommentService.class); 
		var cs2 = c.getBean("commentService", CommentService.class); 
		
		boolean b1 = cs1 == cs2; 
		
		System.out.println(b1); 
	}
}
```

При запуске приложения в консоль будет выведено `true`, поскольку Spring, имея дело с одиночным бином, всегда возвращает одну и ту же ссылку.
### Создание одиночных бинов с помощью стереотипных аннотаций
Рассмотрим структуру классов, в которой два класса сервисов зависят от одного и того же репозитория. Предположим, что классы `CommentService` и `UserService` зависят от репозитория `CommentRepository`.
![spring_5.3](/pictures/spring_5.3.png)

Не имеет значения, почему эти классы зависят друг от друга. Наши сервисы ничего не делают (это просто сценарий). Предположим, что данная структура является частью более сложного приложения, и обратим внимание на связи между бинами и на то, каким образом Spring устанавливает связи в контексте. Ниже представлена визуализация контекста параллельно с кодом, в котором содержится его конфигурация.
![spring_5.4](/pictures/spring_5.4.png)

Убедимся, что поведение Spring именно таково, каким мы его ожидаем увидеть. Для этого создадим три класса, сравним ссылки, которые Spring будет внедрять в бины сервисов, — и увидим, что ссылка выдается одна и та же.
```java
@Repository
public class CommentRepository {
}
```

В следующем фрагменте кода представлено определение класса `CommentService`.
```java
@Service
public class CommentService {

	@Autowired
	private CommentRepository commentRepository;
	
	public CommentRepository getCommentRepository() {
		return commentRepository;
	}
}
```

Следуя той же логике, что и в случае с `CommentService`, определим класс `UserService`:
```java
@Service
public class UserService {

	@Autowired
	private CommentRepository commentRepository;
	
	public CommentRepository getCommentRepository() {
		return commentRepository;
	}
}
```

В отличие от первого примера, в этом проекте класс конфигурации пуст. Нам нужно только сообщить Spring, где находятся классы со стереотипными аннотациями.
```java
@Configuration
@ComponentScan(basePackages = {"services", "repositories"})
public class ProjectConfig {
}
```

В классе `Main` мы получаем ссылки на два сервиса и сравниваем их зависимости, чтобы убедиться, что Spring внедрил в оба сервиса один и тот же экземпляр.
```java
public class Main {

	public static void main(String[] args) { 
		var c = new AnnotationConfigApplicationContext( ProjectConfig.class); 
		
		var s1 = c.getBean(CommentService.class); 
		var s2 = c.getBean(UserService.class); 
		
		boolean b = s1.getCommentRepository() == s2.getCommentRepository();
		
		System.out.println(b); 
	}
}
```
## Одиночные бины в реальных приложениях
Поскольку область видимости одиночного бина предполагает, что доступ к экземпляру объекта имеют несколько компонентов приложения, главное, что следует учитывать, — эти **бины должны быть неизменяемыми**. Как правило, в реальных приложениях (таких как веб-приложения) операции выполняются в нескольких потоках. Следовательно, разные потоки могут иметь доступ к одному экземпляру объекта. Если эти потоки изменят экземпляр, то попадут в **состояние гонки**.
![spring_5.5](/pictures/spring_5.5.png)

**Состояние гонки** — это ситуация, которая возникает в многопоточных архитектурах, когда несколько потоков пытаются изменить общедоступный ресурс. При появлении данной проблемы разработчику следует тщательно синхронизировать потоки во избежание ошибок или неожиданных результатов выполнения приложения.

Если вам нужны изменяемые одиночные бины (атрибуты которых можно модифицировать), необходимо сделать их согласованными (для этого обычно используют синхронизацию потоков). Но одиночные бины не рассчитаны на то, чтобы быть конкурентными. Они, как правило, **используются для определения базовой структуры классов и делегирования обязанностей между собой**. Технически синхронизация одиночных бинов возможна, но это не является хорошим тоном в программировании. Синхронизация потоков для конкурентности экземпляра резко снижает производительность приложения. К счастью, есть другие способы решить эту проблему.

Хорошим тоном в программировании является скорее использование конструктора DI, нежели внедрение в поле. Одним из преимуществ внедрения в конструктор является возможность сделать экземпляры неизменяемыми (пометив поля бина как `final`). В предыдущем примере можно улучшить определение класса `CommentService`, заменив внедрение в поле внедрением в конструктор следующим образом:
```java
@Service
public class CommentService { 

	private final CommentRepository commentRepository; 
	
	public CommentService(CommentRepository commentRepository) { 
		this.commentRepository = commentRepository; 
	} 
	
	public CommentRepository getCommentRepository() { 
		return commentRepository; 
	}
}
```

### Три главных правила использования бинов
- **Размещайте объект в контексте Spring в виде бина только в том случае, если необходимо, чтобы Spring управлял этим объектом и мог расширить его возможности за счёт своего функционала.** Если объект не нуждается в возможностях, предоставляемых фреймворком, то не следует делать его бином.
- **Если нужно сделать объект бином и разместить его в контексте Spring, то бин должен быть одиночным только в случае, если он неизменяемый.** Постарайтесь не создавать изменяемые одиночные бины.
- **Если бин всё же должен быть изменяемым, лучше использовать прототипную область видимости.**
## Немедленное и "ленивое" создание экземпляров
Как правило, **Spring создаёт одиночные бины при инициализации контекста** — таково поведение фреймворка по умолчанию (его также называют **немедленным созданием экземпляров**). Данный способ мы использовали до сих пор. Далее мы рассмотрим другой предусмотренный фреймворком вариант, **«ленивое» создание экземпляров**, и сравним его с первой возможностью. **В «ленивом» случае Spring не создает одиночных бинов при запуске контекста. Вместо этого каждый экземпляр создаётся в момент, когда происходит первое обращение к данному бину.**

Чтобы протестировать вариант по умолчанию (немедленный), в исходном сценарии нам нужен только один бин. Класс будет по-прежнему называться CommentService. На его основе создаём бин, используя либо аннотацию @Bean (как показано в следующем фрагменте кода), либо стереотипную аннотацию. Но в любом случае обязательно нужно добавить в конструкторе класса вывод в консоль. Таким образом, если фреймворк вызовет конструктор класса, мы сразу же это увидим:
```java
@Service
public class CommentService {

	public CommentService() {
		System.out.println("CommentService instance created!");
	}
}
```

Класс конфигурации выглядит так:
```java
@Configuration
@ComponentScan(basePackages = {"services"})
public class ProjectConfig {
}
```

В классе `Main` мы только создаём экземпляр контекста Spring. Обратите внимание на то, что никакой объект не использует бин `CommentService`, однако Spring всё равно создаст данный экземпляр и сохранит его в контексте. Мы узнаем об этом при запуске приложения, поскольку увидим в консоли вывод, генерируемый конструктором `CommentService`. Класс `Main` представлен в следующем фрагменте кода:
```java
public class Main { 

	public static void main(String[] args) { 
		var c = new AnnotationConfigApplicationContext(ProjectConfig.class); 
	}
}
```

Несмотря на то что бин нигде не используется, при запуске приложения вы увидите в консоли следующий текст:
```
CommentService instance created!
```

Теперь внесём изменения в наш пример, добавив аннотацию `@Lazy` перед классом (в случае стереотипных аннотаций) или перед методом с `@Bean` (в случае использования метода с аннотацией `@Bean`). Запустив приложение, вы увидите, что сообщение о создании бина в консоли больше не появляется. При заданной конфигурации Spring будет создавать бин, только если он будет использоваться, а в нашем примере бин `CommentService` не используется.
```java
@Service
@Lazy
public class CommentService { 

	public CommentService() { 
		System.out.println("CommentService instance created!"); 
	}
}
```

Теперь изменим класс `Main` — добавим туда ссылку на бин `CommentService`:
```java
public class Main {

	public static void main(String[] args) { 
		var c = new AnnotationConfigApplicationContext(ProjectConfig.class); 

		System.out.println("Before retrieving the CommentService"); 
		var service = c.getBean(CommentService.class); 
		System.out.println("After retrieving the CommentService"); 
	}
}
```

Теперь, запустив приложение, мы снова увидим текст в консоли. Фреймворк создаёт бин только тогда, когда он нужен:
```
Before retrieving the CommentService
CommentService instance created!
After retrieving the CommentService
```

Когда предпочтительнее использовать немедленный, а когда — «ленивый» вариант работы? Как правило, **удобнее всего создать все экземпляры в самом начале, одновременно с контекстом (немедленно)**; в этом случае, если один экземпляр делегирует функции другому, второй бин гарантированно уже будет существовать. **При «ленивом» же создании бина фреймворк должен сначала проверить, существует ли данный экземпляр, и, если нет, создать его.**

Таким образом, **с точки зрения производительности лучше заранее создать все экземпляры, которые должны находиться в контексте (немедленно), иначе при делегировании функций от одного бина другому фреймворк должен будет сделать ещё несколько дополнительных проверок**. К тому же, **если что-либо пойдёт не так и фреймворк не сможет создать бин, вы сразу это заметите при запуске приложения**. При «ленивом» варианте проблема может быть обнаружена только в уже работающем приложении, когда возникнет необходимость в создании конкретного бина.

Однако «ленивое» создание экземпляров не всегда зло. Например, у нас есть монолитное приложение. Оно устанавливалось на разных устройствах, где клиенты использовали его для разных целей. Как правило, каждому пользователю нужна была лишь малая часть функционала приложения, так что создание сразу всех бинов одновременно с контекстом Spring требовало неоправданно большого объёма памяти. Поэтому большинство бинов приложения разработчики сделали «ленивыми», чтобы каждый раз создавались только необходимые экземпляры.

**Совет — выбирать вариант по умолчанию, то есть немедленное создание экземпляров.** Этот способ, как правило, имеет больше преимуществ. А если вдруг вы окажетесь в ситуации, подобной описанному выше случаю, сначала проверьте, нельзя ли как-либо изменить структуру приложения. Например, в истории ранее было бы лучше, если бы приложение имело модульную структуру или было представлено в виде микросервисов. Такая архитектура позволила бы разработчикам развёртывать только ту часть приложения, которая нужна конкретным клиентам, и необходимость в «ленивом» создании бинов отпала бы. Но на практике реализовать такое бывает сложно из-за ограничений по времени или стоимости. Тем не менее, если невозможно устранить настоящую причину болезни, иногда можно хотя бы избавиться от некоторых симптомов.
# Прототипная область видимости бинов
## Как работают прототипные бины
Прежде чем обсуждать, в каких практических ситуациях следует использовать прототипные бины, разберёмся, что делает Spring, чтобы ими управлять. **Каждый раз, когда запрашивается ссылка на прототипный бин, Spring создаёт новый экземпляр объекта.** В случае прототипных бинов Spring не создаёт сам объект и не управляет им. **Фреймворк управляет только типом объекта и создаёт новый экземпляр всякий раз, когда какой-либо объект запрашивает ссылку на этот бин.** Ниже изображён бин в виде кофейного дерева (чтобы получить свежие зерна, их нужно снять с дерева — подобно этому, всякий раз, когда нужен бин, требуется создать новый экземпляр). Мы будем по-прежнему употреблять термин «бин», но данная растительная аналогия поможет вам быстро понять и запомнить поведение Spring относительно прототипных бинов.
![spring_5.6](/pictures/spring_5.6.png)

Видно, что для изменения области видимости бина нам понадобится новая аннотация — `@Scope`. Она ставится вместе с `@Bean` перед методом, объявляющим бин. При объявлении бина с помощью стереотипных аннотаций `@Scope` вместе со стереотипными аннотациями ставится перед классом, в котором объявляется бин.

Применение прототипных бинов решает проблемы конкурентности, поскольку каждый поток получает свой экземпляр, так что определение нескольких прототипных бинов не создаёт проблем.
![spring_5.7](/pictures/spring_5.7.png)
### Объявление бинов с прототипной областью видимости с помощью аннотации `@Bean`
Мы создадим бин `CommentService` и объявим его прототипным, чтобы при каждом его запросе получать новый экземпляр. Класс `CommentService` выглядит так:
```java
public class CommentService {
}
```

В классе конфигурации мы определим бин класса `CommentService`.
```java
@Configuration
public class ProjectConfig {

	@Bean
	@Scope(BeanDefinition.SCOPE_PROTOTYPE) // Объявляем этот бин прототипным
	public CommentService commentService() {
		return new CommentService();
	}
}
```

Чтобы убедиться, что при каждом запросе мы получаем новый экземпляр, создадим класс `Main` и дважды запросим этот бин из контекста. Мы увидим, что ссылки будут разными.
```java
public class Main { 

	public static void main(String[] args) { 
		var c = new AnnotationConfigApplicationContext(ProjectConfig.class); 

		var cs1 = c.getBean("commentService", CommentService.class); 
		var cs2 = c.getBean("commentService", CommentService.class); 

		boolean b1 = cs1 == cs2; 

		System.out.println(b1); 
	}
}
```

Запустив приложение, вы увидите, что в консоли всегда выводится `false`. Этот результат подтверждает, что при вызове метода `getBean()` возвращаются два разных экземпляра.
### Объявление бинов с прототипной областью видимости посредством стереотипных аннотаций
Мы определим прототипный бин `CommentRepository` и внедрим его в два других, сервисных бина посредством аннотации `@Autowired`.
![spring_5.8](/pictures/spring_5.8.png)

В следующем фрагменте кода показано определение класса `CommentRepository`.
```java
@Repository
@Scope(BeanDefinition.SCOPE_PROTOTYPE)
public class CommentRepository {
}
```

Два класса сервисов запрашивают экземпляр типа `CommentRepository` посредством аннотации `@Autowired`. Класс `CommentService` выглядит так:
```java
@Service
public class CommentService {

	@Autowired
	private CommentRepository commentRepository;
	
	public CommentRepository getCommentRepository() {
		return commentRepository;
	}
}
```

В этом фрагменте кода класс `UserService` также запрашивает экземпляр бина `CommentRepository`.
```java
@Service
public class UserService {

	@Autowired
	private CommentRepository commentRepository;
	
	public CommentRepository getCommentRepository() {
		return commentRepository;
	}
}
```

Чтобы сообщить Spring, где находятся классы со стереотипными аннотациями, в классе конфигурации нужно использовать аннотацию `@ComponentScan`:
```java
@Configuration
@ComponentScan(basePackages = {"services", "repositories"})
public class ProjectConfig {
}
```

Теперь добавим в проект класс `Main` и проверим, как Spring будет внедрять бин `CommentRepository`.
```java
public class Main { 

	public static void main(String[] args) { 
		var c = new AnnotationConfigApplicationContext(ProjectConfig.class); 

		var s1 = c.getBean(CommentService.class); 
		var s2 = c.getBean(UserService.class); 

		boolean b = s1.getCommentRepository() == s2.getCommentRepository(); 

		System.out.println(b); 
	}
}
```
## Практическое применение прототипных бинов
Прототипные бины будут вам встречаться не так часто, как одиночные. Но есть хорошее правило, которым можно пользоваться, решая, делать ли бин прототипным. Напомню, что одиночные бины не особенно хорошо подходят для изменяемых объектов. Предположим, что мы создаём объект `CommentProcessor`, который обрабатывает и валидирует комментарии. Некий сервис может использовать `CommentProcessor` для реализации сценария использования. Но в `CommentProcessor` в качестве атрибута хранится обрабатываемый комментарий, и методы этого объекта изменяют данный атрибут.
![spring_5.9](/pictures/spring_5.9.png)

Реализация бина `CommentProcessor` представлена ниже:
```java
public class CommentProcessor { 

	private Comment comment; 
	
	public void setComment(Comment comment) { 
		this.comment = comment; 
	} 
	
	public void getComment() { 
		return this.comment; 
	} 
	
	public void processComment() { 
		// изменение атрибута comment 
	} 
	
	public void validateComment() { 
		// валидация и изменение атрибута comment 
	}
}
```

Ниже показан сервис, в котором посредством класса `CommentProcessor` реализуется сценарий использования. В методе сервиса создаётся экземпляр `CommentProcessor` с помощью конструктора класса `CommentProcessor`, а затем полученный экземпляр применяется в логике метода.
```java
@Service
public class CommentService { 

	public void sendComment(Comment c) { 
		CommentProcessor p = new CommentProcessor();
		p.setComment(c); 
		p.processComment(c); 
		p.validateComment(c); 
		c = p.getComment(); 
		// делаем что-нибудь еще 
	}
}
```

Объект `CommentProcessor` даже не является бином, размещённым в контексте Spring. А должен ли им быть? Исключительно важно задать себе этот вопрос, прежде чем сделать какой-либо объект бином. Помните, что в этом есть смысл, только если необходимо передать объект под управление Spring, чтобы расширить его возможности за счёт функционала фреймворка. Для нашего сценария в том виде, в каком он существует сейчас, объект `CommentProcessor` не должен быть бином

Но предположим, что бин `CommentProcessor` должен использовать объект `CommentRepository` для хранения каких-то данных и `CommentRepository` является бином, размещённым в контексте Spring.
![spring_5.10](/pictures/spring_5.10.png)

В данном сценарии `CommentProcessor` должен быть бином, чтобы использовать предоставляемую Spring возможность DI. Как правило, если нужно расширить возможности объекта за счёт функционала Spring, его следует сделать бином.

Итак, мы сделаем `CommentProcessor` бином и добавим его в контекст Spring. Но должен ли этот бин быть одиночным? Нет. Если объявить его одиночным и разные потоки начнут его использовать конкурентно, наступит состояние гонки. Мы никогда не будем знать точно, какой именно комментарий, предоставленный потоком, обрабатывается в данный момент и правильно ли он был обработан. В данном сценарии нам нужно, чтобы каждый вызов метода получал свой экземпляр объекта `CommentProcessor`.

Для этого изменим класс `CommentProcessor` так, чтобы бин был прототипным, как показано в следующем фрагменте кода:
```java
@Component
@Scope(BeanDefinition.SCOPE_PROTOTYPE)
public class CommentProcessor {

	@Autowired
	private CommentRepository commentRepository;
	
	// остальной код
}
```

Теперь мы можем получить из контекста Spring экземпляр `CommentProcessor`. Но будьте внимательны! Данный экземпляр будет вам нужен при каждом вызове метода `sendComment()`, поэтому запрос бина должен находиться внутри этого метода. Чтобы получить такой результат, нужно внедрить контекст Spring (`ApplicationContext`) непосредственно в бин `CommentService`, используя аннотацию `@Autowired`. В методе `sendComment()` мы получаем экземпляр `CommentProcessor`, вызывая `getBean()` для контекста приложения.
```java
@Service
public class CommentService { 

	@Autowired 
	private ApplicationContext context; 
	
	public void sendComment(Comment c) { 
		CommentProcessor p = context.getBean(CommentProcessor.class); 

		p.setComment(c); 
		p.processComment(c); 
		p.validateComment(c); 

		c = p.getComment(); 
		// сделать что-нибудь еще 
	}
}
```

Не следует внедрять `CommentProcessor` непосредственно в бин `CommentService` — это было бы ошибкой. Бин `CommentService` является одиночным, а следовательно, Spring создаёт только один экземпляр этого класса. Таким образом, при создании бина `CommentService` Spring сразу внедрит и все зависимости класса. В итоге получим единственный экземпляр `CommentProcessor`. И этот уникальный экземпляр будет использоваться при каждом вызове метода `sendComment()`, поэтому при наличии нескольких потоков возникнет такое же состояние гонки, как и в случае одиночного бина. Данная ситуация продемонстрирована ниже.
```java
@Service
public class CommentService { 

	@Autowired 
	private CommentProcessor p; 
	
	public void sendComment(Comment c) {
		p.setComment(c); 
		p.processComment(c); 
		p.validateComment(c); 

		c = p.getComment(); 
		// что-нибудь еще 
	}
}
```

В качестве резюме сравним бины с одиночной и прототипной областями видимости.

| Одиночные бины                                                                                                               | Прототипные бины                                                                                      |
| ---------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| 1. Фреймворк ассоциирует имя с существующим экземпляром объекта                                                              | 1. Имя ассоциируется с типом                                                                          |
| 2. При обращении к бину по имени каждый раз получаем один и тот же экземпляр объекта                                         | 2. При обращении к бину по имени каждый раз получаем новый экземпляр                                  |
| 3. Можно настроить Spring так, чтобы экземпляр создавался при загрузке контекста или при первом обращении к этому экземпляру | 3. Фреймворк всегда создаёт экземпляры объектов с прототипной областью видимости при обращении к бину |
| 4. По умолчанию Spring создаёт бины с одиночной областью видимости                                                           | 4. Необходимо явно обозначить бин как прототипный                                                     |
| 5. Не рекомендуется создавать одиночные бины с изменяемыми атрибутами                                                        | 5. У прототипного бина могут быть изменяемые атрибуты                                                 |
